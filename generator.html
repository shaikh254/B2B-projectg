<!DOCTYPE html>
<html translate="no" lang="en">

<head>
    <meta name="google" content="notranslate">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-fr="G√©n√©rateur KDP - Cr√©ez vos Gabarits Conformes | GabaritKDP"
        data-en="KDP Generator - Create Your Compliant Templates | GabaritKDP">KDP Generator - Create Your Compliant
        Templates | GabaritKDP</title>
    <link rel="icon" type="image/png" href="logo-gabarit-kdp-site-web.png">
    <meta name="description"
        data-fr="Outil professionnel pour cr√©er des couvertures KDP aux dimensions exactes Amazon. Interface fran√ßaise, calculs pr√©cis."
        data-en="Professional tool to create KDP covers with exact Amazon dimensions. French interface, precise calculations."
        content="Professional tool to create KDP covers with exact Amazon dimensions. French interface, precise calculations.">

    <link rel="icon" type="image/png" href="logo-gabarit-kdp-site-web.png">
    
    <!-- üî§ GOOGLE FONTS - Polices pour les couvertures -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Merriweather:wght@400;700&family=Cinzel:wght@400;700&family=Cormorant+Garamond:wght@400;700&family=Libre+Baskerville:wght@400;700&family=Lora:wght@400;700&family=Spectral:wght@400;700&family=Crimson+Text:wght@400;700&family=EB+Garamond:wght@400;700&family=Bitter:wght@400;700&family=Roboto+Slab:wght@400;700&family=Oswald:wght@400;700&family=Montserrat:wght@400;700&family=Raleway:wght@400;700&family=Poppins:wght@400;700&family=Open+Sans:wght@400;700&family=Lato:wght@400;700&family=Dancing+Script:wght@400;700&family=Pacifico&family=Great+Vibes&family=Satisfy&family=Sacramento&family=Allura&family=Alex+Brush&family=Tangerine:wght@400;700&family=Pinyon+Script&family=Berkshire+Swash&family=Abril+Fatface&family=Alfa+Slab+One&family=Bangers&family=Permanent+Marker&family=Righteous&family=Creepster&family=Nosifer&family=Metal+Mania&family=Butcherman&family=Rubik+Glitch&family=Orbitron:wght@400;700&family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MYG5JJM8EC"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-MYG5JJM8EC');
    </script>

    <script src="https://cdn.tailwindcss.com"></script>

    <!-- üé¨ THREE.JS pour Mockup 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- üõí MARKETPLACE EARLY CAPTURE - DOIT √äTRE AVANT TOUT AUTRE SCRIPT -->
    <script>
    (function captureTemplateParamEarly() {
        try {
            const params = new URLSearchParams(window.location.search);
            const t = params.get("template") || params.get("img");
            if (t) {
                // Sauvegarder AVANT que OAuth ne nettoie l'URL
                sessionStorage.setItem("gkdp_template_url", t);
                window.__GKDP_TEMPLATE_URL__ = t;
                console.log("üõí [MARKETPLACE][EARLY] ‚úÖ Captured:", t);
            } else {
                console.log("üõí [MARKETPLACE][EARLY] No template param in URL");
            }
        } catch (e) {
            console.error("üõí [MARKETPLACE][EARLY] Error:", e);
        }
    })();
    </script>
    
    <script>
    (function() {
      'use strict';
      
      // ‚öôÔ∏è Configuration
      const CANVA_CONFIG = {
        CLIENT_ID: 'OC-AZnaRLvMwpXk', // CLIENT ID MIS √Ä JOUR
        SITE_ORIGIN: window.location.origin,
        CALLBACK_PATH: '/auth/callback.html',
        OAUTH_URL: 'https://www.canva.com/api/oauth/authorize',
        SCOPES: ['design:meta:read', 'design:content:read', 'asset:read']
      };

      console.log('üöÄ Initialisation Canva OAuth...');
      console.log('üìç Origin:', CANVA_CONFIG.SITE_ORIGIN);

      // =========================================================================
      // Utilitaires PKCE
      // =========================================================================
      
      function generateRandomString(length = 43) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
        const values = new Uint8Array(length);
        crypto.getRandomValues(values);
        return Array.from(values).map(v => chars[v % chars.length]).join('');
      }

      async function sha256(plain) {
        const encoder = new TextEncoder();
        const data = encoder.encode(plain);
        return await crypto.subtle.digest('SHA-256', data);
      }

      function base64urlencode(arrayBuffer) {
        const bytes = new Uint8Array(arrayBuffer);
        let str = '';
        bytes.forEach(byte => str += String.fromCharCode(byte));
        return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
      }

      async function generateCodeChallenge(verifier) {
        const hashed = await sha256(verifier);
        return base64urlencode(hashed);
      }

      // =========================================================================
      // Objet CanvaAuth global
      // =========================================================================
      
      window.CanvaAuth = {
        config: CANVA_CONFIG,

        /**
         * V√©rifie si l'utilisateur est authentifi√©
         */
        isAuthenticated() {
          const token = localStorage.getItem('canva_access_token');
          const expiry = parseInt(localStorage.getItem('canva_token_expiry') || '0', 10);
          
          if (!token || !expiry) {
            console.log('‚ùå Pas de token ou expiry');
            return false;
          }
          
          const isValid = Date.now() < (expiry - 300000); // 5min de marge
          // Log supprim√© pour √©viter le spam console
          return isValid;
        },

        /**
         * Obtient le token actuel
         */
        getToken() {
          if (!this.isAuthenticated()) return null;
          return localStorage.getItem('canva_access_token');
        },

        /**
         * Lance le processus de connexion OAuth
         */
        async initiateConnection() {
          console.log('üéØ D√©but connexion OAuth Canva...');
          
          try {
            // V√©rifier la config
            if (!CANVA_CONFIG.CLIENT_ID) {
              alert('‚ö†Ô∏è CLIENT_ID Canva non configur√© ! V√©rifiez le script.');
              console.error('‚ùå CLIENT_ID manquant ou invalide');
              return;
            }

            // 1. G√©n√©rer PKCE
            console.log('üîë G√©n√©ration PKCE...');
            const codeVerifier = generateRandomString(43);
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            
            console.log('‚úÖ Verifier g√©n√©r√©:', codeVerifier.substring(0, 10) + '...');
            console.log('‚úÖ Challenge g√©n√©r√©:', codeChallenge.substring(0, 10) + '...');

            // 2. Stocker le verifier
            sessionStorage.setItem('pkce_code_verifier', codeVerifier);
            localStorage.setItem('canva_pkce_verifier', codeVerifier);
            console.log('üíæ Verifier stock√© dans sessionStorage et localStorage');

            // 3. Construire l'URL
            const redirectUri = CANVA_CONFIG.SITE_ORIGIN + CANVA_CONFIG.CALLBACK_PATH;
            const state = generateRandomString(32);
            sessionStorage.setItem('oauth_state', state);

            const params = new URLSearchParams({
              client_id: CANVA_CONFIG.CLIENT_ID,
              redirect_uri: redirectUri,
              response_type: 'code',
              scope: CANVA_CONFIG.SCOPES.join(' '),
              code_challenge: codeChallenge,
              code_challenge_method: 'S256',
              state: state
            });

            const authUrl = `${CANVA_CONFIG.OAUTH_URL}?${params.toString()}`;
            
            console.log('üîó Redirect URI:', redirectUri);
            console.log('üåê URL OAuth compl√®te:', authUrl);
            console.log('üöÄ Redirection vers Canva...');

            // 4. Rediriger
            window.location.href = authUrl;

          } catch (error) {
            console.error('‚ùå Erreur initiation OAuth:', error);
            alert('Erreur lors de la connexion √† Canva: ' + error.message);
          }
        },

        /**
         * D√©connexion
         */
        logout() {
          console.log('üö™ D√©connexion Canva...');
          localStorage.removeItem('canva_access_token');
          localStorage.removeItem('canva_refresh_token');
          localStorage.removeItem('canva_token_expiry');
          localStorage.removeItem('canva_pkce_verifier');
          sessionStorage.removeItem('pkce_code_verifier');
          sessionStorage.removeItem('oauth_state');
          console.log('‚úÖ D√©connexion compl√®te');
        },

        /**
         * Test de connexion
         */
        async testConnection() {
          const token = this.getToken();
          if (!token) {
            console.error('‚ùå Pas de token pour tester');
            return false;
          }

          try {
            console.log('üß™ Test de connexion API Canva...');
            const response = await fetch('https://api.canva.com/rest/v1/users/me', {
              headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
              const data = await response.json();
              console.log('‚úÖ Connexion OK, utilisateur:', data);
              return true;
            } else {
              console.error('‚ùå Connexion √©chou√©e:', response.status);
              return false;
            }
          } catch (error) {
            console.error('‚ùå Erreur test connexion:', error);
            return false;
          }
        }
      };

      console.log('‚úÖ window.CanvaAuth cr√©√© et pr√™t');
      console.log('üì± Utilisez window.CanvaAuth.initiateConnection() pour connecter');
      
      // Test au chargement
      if (window.CanvaAuth.isAuthenticated()) {
        console.log('‚úÖ Utilisateur d√©j√† authentifi√©');
      } else {
        console.log('‚ÑπÔ∏è Utilisateur non authentifi√©');
      }

    })();
    </script>

    <!-- üîê SUPABASE - V√©rification abonnement -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
    (async function checkSubscriptionStatus() {
        const SUPABASE_URL = 'https://kucwdaicplajljpfkzhu.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt1Y3dkYWljcGxhamxqcGZremh1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE5MzMxMjQsImV4cCI6MjA3NzUwOTEyNH0.0IDHysD84_0ghjb-a4K0UkNrJbzdQBKUjm5mQbSfro8';
        
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Exposer globalement
        window.supabaseClient = supabase;
        window.dispatchEvent(new Event('supabase:ready'));
        console.log('‚úÖ [SUPABASE] Client initialis√©');
        
        // üîß FONCTION GLOBALE: V√©rifier si l'utilisateur est connect√©
        window.isUserLoggedIn = function() {
            return !!localStorage.getItem('userEmail');
        };
        
        // üîß FONCTION GLOBALE: Obtenir les cr√©dits restants
        window.getExportCredits = function() {
            const isPro = localStorage.getItem('userProfile') === 'pro';
            if (isPro) return Infinity;
            return parseInt(localStorage.getItem('exportCredits') || '0', 10);
        };
        
        // üîß FONCTION GLOBALE: D√©compter un export (async)
        window.decrementExportCredit = async function() {
            try {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session || !session.user) {
                    console.log('Pas de session ‚Üí pas de d√©cr√©ment');
                    return false;
                }
                
                const userId = session.user.id;
                
                // 1) R√©cup√©rer les cr√©dits actuels
                const { data: profile, error: fetchError } = await supabase
                    .from('user_profiles')
                    .select('exports_available, total_exports_used, is_pro')
                    .eq('id', userId)
                    .single();
                
                if (fetchError || !profile) {
                    console.error('Erreur r√©cup√©ration cr√©dits', fetchError);
                    return false;
                }
                
                // Si PRO, pas de d√©cr√©ment
                if (profile.is_pro) {
                    console.log('‚úÖ [EXPORT] Utilisateur PRO - exports illimit√©s');
                    return true;
                }
                
                if (profile.exports_available <= 0) {
                    console.log('Plus de cr√©dits disponibles');
                    return false;
                }
                
                // 2) D√©cr√©menter dans Supabase
                const { error: updateError } = await supabase
                    .from('user_profiles')
                    .update({
                        exports_available: profile.exports_available - 1,
                        total_exports_used: (profile.total_exports_used || 0) + 1
                    })
                    .eq('id', userId);
                
                if (updateError) {
                    console.error('Erreur d√©cr√©ment export', updateError);
                    return false;
                }
                
                // 3) Mettre √† jour localStorage pour l'UI
                const newCredits = profile.exports_available - 1;
                localStorage.setItem('exportCredits', newCredits.toString());
                console.log('‚úÖ [EXPORT] Cr√©dit d√©compt√©:', newCredits, 'restants');
                return true;
            } catch (e) {
                console.error('‚ùå [EXPORT] Erreur:', e);
                return false;
            }
        };
        
        // üîß FONCTION GLOBALE: Rafra√Æchir les cr√©dits depuis Supabase
        window.refreshExportCredits = async function() {
            try {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session || !session.user) return 0;
                
                const { data, error } = await supabase
                    .from('user_profiles')
                    .select('exports_available, is_pro')
                    .eq('id', session.user.id)
                    .single();
                
                if (data) {
                    localStorage.setItem('exportCredits', data.exports_available.toString());
                    if (data.is_pro) localStorage.setItem('userProfile', 'pro');
                    return data.exports_available;
                }
            } catch (e) {
                console.error('‚ùå [REFRESH] Erreur:', e);
            }
            return 0;
        };
        
        try {
            const { data: { session } } = await supabase.auth.getSession();
            
            if (session && session.user) {
                console.log('üë§ [AUTH] Utilisateur connect√©:', session.user.email);
                
                // Chercher le profil par ID (plus fiable)
                let { data: userData, error } = await supabase
                    .from('user_profiles')
                    .select('is_pro, exports_available, subscription_type')
                    .eq('id', session.user.id)
                    .single();
                
                // Si pas de profil trouv√©, le cr√©er automatiquement (inscription sociale)
                if (error || !userData) {
                    console.log('üìù [AUTH] Cr√©ation profil FREE pour nouvel utilisateur social...');
                    
                    const { error: insertError } = await supabase
                        .from('user_profiles')
                        .insert({
                            id: session.user.id,
                            email: session.user.email,
                            is_pro: false,
                            exports_available: 3,
                            total_exports_used: 0
                        });
                    
                    if (insertError) {
                        console.error('‚ùå [AUTH] Erreur cr√©ation profil:', insertError);
                    } else {
                        console.log('‚úÖ [AUTH] Profil FREE cr√©√© avec 3 exports!');
                        userData = { is_pro: false, exports_available: 3, subscription_type: null };
                    }
                }
                
                console.log('üìä [AUTH] Donn√©es utilisateur:', userData);
                
                if (userData) {
                    if (userData.is_pro === true) {
                        localStorage.setItem('userProfile', 'pro');
                    } else {
                        localStorage.removeItem('userProfile');
                    }
                    if (userData.subscription_type) {
                        localStorage.setItem('subscription_type', userData.subscription_type);
                    }
                    localStorage.setItem('exportCredits', (userData.exports_available || 0).toString());
                    console.log('‚úÖ [AUTH] Cr√©dits exports:', userData.exports_available);
                }
                
                localStorage.setItem('userEmail', session.user.email);
            } else {
                console.log('‚ÑπÔ∏è [AUTH] Aucun utilisateur connect√©');
                localStorage.removeItem('userProfile');
                localStorage.removeItem('userEmail');
                localStorage.removeItem('exportCredits');
            }
        } catch (err) {
            console.error('‚ùå [AUTH] Erreur:', err);
        }
    })();
    </script>

    <!-- üíæ DESIGN SAVE SYSTEM - Sauvegarde pour redirection inscription -->
    <script>
    (function() {
        'use strict';
        
        const STORAGE_KEY = 'gkdp_saved_design';
        const TEMP_STORAGE_KEY = 'gkdp_temp_design'; // Pour les non-connect√©s avant inscription
        const ACTIVE_TEMPLATE_KEY = 'gkdp_active_template_url'; // Template actuellement actif (Marketplace)
        const LIBRARY_KEY = 'gkdp_design_library_v1'; // Biblioth√®que de designs (local)

        // üéØ Template actif (permet d'√©viter de restaurer un ancien design sur un nouveau template)
        window.setActiveTemplateUrl = function(url) {
            try {
                if (!url) {
                    localStorage.removeItem(ACTIVE_TEMPLATE_KEY);
                    return;
                }
                localStorage.setItem(ACTIVE_TEMPLATE_KEY, url);
            } catch (e) {
                console.error('‚ùå [ACTIVE TEMPLATE] Error:', e);
            }
        };

        window.getActiveTemplateUrl = function() {
            try {
                return localStorage.getItem(ACTIVE_TEMPLATE_KEY) || null;
            } catch (e) {
                return null;
            }
        };

        // üìö Design Library (localStorage) ‚Äî CRUD
        function readLibrary() {
            try {
                const raw = localStorage.getItem(LIBRARY_KEY);
                const arr = raw ? JSON.parse(raw) : [];
                return Array.isArray(arr) ? arr : [];
            } catch (e) {
                console.error('‚ùå [LIBRARY] read error:', e);
                return [];
            }
        }

        function writeLibrary(items) {
            try {
                localStorage.setItem(LIBRARY_KEY, JSON.stringify(items || []));
                return true;
            } catch (e) {
                console.error('‚ùå [LIBRARY] write error:', e);
                return false;
            }
        }

        function genId() {
            try {
                return (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('id_' + Date.now() + '_' + Math.random().toString(16).slice(2));
            } catch (e) {
                return 'id_' + Date.now() + '_' + Math.random().toString(16).slice(2);
            }
        }

        window.gkdpListDesigns = function() {
            const items = readLibrary();
            // Tri: r√©cemment utilis√©s d'abord
            return items.sort((a,b) => (b.lastUsedAt || b.updatedAt || b.createdAt || '').localeCompare(a.lastUsedAt || a.updatedAt || a.createdAt || ''));
        };

        window.gkdpGetDesign = function(id) {
            const items = readLibrary();
            return items.find(d => d && d.id === id) || null;
        };

        // Upsert: cr√©e si pas d'id, sinon update
        window.gkdpUpsertDesign = function(payload) {
            try {
                const items = readLibrary();
                const now = new Date().toISOString();
                const id = payload && payload.id ? payload.id : genId();

                const templateUrl = (payload && payload.templateUrl) || window.getActiveTemplateUrl?.() || null;
                const title = (payload && payload.title) || 'Untitled design';

                const designData = (payload && payload.designData) ? payload.designData : null;

                const existingIdx = items.findIndex(d => d && d.id === id);
                const record = {
                    id,
                    templateUrl,
                    title,
                    designData,
                    createdAt: existingIdx >= 0 ? (items[existingIdx].createdAt || now) : now,
                    updatedAt: now,
                    lastUsedAt: payload && payload.lastUsedAt ? payload.lastUsedAt : (existingIdx >= 0 ? (items[existingIdx].lastUsedAt || null) : null)
                };

                if (existingIdx >= 0) items[existingIdx] = { ...items[existingIdx], ...record };
                else items.unshift(record);

                writeLibrary(items);
                return record;
            } catch (e) {
                console.error('‚ùå [LIBRARY] upsert error:', e);
                return null;
            }
        };

        window.gkdpTouchDesign = function(id) {
            try {
                const items = readLibrary();
                const idx = items.findIndex(d => d && d.id === id);
                if (idx < 0) return null;
                const now = new Date().toISOString();
                items[idx] = { ...items[idx], lastUsedAt: now, updatedAt: now };
                writeLibrary(items);
                return items[idx];
            } catch (e) {
                return null;
            }
        };

        window.gkdpDeleteDesign = function(id) {
            try {
                const items = readLibrary();
                const next = items.filter(d => d && d.id !== id);
                writeLibrary(next);
                return true;
            } catch (e) {
                return false;
            }
        };

        
        // üíæ Sauvegarder le design TEMPORAIREMENT (avant redirection vers inscription)
        window.saveTempDesign = function(designData) {
            try {
                const dataToSave = {
                    ...designData,
                    templateUrl: (designData && designData.templateUrl) ? designData.templateUrl : (window.getActiveTemplateUrl ? window.getActiveTemplateUrl() : null),
                    savedAt: new Date().toISOString()
                };
                localStorage.setItem(TEMP_STORAGE_KEY, JSON.stringify(dataToSave));
                console.log('üíæ [TEMP SAVE] ‚úÖ Design temporaire sauvegard√©!');
                return true;
            } catch (e) {
                console.error('üíæ [TEMP SAVE] Erreur:', e);
                return false;
            }
        };
        
        // üíæ Charger le design temporaire (apr√®s connexion)
        window.loadTempDesign = function() {
            try {
                const saved = localStorage.getItem(TEMP_STORAGE_KEY);
                if (!saved) return null;
                console.log('üíæ [TEMP LOAD] ‚úÖ Design temporaire trouv√©!');
                return JSON.parse(saved);
            } catch (e) {
                console.error('üíæ [TEMP LOAD] Erreur:', e);
                return null;
            }
        };
        
        // üíæ Effacer le design temporaire
        window.clearTempDesign = function() {
            localStorage.removeItem(TEMP_STORAGE_KEY);
            console.log('üíæ [TEMP CLEAR] Design temporaire effac√©');
        };
        
        // üíæ Sauvegarder le design permanent (pour utilisateurs connect√©s)
        window.saveDesignPermanent = function(designData) {
            if (!window.isUserLoggedIn || !window.isUserLoggedIn()) {
                return false;
            }
            try {
                const dataToSave = {
                    ...designData,
                    templateUrl: (designData && designData.templateUrl) ? designData.templateUrl : (window.getActiveTemplateUrl ? window.getActiveTemplateUrl() : null),
                    savedAt: new Date().toISOString(),
                    userEmail: localStorage.getItem('userEmail')
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                console.log('üíæ [PERM SAVE] ‚úÖ Design permanent sauvegard√©!');
                return true;
            } catch (e) {
                console.error('üíæ [PERM SAVE] Erreur:', e);
                return false;
            }
        };
        
        // üíæ Charger le design permanent
        window.loadPermanentDesign = function() {
            if (!window.isUserLoggedIn || !window.isUserLoggedIn()) {
                return null;
            }
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (!saved) return null;
                const data = JSON.parse(saved);
                if (data.userEmail !== localStorage.getItem('userEmail')) {
                    return null;
                }
                console.log('üíæ [PERM LOAD] ‚úÖ Design permanent trouv√©!');
                return data;
            } catch (e) {
                console.error('üíæ [PERM LOAD] Erreur:', e);
                return null;
            }
        };
        
        // üíæ Sauvegarder le design actuel dans la biblioth√®que
        window.gkdpSaveCurrentDesign = function() {
            try {
                // R√©cup√©rer le design actuel depuis React
                if (!window.getCurrentDesignData) {
                    console.error('‚ùå [LIBRARY SAVE] getCurrentDesignData manquant');
                    alert('Erreur: impossible de r√©cup√©rer le design actuel');
                    return false;
                }

                const data = window.getCurrentDesignData();
                if (!data) {
                    console.error('‚ùå [LIBRARY SAVE] Aucun design √† sauvegarder');
                    alert('Aucun design √† sauvegarder');
                    return false;
                }

                // Demander un titre
                const title = prompt('Nom du design:', data.title || 'Mon design');
                if (!title) return false; // Annul√©

                // Cr√©er l'objet design
                const design = {
                    id: 'dsg_' + Date.now(),
                    title: title,
                    templateUrl: window.getActiveTemplateUrl?.() || null,
                    designData: data,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    lastUsedAt: new Date().toISOString()
                };

                // Ajouter √† la biblioth√®que
                const result = window.gkdpUpsertDesign(design);
                
                if (result) {
                    console.log('üíæ [LIBRARY SAVE] Design sauvegard√©:', result);
                    alert('‚úÖ Design sauvegard√© !');
                    return true;
                } else {
                    console.error('‚ùå [LIBRARY SAVE] √âchec de la sauvegarde');
                    alert('‚ùå Erreur lors de la sauvegarde');
                    return false;
                }

            } catch (e) {
                console.error('‚ùå [LIBRARY SAVE] Erreur:', e);
                alert('‚ùå Erreur: ' + e.message);
                return false;
            }
        };
        
        console.log('üíæ [DESIGN SAVE] Syst√®me initialis√©');
    })();
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.4/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="js/canva-integration.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "t09tdy9nqm");
</script>
    <style>html, body {
    height: 100%;
    overflow-y: scroll; /* FIX JUMP: force consistent scrollbar to avoid layout shift */
}

        /* üíæ Animations pour les notifications */
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideInCenter {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }


        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        #kdp-generator-container {
            min-height: 90vh; /* R√©serve l'espace pour l'application React pendant son chargement pour √©viter le saut de page */
    display: flex;
    align-items: center;
    justify-content: center;}

  .language-selector {
    background: #fff;
    border-radius: 20px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, .1);
    padding: 3px;
  }

  .lang-btn {
    padding: 6px 10px;
    border: none;
    background: transparent;
    border-radius: 16px;
    cursor: pointer;
    transition: .3s;
    font-weight: 500;
    font-size: .8rem;
  }

  .lang-btn.active {
    background: #FF9900;
    color: #fff
  }

        .header-nav {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            padding: 15px 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 999;
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            flex-wrap: wrap;
        }

        .logo-nav {
            display: flex;
            align-items: center;
            gap: 15px;
            text-decoration: none;
            color: white;
            flex-shrink: 0;
        }

        .logo-nav img {
            height: 40px;
            width: auto;
        }

        .logo-nav span {
            font-size: 1.3rem;
            font-weight: 700;
            color: #FF9900;
        }

        .nav-links {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 25px;
            flex-wrap: wrap;
        }

        .nav-links a {
            color: white;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
            padding: 10px 14px;
            border-radius: 8px;
            position: relative;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.95rem;
        }

        .nav-links a:hover {
            color: #FF9900;
            background: rgba(255, 153, 0, 0.1);
        }

        .express-nav-btn {
            background: linear-gradient(135deg, #10b981, #059669) !important;
            color: white !important;
            border-radius: 8px !important;
        }

        .express-nav-btn:hover {
            background: linear-gradient(135deg, #0d9488, #047857) !important;
            transform: translateY(-2px) !important;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4) !important;
        }

        .f-exp-gene {
            background: linear-gradient(135deg, #10b981, #059669) !important;
            padding: 8px 10px;
            border-radius: 5px;
        }

        .f-exp-gene:hover {
            background: linear-gradient(135deg, #0d9488, #047857) !important;
            color: #FFFFFF;
        }

        .express-nav-btn::before,
        .f-exp-gene::before {
            content: "‚ö°";
            margin-right: 4px;
        }

        .mobile-menu {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            z-index: 999;
            padding: 80px 20px 20px;
            overflow-y: auto;
        }

        .mobile-menu.active {
            display: block;
            animation: slideIn 0.3s ease;
        }

        .social-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .social-links {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .social-link {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            color: white;
            text-decoration: none;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .social-link:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .social-link.youtube {
            background: linear-gradient(135deg, #FF0000, #CC0000);
        }

        .social-link.facebook {
            background: linear-gradient(135deg, #1877F2, #0866D3);
        }

        .social-link.instagram {
            background: linear-gradient(135deg, #E4405F, #C13584, #8A2BE2);
        }

        .social-link.pinterest {
            background: linear-gradient(135deg, #BD081C, #E60023);
        }

        .social-link.tiktok {
            background: linear-gradient(135deg, #000000, #FF0050, #00F2EA);
        }

        .social-link.linkedin {
            background: linear-gradient(135deg, #0A66C2, #004182);
        }        

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .mobile-menu-links {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 400px;
            margin: 0 auto;
        }

        .mobile-menu-links a {
            color: white;
            text-decoration: none;
            font-weight: 600;
            padding: 15px 20px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.1rem;
        }

        .mobile-menu-links a:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .mobile-menu-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
        }

         .generator-layout {
    display: grid;
    grid-template-columns: 340px 1fr 300px;
    gap: 20px;
    max-width: 1800px;
    margin: 0 auto;
    padding: 20px;
}

        .preview-zone {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-height: 600px;
            height: fit-content;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e5e7eb;
            gap: 15px;
        }

        .preview-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preview-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .zoom-btn {
            background: #6b7280;
            color: white;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .zoom-btn:hover {
            background: #4b5563;
            transform: scale(1.05);
        }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            border-radius: 12px;
            padding: 40px 20px;
            overflow: visible;
            position: relative;
            min-height: 400px;
        }

        .canvas-4k {
            border: 3px solid #d1d5db;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            background: white;
            transition: all 0.3s ease;
        }

        .canvas-4k:hover {
            box-shadow: 0 15px 60px rgba(0, 0, 0, 0.25);
            transform: scale(1.02);
        }

        .position-labels {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 40px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 20px;
            border-radius: 20px;
            border: 1px solid #e5e7eb;
            font-weight: 600;
            font-size: 0.875rem;
            color: #374151;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .dimensions-overlay {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            backdrop-filter: blur(5px);
        }

        .sidebar {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            height: fit-content;
            max-height: none;
            overflow-y: visible;
        }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
        }

        .sidebar-section:last-child {
            border-bottom: none;
        }

        .sidebar-title {
            font-size: 1.125rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .quality-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 3px 15px rgba(139, 92, 246, 0.4);
        }

        .validation-smart {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }

        .validation-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .validation-score {
            padding: 16px 20px;
            text-align: center;
            border-bottom: 1px solid #e2e8f0;
        }

        .score-excellent {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 700;
            margin-bottom: 12px;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .score-tres-bon {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 700;
            margin-bottom: 12px;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }

        .score-acceptable {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 700;
            margin-bottom: 12px;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }

        .score-problematique {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 700;
            margin-bottom: 12px;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }

        .validation-alerts {
            padding: 16px 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .alert-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            font-size: 0.875rem;
            line-height: 1.4;
        }

        .alert-excellent {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.2);
            color: #065f46;
        }

        .alert-good {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            color: #1e3a8a;
        }

        .alert-warning {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.2);
            color: #92400e;
        }

        .alert-critical {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            color: #991b1b;
        }

        .alert-info {
            background: rgba(99, 102, 241, 0.1);
            border: 1px solid rgba(99, 102, 241, 0.2);
            color: #3730a3;
        }

        .alert-icon {
            font-size: 1rem;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .validation-tips {
            background: #f8fafc;
            padding: 16px 20px;
            border-top: 1px solid #e2e8f0;
        }

        .tips-title {
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tip-item {
            font-size: 0.75rem;
            color: #6b7280;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .no-analysis {
            text-align: center;
            padding: 40px 20px;
            color: #6b7280;
        }

        /* Canva Spinners */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spinner {
            animation: spin 1s linear infinite;
        }

        .spinner-small {
            animation: spin 1s linear infinite;
        }

        .format-alert-critical {
            background: linear-gradient(135deg, #dc2626, #991b1b);
            color: white;
            padding: 16px;
            border-radius: 12px;
            margin: 16px 0;
            border: 2px solid #b91c1c;
            box-shadow: 0 4px 20px rgba(220, 38, 38, 0.3);
        }

        .format-alert-critical .alert-title {
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .format-alert-critical .alert-content {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        @media (max-width: 1400px) {
            .generator-layout {
                grid-template-columns: 300px 1fr 280px;
                gap: 15px;
                padding: 15px;
            }
        }

        @media (max-width: 1250px) {
            .generator-layout {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 15px;
            }

            .preview-zone {
                min-height: 500px;
                order: 2;
            }

            .sidebar {
                max-height: none;
                order: 1;
            }

            .sidebar:last-child {
                order: 3;
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
    .language-selector {
      top: 22.5px;
      right: 60px
    }

            .nav-links {
                display: none;
            }

            .mobile-menu-toggle {
                display: block;
                background: none;
                border: none;
                color: white;
                font-size: 1.5rem;
                cursor: pointer;
                padding: 8px;
                margin-left: auto;
            }
        }

        @media (min-width: 769px) {
            .mobile-menu-toggle {
                display: none;
            }
        }
        .feedback-section {
            width: 100%;
            padding: 4rem 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
        }
        .feedback-section h3 {
            color: #1e293b;
            font-weight: 900;
            font-size: 48px;
            line-height: 1;
        }
        .feedback-section p {
            margin-top: 16px;
            font-size: 18px;
            color: #4B5563;
        }
        .feedback-section button {
            background: #10B981;
            color: #FFFFFF;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 5px;
            max-width: 250px;
            width: 100%;
            font-weight: 600;
            margin-top: 40px;
            transition: 0.3s;
        }
        .feedback-section button:hover {
            background: #16A34A;
        }
        @media(max-width:769px) {
            .feedback-section h3 {
            color: #1e293b;
            font-weight: 900;
            font-size: 36px;
            line-height: 1;
        }
        }        
    
.notranslate { unicode-bidi: plaintext; }
/* ============================================================
   STYLES POUR L'IMPORT CANVA DESIGNS
   ============================================================ */

/* Conteneur de la grille de designs */
#canva-designs-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 1rem;
  max-height: 600px;
  overflow-y: auto;
  padding: 0.5rem;
}

/* Scrollbar personnalis√©e */
#canva-designs-container::-webkit-scrollbar {
  width: 8px;
}

#canva-designs-container::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

#canva-designs-container::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

#canva-designs-container::-webkit-scrollbar-thumb:hover {
  background: #555;
}

/* Carte de design */
.canva-design-item {
  border: 2px solid #e5e7eb;
  border-radius: 0.5rem;
  padding: 1rem;
  transition: all 0.2s ease;
  cursor: pointer;
  background: white;
}

.canva-design-item:hover {
  border-color: #3b82f6;
  box-shadow: 0 4px 12px -1px rgba(0, 0, 0, 0.1);
  transform: translateY(-2px);
}

.canva-design-item.selected {
  border-color: #10b981;
  background-color: #f0fdf4;
}

/* Zone de pr√©visualisation */
.canva-design-preview {
  width: 100%;
  height: 150px;
  background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
  border-radius: 0.375rem;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 0.75rem;
}

.canva-design-preview img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

/* Info du design */
.canva-design-info {
  margin-top: 0.75rem;
}

.canva-design-title {
  font-weight: 600;
  font-size: 0.875rem;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: #1f2937;
  margin-bottom: 0.25rem;
}

.canva-design-size {
  font-size: 0.75rem;
  color: #6b7280;
  margin-bottom: 0.75rem;
}

/* Boutons d'import */
.btn-import-design {
  font-size: 0.75rem;
  padding: 0.375rem 0.75rem;
  border-radius: 0.375rem;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
}

.btn-import-design:hover {
  transform: scale(1.05);
}

.btn-import-design:active {
  transform: scale(0.95);
}

.btn-import-design:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

/* Animation de chargement */
@keyframes pulse-loading {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.animate-pulse {
  animation: pulse-loading 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* ========================================
   RESPONSIVE DESIGN COMPLET
   ======================================== */



/* Tablettes */
@media (max-width: 992px) {
    /* .generator-layout {
        grid-template-columns: 280px 1fr;
        gap: 15px;
    }
     */
    .preview-zone {
        padding: 15px;
    }
    
    .preview-title {
        font-size: 1.25rem;
    }
}

/* Mobile - Portrait */
@media (max-width: 768px) {
    /* .generator-layout {
        grid-template-columns: 1fr;
        gap: 15px;
        padding: 10px;
    }
     */
    /* Sidebars en pleine largeur sur mobile */
    .sidebar {
        width: 100%;
        max-width: 100%;
        margin: 0;
        padding: 0;
    }
    
    .sidebar-section {
        padding: 15px;
    }
    
    .sidebar-title {
        font-size: 1rem;
    }
    
    .preview-zone {
        padding: 15px;
        min-height: auto;
    }
    
    .preview-title {
        font-size: 1.1rem;
    }
    
    .preview-controls {
        flex-wrap: wrap;
        gap: 8px;
    }
    
    .zoom-btn {
        width: 32px;
        height: 32px;
        font-size: 25px;
    }
    
    .canvas-container {
        min-height: 300px;
        padding: 10px;
    }
    
    /* Ajuster les formulaires sur mobile */
    input[type="text"],
    input[type="number"],
    select,
    textarea {
        font-size: 16px !important; /* √âvite le zoom iOS */
        padding: 10px;
        width: 100%;
    }
    
    button {
        min-height: 44px; /* Taille tactile optimale */
        padding: 10px 16px;
    }
    
    /* Guide rapide - texte plus petit sur mobile */
    .sidebar-section .text-sm {
        font-size: 0.875rem;
    }
    
    .sidebar-section .text-xs {
        font-size: 0.75rem;
    }
    
    /* Canvas settings */
    .canvas-settings {
        padding: 12px;
    }
    
    .canvas-settings h3 {
        font-size: 1rem;
    }
    
    /* Espacements r√©duits sur mobile */
    .space-y-4 > * + * {
        margin-top: 0.75rem;
    }
    
    .space-y-3 > * + * {
        margin-top: 0.5rem;
    }
}

/* Petit mobile */
@media (max-width: 480px) {
    .generator-layout {
        padding: 8px;
        gap: 12px;
    }
    
    .sidebar-section {
        padding: 12px;
    }
    
    .sidebar-title {
        font-size: 0.95rem;
    }
    
    .preview-zone {
        padding: 12px;
        border-radius: 8px;
    }
    
    .preview-title {
        font-size: 1rem;
        flex-direction: column;
        gap: 5px;
        align-items: flex-start;
    }
    
    .preview-controls {
        width: 100%;
        justify-content: space-between;
    }
    
    .canvas-container {
        min-height: 250px;
    }
    
    /* Textes plus petits */
    body {
        font-size: 14px;
    }
    
    h1 {
        font-size: 1.5rem;
    }
    
    h2 {
        font-size: 1.25rem;
    }
    
    h3 {
        font-size: 1.1rem;
    }
    
    /* Select et inputs plus grands pour tactile */
    select,
    input[type="text"],
    input[type="number"] {
        font-size: 16px !important;
        padding: 12px;
        min-height: 44px;
    }
    
    /* Boutons empil√©s et plus grands */
    .button-group {
        flex-direction: column;
        width: 100%;
    }
    
    .button-group button {
        width: 100%;
        min-height: 44px;
    }
    
    /* Am√©liorer l'espacement du guide */
    .sidebar-section .space-y-3 > * + * {
        margin-top: 0.75rem;
    }
    
    /* Texte du guide plus lisible */
    .sidebar-section p {
        line-height: 1.5;
    }
}

/* Tr√®s petit mobile */
@media (max-width: 360px) {
    .generator-layout {
        padding: 5px;
    }
    
    .sidebar-section {
        padding: 10px;
    }
    
    .preview-zone {
        padding: 10px;
    }
    
    .preview-title {
        font-size: 0.9rem;
    }
    
    input[type="text"],
    input[type="number"],
    select {
        font-size: 14px !important;
        padding: 10px;
    }
    
    button {
        padding: 8px 12px;
        font-size: 14px;
    }
    
    /* Texte encore plus compact */
    .sidebar-section .text-sm {
        font-size: 0.8125rem;
    }
    
    .sidebar-section .text-xs {
        font-size: 0.6875rem;
    }
}

/* Pr√©venir les d√©bordements sur tous les √©crans */
* {
    box-sizing: border-box;
}

img {
    max-width: 100%;
    height: auto;
}

/* Gestion du d√©bordement de texte */
.sidebar-section p,
.sidebar-section div {
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
}

/* Am√©lioration tactile globale */
@media (hover: none) and (pointer: coarse) {
    /* Appareils tactiles */
    button,
    select,
    input,
    a {
        min-height: 44px;
        min-width: 44px;
    }
    
    /* Espacements plus g√©n√©reux pour le tactile */
    .sidebar-section {
        padding: 16px;
    }
    
    /* √âviter les hover effects sur tactile */
    button:hover,
    a:hover {
        transform: none;
    }
}

/* Responsive */
@media (max-width: 768px) {
  #canva-designs-container {
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 0.75rem;
    max-height: 400px;
  }
  
  .canva-design-preview {
    height: 120px;
  }
  
  .canva-design-title {
    font-size: 0.8125rem;
  }
}

@media (max-width: 480px) {
  #canva-designs-container {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* üìö MOCKUP 3D STYLES */
.mockup-3d-container {
    perspective: 1500px;
    perspective-origin: center center;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 400px;
    background: linear-gradient(145deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
    border-radius: 12px;
    padding: 40px;
    position: relative;
    overflow: hidden;
}

.mockup-3d-container::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    height: 40%;
    background: radial-gradient(ellipse at center, rgba(255,255,255,0.1) 0%, transparent 70%);
    pointer-events: none;
}

.book-3d {
    position: relative;
    transform-style: preserve-3d;
    transition: transform 0.5s ease;
}

.book-3d.perspective {
    transform: rotateY(-25deg) rotateX(5deg);
}

.book-3d.flat {
    transform: rotateY(-5deg) rotateX(2deg);
}

.book-3d.standing {
    transform: rotateY(-35deg) rotateX(10deg);
}

.book-3d:hover {
    transform: rotateY(-15deg) rotateX(3deg);
}

.book-front {
    position: relative;
    box-shadow: 
        5px 5px 20px rgba(0,0,0,0.4),
        inset -2px 0 10px rgba(0,0,0,0.2);
    border-radius: 0 3px 3px 0;
    overflow: hidden;
    backface-visibility: hidden;
}

.book-spine {
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    transform-origin: left center;
    transform: rotateY(-90deg);
    background: linear-gradient(90deg, #1a1a1a 0%, #2a2a2a 50%, #1a1a1a 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
}

.book-spine-text {
    writing-mode: vertical-rl;
    text-orientation: mixed;
    transform: rotate(180deg);
    color: white;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-height: 90%;
    padding: 10px 5px;
}

.book-back {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    transform: translateZ(-20px);
    background: #1a1a1a;
    border-radius: 3px 0 0 3px;
}

.mockup-3d-controls {
    position: absolute;
    bottom: 15px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    background: rgba(255,255,255,0.1);
    padding: 8px 12px;
    border-radius: 20px;
    backdrop-filter: blur(10px);
}

.mockup-3d-controls button {
    padding: 6px 12px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 600;
    transition: all 0.2s;
    border: none;
    cursor: pointer;
}

.mockup-3d-controls button.active {
    background: linear-gradient(135deg, #f59e0b, #d97706);
    color: white;
}

.mockup-3d-controls button:not(.active) {
    background: rgba(255,255,255,0.1);
    color: white;
}

.mockup-3d-controls button:hover:not(.active) {
    background: rgba(255,255,255,0.2);
}

.view-toggle {
    display: flex;
    background: #e5e7eb;
    border-radius: 8px;
    padding: 3px;
    gap: 2px;
}

.view-toggle button {
    padding: 6px 16px;
    border: none;
    border-radius: 6px;
    font-weight: 600;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
}

.view-toggle button.active {
    background: white;
    color: #1f2937;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.view-toggle button:not(.active) {
    background: transparent;
    color: #6b7280;
}

.view-toggle button:hover:not(.active) {
    color: #374151;
}

@media (max-width:480px) {
    .language-selector {
      right: 60px;
      padding: 2px;
      top: 27px
    }

    .lang-btn {
      padding: 4px 8px;
      font-size: .7rem
    }
}

</style>
    <script src="canva-designs-fetcher.js" defer></script>



</head>

<body>

    <header class="header-nav">
        <div class="nav-container">
            <a href="./index.html" class="logo-nav">
                <img src="logo-gabarit-kdp-site-web.png" alt="GabaritKDP Logo">
                <span>GabaritKDP</span>
            </a>
            <button class="mobile-menu-toggle" onclick="toggleMobileMenu()"><i class="fas fa-bars"></i></button>
            <div class="language-selector">
                <button class="lang-btn" data-lang="fr" onclick="switchLanguage('fr')">üá´üá∑</button>
                <button class="lang-btn active" data-lang="en" onclick="switchLanguage('en')">üá∫üá∏</button>
            </div>
      <!-- Navigation Desktop -->
      <nav class="nav-links">
        <a href="./index.html" data-fr="üè† Accueil" data-en="üè† Home">üè† Home</a>
        <a href="./dashboard.html" data-fr="üìä tableau de bord" data-en="üìä Dashboard">üìä Dashboard</a>
        <a href="./generator.html" class="express-nav-btn" data-fr="G√©n√©rateur Express"
          data-en="Express Generator">G√©n√©rateur Express</a>
        <a href="./generator-magic.html" data-fr="G√©n√©rateur Magique" data-en="Magic Generator">G√©n√©rateur Magique</a>
        <a href="./marketplace.html" data-fr="march√©" data-en="Marketplace">Marketplace</a>
        <a href="./inscription.html" data-fr="üìù Inscription" data-en="üìù Sign Up">üìù Sign Up</a>
        <a href="./connexion.html" data-fr="üîì Connexion" data-en="üîì Login">üîì Login</a>
      </nav>
    </div>
  </header>

  <!-- Menu Mobile -->
  <div class="mobile-menu" id="mobileMenu">
    <button class="mobile-menu-close" onclick="toggleMobileMenu()"><i class="fas fa-times"></i></button>
    <div class="mobile-menu-links">
      <a href="./index.html" data-fr="üè† Accueil" data-en="üè† Home">üè† Home</a>
      <a href="./dashboard.html" data-fr="üìä tableau de bord" data-en="üìä Dashboard">üìä Dashboard</a>
      <a href="./generator.html" style="background:linear-gradient(135deg,#10b981,#059669);border-color:#10b981;"
        data-fr="‚ö° G√©n√©rateur Express" data-en="‚ö° Express Generator">‚ö° G√©n√©rateur Express</a>
      <a href="./generator-magic.html" data-fr="G√©n√©rateur Magique" data-en="Magic Generator">G√©n√©rateur Magique</a>
      <a href="./marketplace.html" data-fr="march√©" data-en="Marketplace">Marketplace</a>
      <a href="./inscription.html" style="background:rgba(34,197,94,.2);border-color:#22c55e;" data-fr="üìù Inscription"
        data-en="üìù Sign Up">üìù Sign Up</a>
      <a href="./connexion.html" data-fr="üîì Connexion" data-en="üîì Login">üîì Login</a>
    </div>
  </div>

    <div id="kdp-generator-container" class="notranslate"></div>
    
    <div class="py-12 bg-gray-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="text-center">
                <h2 class="text-3xl font-extrabold text-gray-900 sm:text-4xl"
                    data-fr="Conseils d'Expert pour une Couverture KDP R√©ussie"
                    data-en="Expert Tips for a Successful KDP Cover">
                    Conseils d'Expert pour une Couverture KDP R√©ussie
                </h2>
                <p class="mt-4 text-lg text-gray-500"
                    data-fr="Mettez toutes les chances de votre c√¥t√© avec ces recommandations."
                    data-en="Give yourself the best chance of success with these recommendations.">
                    Mettez toutes les chances de votre c√¥t√© avec ces recommandations.
                </p>
            </div>

            <div class="mt-12 grid gap-8 md:grid-cols-3">
                <div class="bg-white p-6 rounded-lg shadow-lg">
                    <div class="flex items-center">
                        <div class="flex-shrink-0">
                            <i class="fas fa-layer-group text-3xl text-blue-500"></i>
                        </div>
                        <div class="ml-4">
                            <h3 class="text-lg font-bold text-gray-900"
                                data-fr="Le Fond Perdu : Quand l'utiliser ?"
                                data-en="Bleed: When to use it?">
                                Le Fond Perdu : Quand l'utiliser ?
                            </h3>
                        </div>
                    </div>
                    <div class="mt-4 text-gray-600 space-y-3">
                        <p>
                            <strong class="text-gray-800"
                                data-fr="QUAND L'UTILISER (OBLIGATOIRE) :"
                                data-en="WHEN TO USE IT (MANDATORY):">
                                QUAND L'UTILISER (OBLIGATOIRE) :
                            </strong>
                            <span data-fr="Si une image, une couleur ou un √©l√©ment de votre design touche le bord de la couverture. Cela √©vite l'apparition d'un liser√© blanc apr√®s la coupe."
                                  data-en="If any image, color, or element of your design touches the edge of the cover. This prevents a white border from appearing after trimming.">
                                  Si une image, une couleur ou un √©l√©ment de votre design touche le bord de la couverture. Cela √©vite l'apparition d'un liser√© blanc apr√®s la coupe.
                            </span>
                        </p>
                        <p>
                            <strong class="text-gray-800"
                                data-fr="QUAND NE PAS L'UTILISER :"
                                data-en="WHEN NOT TO USE IT:">
                                QUAND NE PAS L'UTILISER :
                            </strong>
                            <span data-fr="Pour les designs avec une bordure blanche volontaire tout autour (style roman classique)."
                                  data-en="For designs with a deliberate white border all around (classic novel style).">
                                  Pour les designs avec une bordure blanche volontaire tout autour (style roman classique).
                            </span>
                        </p>
                        <p class="bg-blue-50 p-3 rounded-md">
                            <strong class="text-blue-800"
                                data-fr="L'ASTUCE :"
                                data-en="PRO TIP:">
                                L'ASTUCE :
                            </strong>
                            <span data-fr="Dans le doute, cochez toujours la case &quot;Fond perdu&quot;. C'est plus s√ªr !"
                                  data-en="When in doubt, always check the &quot;Bleed&quot; box. It's safer!">
                                  Dans le doute, cochez toujours la case "Fond perdu". C'est plus s√ªr !
                            </span>
                        </p>
                    </div>
                </div>

                <div class="bg-white p-6 rounded-lg shadow-lg">
                    <div class="flex items-center">
                        <div class="flex-shrink-0">
                            <i class="fas fa-exclamation-triangle text-3xl text-red-500"></i>
                        </div>
                        <div class="ml-4">
                            <h3 class="text-lg font-bold text-gray-900"
                                data-fr="Les 3 Pi√®ges Mortels √† √âviter"
                                data-en="The 3 Deadly Pitfalls to Avoid">
                                Les 3 Pi√®ges Mortels √† √âviter
                            </h3>
                        </div>
                    </div>
                    <div class="mt-4 text-gray-600 space-y-3">
                        <p>
                            <strong class="text-gray-800"
                                data-fr="1. Les Marges de S√©curit√© Ignor√©es :"
                                data-en="1. Ignoring Safety Margins:">
                                1. Les Marges de S√©curit√© Ignor√©es :
                            </strong>
                            <span data-fr="Ne placez JAMAIS de texte ou de logo important sur les pointill√©s. Laissez toujours un petit espace, comme vous le montre le guide visuel du g√©n√©rateur."
                                  data-en="NEVER place text or important logos on the dotted lines. Always leave a small space, as shown by the generator's visual guide.">
                                  Ne placez JAMAIS de texte ou de logo important sur les pointill√©s. Laissez toujours un petit espace, comme vous le montre le guide visuel du g√©n√©rateur.
                            </span>
                        </p>
                        <p>
                            <strong class="text-gray-800"
                                data-fr="2. Une Tranche Illisible :"
                                data-en="2. An Illegible Spine:">
                                2. Une Tranche Illisible :
                            </strong>
                            <span data-fr="Si votre livre a peu de pages, la tranche sera fine. √âvitez d'y mettre du texte. Notre outil d√©sactive d'ailleurs le champ quand c'est n√©cessaire."
                                  data-en="If your book has few pages, the spine will be thin. Avoid putting text on it. Our tool even disables the field when necessary.">
                                  Si votre livre a peu de pages, la tranche sera fine. √âvitez d'y mettre du texte. Notre outil d√©sactive d'ailleurs le champ quand c'est n√©cessaire.
                            </span>
                        </p>
                        <p>
                            <strong class="text-gray-800"
                                data-fr="3. Une Faible R√©solution d'Image :"
                                data-en="3. Low Image Resolution:">
                                3. Une Faible R√©solution d'Image :
                            </strong>
                            <span data-fr="Utilisez toujours des images de la meilleure qualit√© possible (id√©alement 300 DPI). Une image floue sur l'√©cran sera floue √† l'impression."
                                  data-en="Always use the highest quality images possible (ideally 300 DPI). A blurry image on screen will be blurry in print.">
                                  Utilisez toujours des images de la meilleure qualit√© possible (id√©alement 300 DPI). Une image floue sur l'√©cran sera floue √† l'impression.
                            </span>
                        </p>
                    </div>
                </div>

                <div class="bg-white p-6 rounded-lg shadow-lg">
                    <div class="flex items-center">
                        <div class="flex-shrink-0">
                            <i class="fas fa-star text-3xl text-yellow-500"></i>
                        </div>
                        <div class="ml-4">
                            <h3 class="text-lg font-bold text-gray-900"
                                data-fr="Ce Qui Pla√Æt aux Lecteurs"
                                data-en="What Readers Love">
                                Ce Qui Pla√Æt aux Lecteurs
                            </h3>
                        </div>
                    </div>
                    <div class="mt-4 text-gray-600 space-y-3">
                        <p>
                            <strong class="text-gray-800"
                                data-fr="1. La Lisibilit√© Avant Tout :"
                                data-en="1. Readability Above All:">
                                1. La Lisibilit√© Avant Tout :
                            </strong>
                            <span data-fr="Votre titre doit √™tre lisible m√™me en format miniature sur la page d'Amazon. Utilisez des polices claires et un fort contraste de couleurs."
                                  data-en="Your title must be readable even as a thumbnail on the Amazon store. Use clear fonts and high color contrast.">
                                  Votre titre doit √™tre lisible m√™me en format miniature sur la page d'Amazon. Utilisez des polices claires et un fort contraste de couleurs.
                            </span>
                        </p>
                        <p>
                            <strong class="text-gray-800"
                                data-fr="2. Respecter les Codes du Genre :"
                                data-en="2. Respect Genre Conventions:">
                                2. Respecter les Codes du Genre :
                            </strong>
                            <span data-fr="La couverture d'un thriller ne ressemble pas √† celle d'une romance. Analysez les meilleures ventes de votre cat√©gorie pour vous inspirer."
                                  data-en="A thriller cover looks different from a romance cover. Analyze the bestsellers in your category for inspiration.">
                                  La couverture d'un thriller ne ressemble pas √† celle d'une romance. Analysez les meilleures ventes de votre cat√©gorie pour vous inspirer.
                            </span>
                        </p>
                        <p>
                            <strong class="text-gray-800"
                                data-fr="3. Le Pouvoir de la Simplicit√© :"
                                data-en="3. The Power of Simplicity:">
                                3. Le Pouvoir de la Simplicit√© :
                            </strong>
                            <span data-fr="Une couverture surcharg√©e est souvent synonyme d'amateurisme. Concentrez-vous sur une seule image forte ou un concept clair. Moins, c'est plus !"
                                  data-en="A cluttered cover often looks amateurish. Focus on a single strong image or a clear concept. Less is more!">
                                  Une couverture surcharg√©e est souvent synonyme d'amateurisme. Concentrez-vous sur une seule image forte ou un concept clair. Moins, c'est plus !
                            </span>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        let currentLang = localStorage.getItem('selectedLanguage') || 'en';

        function updatePageLanguage(lang) { document.documentElement.lang = lang; }

        function switchLanguage(lang) {
            localStorage.setItem('selectedLanguage', lang);
            currentLang = lang;
            window.currentLang = lang;

            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
            const targetBtn = document.querySelector(`[data-lang="${lang}"]`);
            if (targetBtn) targetBtn.classList.add('active');
            
            if (window.reactSetLanguage) {
                window.reactSetLanguage(lang);
            }
            
            updatePageLanguage(lang);
        }

        window.switchLanguage = switchLanguage;
        window.currentLang = currentLang;

        document.addEventListener('DOMContentLoaded', function () {
            window.currentLang = currentLang;
            document.querySelectorAll('.lang-btn').forEach(button => {
                const lang = button.getAttribute('data-lang');
                if (lang === currentLang) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
            updatePageLanguage(currentLang);
        });

        function toggleMobileMenu() {
            const mobileMenu = document.getElementById('mobileMenu');
            const body = document.body;

            if (mobileMenu.classList.contains('active')) {
                mobileMenu.classList.remove('active');
                body.style.overflow = '';
            } else {
                mobileMenu.classList.add('active');
                body.style.overflow = 'hidden';
            }
        }
    </script>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback, useMemo } = React;

        // === Cover-fit comme CSS background-size: cover ===
        function drawImageCover(ctx, img, box, cx = 0.5, cy = 0.5, zoom = 1, offsetX = 0, offsetY = 0) {
            const iw = img.naturalWidth, ih = img.naturalHeight;
            if (!iw || !ih) return;

            const scale = Math.max(box.width / iw, box.height / ih) * zoom;
            const dw = iw * scale, dh = ih * scale;

            // Position de base + offset manuel (en pixels de pr√©visualisation)
            const dx = box.x + (box.width - dw) * cx + offsetX;
            const dy = box.y + (box.height - dh) * cy + offsetY;

            // Clipper √† la zone du livre pour ne pas d√©border
            ctx.save();
            ctx.beginPath();
            ctx.rect(box.x, box.y, box.width, box.height);
            ctx.clip();
            
            ctx.drawImage(img, dx, dy, dw, dh);
            
            ctx.restore();
        }

        const texts = {
            fr: {
                title: "G√©n√©rateur de Couvertures KDP",
                subtitle: "Aper√ßu 4K Ultra HD - De Canva √† KDP en 3 clics",
                bookSettings: "Param√®tres du livre",
                bindingType: "Type de reliure",
                paperback: "Livre broch√© (Paperback)",
                hardcover: "Livre reli√© (Hardcover)",
                kdpFormat: "Format KDP",
                selectFormat: "S√©lectionner un format",
                popularSizes: "Tailles les plus courantes",
                otherSizes: "Autres tailles standard",
                hardcoverFormats: "Formats livre reli√©",
                pageCount: "Nombre de pages",
                bleed: "Fond perdu (images jusqu'au bord)",
                paperType: "Type d'encre et de papier",
                coverFinish: "Finition de la couverture",
                spineText: "Texte du dos (tranche)",
                spineTextHelp: "Titre ou auteur (optionnel)",
                spineTextAuto: "G√©r√© automatiquement par Amazon",
                spineTextThin: "Tranche trop fine - non recommand√©",
                calculatedDimensions: "Dimensions calcul√©es",
                totalWidth: "Largeur totale",
                totalHeight: "Hauteur totale",
                spineThickness: "√âpaisseur dos",
                thinSpine: "(tranche fine)",
                canvaDimensions: "üìê Dimensions pour Canva",
                canvaInches: "En pouces (recommand√©)",
                canvaMM: "En millim√®tres",
                copyForCanva: "üìã Copier pour Canva",
                copiedToClipboard: "‚úÖ Copi√© !",
                canvaInstructions: "Dans Canva : Dimension personnalis√©e ‚Üí Collez ces valeurs",
                images: "Images",
                frontImage: "Image Face (1√®re de couverture)",
                backImage: "Image Verso (4√®me de couverture)",
                spineImage: "Image Dos (tranche) - Optionnel",
                spineColor: "Couleur de fond du dos",
                spineTextColor: "Couleur du texte du dos",
                spineTextSize: "Taille du texte du dos",
                spineTextFont: "Police du texte du dos",
                
                // üìö COVER TEXT TRANSLATIONS
                coverTextSection: "üìö Texte de couverture",
                bookTitle: "Titre du livre",
                bookTitlePlaceholder: "Entrez le titre...",
                bookTitleSize: "Taille du titre",
                bookTitleColor: "Couleur du titre",
                bookTitleFont: "Police du titre",
                bookTitlePosition: "Position verticale (%)",
                authorName: "Nom de l'auteur",
                authorNamePlaceholder: "Entrez le nom de l'auteur...",
                authorNameSize: "Taille",
                authorNameColor: "Couleur",
                authorNamePosition: "Position (%)",
                
                // üìñ BACK COVER TRANSLATIONS
                backCoverSection: "üìñ 4√®me de couverture",
                backCoverText: "R√©sum√© / Description",
                backCoverTextPlaceholder: "Entrez le texte de votre 4√®me de couverture...",
                backCoverTextSize: "Taille du texte",
                backCoverTextColor: "Couleur du texte",
                backCoverBgColor: "Couleur de fond (optionnel)",
                
                // üé® BACK COVER BACKGROUND
                backCoverBgSection: "üé® Fond de la 4√®me de couverture",
                backCoverBgEnable: "Activer un fond personnalis√©",
                backCoverBgColorLabel: "Couleur de fond",
                backCoverTextureLabel: "Texture / Image de fond",
                backCoverTextureUpload: "Uploader une texture",
                backCoverTextureRemove: "Supprimer la texture",
                backCoverBgTip: "Ajoutez une couleur unie ou une texture pour votre 4√®me de couverture",
                
                // üìä BARCODE ZONE
                barcodeSection: "üìä Zone code-barre ISBN",
                showBarcodeZone: "Afficher zone code-barre",
                barcodeZoneColor: "Couleur de fond",
                barcodeZoneHelp: "Amazon ajoute automatiquement le code-barre ISBN ici",
                
                removeImage: "Supprimer l'image",
                canvaImport: "Import depuis Canva",
                canvaComingSoon: "üöÄ Bient√¥t disponible",
                canvaTitle: "Importez depuis Canva",
                canvaDescription: "Connectez votre compte Canva pour importer vos designs directement dans le g√©n√©rateur",
                canvaConnectButton: "Se connecter √† Canva",
                canvaAvailabilitySoon: "Cette fonctionnalit√© sera bient√¥t disponible",
                premium: "PREMIUM",
                preview4k: "Aper√ßu 4K Ultra HD",
                generating: "G√©n√©ration 4K en cours...",
                resetForm: "Nouveau projet",
                qualityUltraHD: "4K Ultra HD",
                zoomIn: "Zoom +",
                zoomOut: "Zoom -",
                exportDesign: "EXPORTER LE DESIGN",
                exportFormat: "Format d'export",
                formatPDF: "PDF (Recommand√© par Amazon)",
                formatPNG: "PNG 300 DPI",
                formatJPEG: "JPEG Haute Qualit√©",
                analysisTitle: "Analyse Intelligente KDP",
                scoreExcellent: "EXCELLENT",
                scoreTresBon: "TR√àS BON",
                scoreAcceptable: "ACCEPTABLE",
                scoreProblematique: "√Ä AM√âLIORER",
                scoreSubtitleExcellent: "Pr√™t pour Amazon KDP",
                scoreSubtitleTresBon: "Quelques optimisations possibles",
                scoreSubtitleAcceptable: "Sera accept√© mais peut √™tre am√©lior√©",
                scoreSubtitleProblematique: "Corrections recommand√©es",
                noImagesYet: "Ajoutez vos images pour voir l'analyse compl√®te",
                kdpTips: "Conseils KDP",
                tipFormat: "Le format 6√ó9\" est le plus populaire sur Amazon.",
                tipBleed: "Activez le fond perdu pour √©viter les liser√©s blancs.",
                tipSpine: "Les tranches fines (<2.5mm) rendent le texte difficile √† lire.",
                tipResolution: "M√™me si votre image est en basse r√©solution (ex: 150 DPI), notre outil l'optimisera √† 300 DPI pour l'export.",
                disclaimer: "Clause de non-responsabilit√©",
                disclaimerShort: "GabaritKDP garantit uniquement la conformit√© technique des dimensions selon les sp√©cifications Amazon KDP.",
                disclaimerFull: "GabaritKDP n'est responsable que de la conformit√© technique des dimensions selon les sp√©cifications officielles Amazon KDP. Nous ne sommes pas responsables du contenu cr√©atif, de l'esth√©tique, de l'orthographe, de la grammaire, de la qualit√© des images fournies, du respect des droits d'auteur, ou de tout autre aspect cr√©atif de votre couverture. L'utilisateur reste enti√®rement responsable du contenu de sa publication.",
                disclaimerExport: "En t√©l√©chargeant, vous confirmez √™tre responsable du contenu cr√©atif de votre couverture.",
                technicalOnly: "Validation technique uniquement",
                contentResponsibility: "Contenu sous votre responsabilit√©",
                format8511Warning: "‚ö†Ô∏è FORMAT COMPLEXE D√âTECT√â",
                format8511Title: "Format 8.5√ó11\" - Attention Particuli√®re Requise",
                format8511Message: "Ce format est particuli√®rement d√©licat pour KDP. V√©rifiez IMP√âRATIVEMENT vos dimensions avant publication.",
                format8511Tips: "Conseils pour 8.5√ó11\" : V√©rifiez deux fois les marges, utilisez PNG haute qualit√©, testez la conversion PDF.",
                canvaBetaTitle: "API Canva en d√©veloppement",
                canvaBetaMessage: "L'int√©gration Canva est actuellement en cours de d√©veloppement. Pour l'instant, vous pouvez tester le g√©n√©rateur en uploadant vos images manuellement.",
                canvaBetaEta: "Disponibilit√© pr√©vue: Q2 2025",
                betaFeedback: "Vos retours nous aident √† am√©liorer l'outil !",
                legendTrim: "Bord de coupe (Trim)",
                legendSafeZone: "Marge de s√©curit√© (Texte)",
                howToTitle: "Guide Rapide",
                howToStep1: "1. Param√©trez votre livre (format, pages, etc.)",
                howToStep2: "2. Importez vos images pour la couverture.",
                howToStep2Tip: "üí° Bient√¥t : import direct depuis Canva ! En manque d'inspiration ? Essayez notre",
                howToStep2Link: "G√©n√©rateur Magique",
                howToStep3: "3. V√©rifiez que votre texte est bien √† l'int√©rieur des pointill√©s BLEUS (zone de s√©curit√©).",
                howToStep3Tip: "‚ÑπÔ∏è Les pointill√©s BLEUS = zone de s√©curit√© pour le texte. Les pointill√©s ROUGES = ligne de coupe (vos images peuvent aller jusque-l√†, mais pas le texte !). C'est requis par Amazon KDP.",
                howToStep4: "4. Exportez votre fichier PDF, pr√™t pour Amazon KDP, et r√©alisez votre r√™ve ! üöÄ",
                betaBannerActive: "places Beta restantes ! Devenez Founding Tester - Acc√®s illimit√© jusqu'√† No√´l 2025",
                betaBannerFull: "Programme Beta COMPLET - Inscription gratuite toujours disponible (3 exports/mois)",
            },
            en: {
                title: "KDP Cover Generator",
                subtitle: "4K Ultra HD Preview - From Canva to KDP in 3 clicks",
                bookSettings: "Book Settings",
                bindingType: "Binding Type",
                paperback: "Paperback",
                hardcover: "Hardcover",
                kdpFormat: "KDP Format",
                selectFormat: "Select a format",
                popularSizes: "Most Popular Sizes",
                otherSizes: "Other Standard Sizes",
                hardcoverFormats: "Hardcover Formats",
                pageCount: "Page Count",
                bleed: "Bleed (images to edge)",
                paperType: "Ink and Paper Type",
                coverFinish: "Cover Finish",
                spineText: "Spine Text",
                spineTextHelp: "Title or author (optional)",
                spineTextAuto: "Automatically managed by Amazon",
                spineTextThin: "Spine too thin - not recommended",
                calculatedDimensions: "Calculated Dimensions",
                totalWidth: "Total Width",
                totalHeight: "Total Height",
                spineThickness: "Spine Thickness",
                thinSpine: "(thin spine)",
                canvaDimensions: "üìê Dimensions for Canva",
                canvaInches: "In inches (recommended)",
                canvaMM: "In millimeters",
                copyForCanva: "üìã Copy for Canva",
                copiedToClipboard: "‚úÖ Copied!",
                canvaInstructions: "In Canva: Custom size ‚Üí Paste these values",
                images: "Images",
                frontImage: "Front Image (Front Cover)",
                backImage: "Back Image (Back Cover)",
                spineImage: "Spine Image - Optional",
                spineColor: "Spine Background Color",
                spineTextColor: "Spine Text Color",
                spineTextSize: "Spine Text Size",
                spineTextFont: "Spine Text Font",
                
                // üìö COVER TEXT TRANSLATIONS
                coverTextSection: "üìö Cover Text",
                bookTitle: "Book Title",
                bookTitlePlaceholder: "Enter title...",
                bookTitleSize: "Title Size",
                bookTitleColor: "Title Color",
                bookTitleFont: "Title Font",
                bookTitlePosition: "Vertical Position (%)",
                authorName: "Author Name",
                authorNamePlaceholder: "Enter author name...",
                authorNameSize: "Size",
                authorNameColor: "Color",
                authorNamePosition: "Position (%)",
                
                // üìñ BACK COVER TRANSLATIONS
                backCoverSection: "üìñ Back Cover",
                backCoverText: "Summary / Description",
                backCoverTextPlaceholder: "Enter your back cover text...",
                backCoverTextSize: "Text Size",
                backCoverTextColor: "Text Color",
                backCoverBgColor: "Background Color (optional)",
                
                // üé® BACK COVER BACKGROUND
                backCoverBgSection: "üé® Back Cover Background",
                backCoverBgEnable: "Enable custom background",
                backCoverBgColorLabel: "Background Color",
                backCoverTextureLabel: "Texture / Background Image",
                backCoverTextureUpload: "Upload texture",
                backCoverTextureRemove: "Remove texture",
                backCoverBgTip: "Add a solid color or texture for your back cover",
                
                // üìä BARCODE ZONE
                barcodeSection: "üìä ISBN Barcode Zone",
                showBarcodeZone: "Show barcode zone",
                barcodeZoneColor: "Background Color",
                barcodeZoneHelp: "Amazon automatically adds the ISBN barcode here",
                
                removeImage: "Remove Image",
                canvaImport: "Import from Canva",
                canvaComingSoon: "üöÄ Coming Soon",
                canvaTitle: "Import from Canva",
                canvaDescription: "Connect your Canva account to import your designs directly into the generator",
                canvaConnectButton: "Connect to Canva",
                canvaAvailabilitySoon: "This feature will be available soon",
                premium: "PREMIUM",
                preview4k: "4K Ultra HD Preview",
                generating: "4K Generation in progress...",
                resetForm: "New project",
                qualityUltraHD: "4K Ultra HD",
                zoomIn: "Zoom +",
                zoomOut: "Zoom -",
                exportDesign: "EXPORT DESIGN",
                exportFormat: "Export Format",
                formatPDF: "PDF (Recommended by Amazon)",
                formatPNG: "PNG 300 DPI",
                formatJPEG: "JPEG High Quality",
                analysisTitle: "Smart KDP Analysis",
                scoreExcellent: "EXCELLENT",
                scoreTresBon: "VERY GOOD",
                scoreAcceptable: "ACCEPTABLE",
                scoreProblematique: "NEEDS WORK",
                scoreSubtitleExcellent: "Ready for Amazon KDP",
                scoreSubtitleTresBon: "Some optimizations possible",
                scoreSubtitleAcceptable: "Will be accepted but can be improved",
                scoreSubtitleProblematique: "Corrections recommended",
                noImagesYet: "Add your images to see complete analysis",
                kdpTips: "KDP Tips",
                tipFormat: "The 6√ó9\" format is the most popular on Amazon.",
                tipBleed: "Enable bleed to avoid white borders.",
                tipSpine: "Thin spines (<2.5mm) make text hard to read.",
                tipResolution: "Even if your image has a low resolution (e.g., 150 DPI), our tool will optimize it to 300 DPI for export.",
                disclaimer: "Disclaimer",
                disclaimerShort: "GabaritKDP only guarantees technical compliance of dimensions according to Amazon KDP specifications.",
                disclaimerFull: "GabaritKDP is only responsible for technical compliance of dimensions according to official Amazon KDP specifications. We are not responsible for creative content, aesthetics, spelling, grammar, quality of provided images, copyright compliance, or any other creative aspect of your cover. The user remains entirely responsible for the content of their publication.",
                disclaimerExport: "By downloading, you confirm being responsible for the creative content of your cover.",
                technicalOnly: "Technical validation only",
                contentResponsibility: "Content under your responsibility",
                format8511Warning: "‚ö†Ô∏è COMPLEX FORMAT DETECTED",
                format8511Title: "8.5√ó11\" Format - Particular Attention Required",
                format8511Message: "This format is particularly delicate for KDP. IMPERATIVELY check your dimensions before publication.",
                format8511Tips: "Tips for 8.5√ó11\": Double-check margins, use high-quality PNG, test PDF conversion.",
                canvaBetaTitle: "Canva API in development",
                canvaBetaMessage: "Canva integration is currently under development. For now, you can test the generator by uploading your images manually.",
                canvaBetaEta: "Expected availability: Q2 2025",
                betaFeedback: "Your feedback helps us improve the tool!",
                legendTrim: "Trim Line",
                legendSafeZone: "Safe Zone (Text)",
                howToTitle: "Quick Guide",
                howToStep1: "1. Set up your book (format, pages, etc.)",
                howToStep2: "2. Upload your images for the cover.",
                howToStep2Tip: "üí° Coming soon: direct import from Canva! Need inspiration? Try our",
                howToStep2Link: "Magic Generator",
                howToStep3: "3. Check that your text is well within the BLUE dotted lines (safe zone).",
                howToStep3Tip: "‚ÑπÔ∏è BLUE dotted lines = text safe zone. RED dotted lines = trim line (your images can go there, but not text!). Required by Amazon KDP.",
                howToStep4: "4. Export your PDF file, ready for Amazon KDP, and make your dream come true! üöÄ",
                betaBannerActive: "Beta spots left! Become a Founding Tester - Unlimited access until Christmas 2025",
                betaBannerFull: "Beta Program FULL - Free registration still available (3 exports/month)",
            }
        };
        
        // üî§ COMPOSANT FONT SELECT - Avec aper√ßu des polices
        const FontSelect = ({ value, onChange, fonts, label }) => {
            return (
                <div>
                    <label className="block text-xs font-medium text-gray-600 mb-1">{label}</label>
                    <select
                        value={value}
                        onChange={(e) => onChange(e.target.value)}
                        className="w-full p-2 border border-gray-300 rounded text-sm"
                        style={{ fontFamily: value }}
                    >
                        {fonts.map((font, idx) => (
                            <option 
                                key={idx} 
                                value={font.name}
                                style={{ fontFamily: font.name }}
                            >
                                {font.name} ({font.category})
                            </option>
                        ))}
                    </select>
                    <div 
                        className="mt-1 p-2 bg-gray-100 rounded text-center text-lg"
                        style={{ fontFamily: value }}
                    >
                        Aper√ßu ABC abc 123
                    </div>
                </div>
            );
        };
        
        const KDPCoverGenerator = ({ onReset }) => {
            const [language, setLanguage] = useState(() => {
                return window.currentLang || localStorage.getItem('selectedLanguage') || 'en';
            });
            const [format, setFormat] = useState('');
            const [paperType, setPaperType] = useState('white');
            const [bindingType, setBindingType] = useState('paperback');
            const [coverFinish, setCoverFinish] = useState('matte');
            const [hasBleed, setHasBleed] = useState(true);
            const [pageCount, setPageCount] = useState(100);
            const [kdpStrictConfirmed, setKdpStrictConfirmed] = useState(false); // üîí KDP STRICT

            // --- Debounce only for pageCount input to smooth re-renders ---
            const pageCountDebounceRef = useRef(null);
            const setPageCountDebounced = useCallback((val) => {
                if (pageCountDebounceRef.current) clearTimeout(pageCountDebounceRef.current);
                pageCountDebounceRef.current = setTimeout(() => {
                    setPageCount(val);
                }, 250);
            }, []);
            const [isExporting, setIsExporting] = useState(false);
            const [spineText, setSpineText] = useState('');
            
            // üé® G√âN√âRATEUR DE TEXTURES PROC√âDURALES
            const generateTexture = (textureName, width, height, baseColor = '#f5f5f5') => {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                
                // Fonction de bruit simplifi√©
                const noise = () => Math.random();
                const lerp = (a, b, t) => a + (b - a) * t;
                
                // Couleur de base
                ctx.fillStyle = baseColor;
                ctx.fillRect(0, 0, width, height);
                
                switch(textureName) {
                    case 'paper':
                        // Texture papier - grain fin
                        ctx.fillStyle = '#f8f6f0';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < width * height * 0.3; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            const gray = 200 + Math.random() * 55;
                            ctx.fillStyle = `rgba(${gray}, ${gray-5}, ${gray-10}, ${0.1 + Math.random() * 0.2})`;
                            ctx.fillRect(x, y, 1 + Math.random(), 1 + Math.random());
                        }
                        // Fibres subtiles
                        ctx.strokeStyle = 'rgba(180, 170, 160, 0.1)';
                        for (let i = 0; i < 50; i++) {
                            ctx.beginPath();
                            ctx.moveTo(Math.random() * width, Math.random() * height);
                            ctx.lineTo(Math.random() * width, Math.random() * height);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'wood':
                        // Texture bois - veines horizontales
                        const woodBase = '#d4a574';
                        const woodDark = '#8b5a2b';
                        ctx.fillStyle = woodBase;
                        ctx.fillRect(0, 0, width, height);
                        
                        for (let y = 0; y < height; y += 3) {
                            const offset = Math.sin(y * 0.02) * 20 + Math.sin(y * 0.05) * 10;
                            const thickness = 1 + Math.random() * 2;
                            const alpha = 0.1 + Math.random() * 0.2;
                            ctx.strokeStyle = `rgba(100, 60, 30, ${alpha})`;
                            ctx.lineWidth = thickness;
                            ctx.beginPath();
                            ctx.moveTo(0, y);
                            for (let x = 0; x < width; x += 10) {
                                const yOffset = y + Math.sin((x + offset) * 0.01) * 5;
                                ctx.lineTo(x, yOffset);
                            }
                            ctx.stroke();
                        }
                        // Noeuds
                        for (let i = 0; i < 3; i++) {
                            const kx = Math.random() * width;
                            const ky = Math.random() * height;
                            const gradient = ctx.createRadialGradient(kx, ky, 0, kx, ky, 15 + Math.random() * 10);
                            gradient.addColorStop(0, 'rgba(80, 40, 20, 0.4)');
                            gradient.addColorStop(1, 'rgba(80, 40, 20, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.ellipse(kx, ky, 20, 10, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'linen':
                        // Texture lin - tissage crois√©
                        ctx.fillStyle = '#e8dcc8';
                        ctx.fillRect(0, 0, width, height);
                        ctx.strokeStyle = 'rgba(180, 160, 140, 0.3)';
                        ctx.lineWidth = 1;
                        // Lignes horizontales
                        for (let y = 0; y < height; y += 4) {
                            ctx.beginPath();
                            ctx.moveTo(0, y + Math.random() * 2);
                            ctx.lineTo(width, y + Math.random() * 2);
                            ctx.stroke();
                        }
                        // Lignes verticales
                        for (let x = 0; x < width; x += 4) {
                            ctx.beginPath();
                            ctx.moveTo(x + Math.random() * 2, 0);
                            ctx.lineTo(x + Math.random() * 2, height);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'leather':
                        // Texture cuir - grain irr√©gulier
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(0, 0, width, height);
                        // Grain
                        for (let i = 0; i < width * height * 0.1; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            const size = 1 + Math.random() * 3;
                            ctx.fillStyle = `rgba(60, 30, 10, ${0.1 + Math.random() * 0.2})`;
                            ctx.beginPath();
                            ctx.arc(x, y, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        // Plis subtils
                        ctx.strokeStyle = 'rgba(40, 20, 5, 0.15)';
                        for (let i = 0; i < 20; i++) {
                            ctx.beginPath();
                            const startX = Math.random() * width;
                            const startY = Math.random() * height;
                            ctx.moveTo(startX, startY);
                            ctx.quadraticCurveTo(
                                startX + (Math.random() - 0.5) * 100,
                                startY + (Math.random() - 0.5) * 100,
                                startX + (Math.random() - 0.5) * 150,
                                startY + (Math.random() - 0.5) * 150
                            );
                            ctx.stroke();
                        }
                        break;
                        
                    case 'marble':
                        // Texture marbre - veines
                        ctx.fillStyle = '#f0ebe5';
                        ctx.fillRect(0, 0, width, height);
                        // Veines principales
                        ctx.strokeStyle = 'rgba(150, 140, 130, 0.4)';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 8; i++) {
                            ctx.beginPath();
                            let x = Math.random() * width;
                            let y = 0;
                            ctx.moveTo(x, y);
                            while (y < height) {
                                x += (Math.random() - 0.5) * 40;
                                y += 10 + Math.random() * 20;
                                ctx.lineTo(x, y);
                            }
                            ctx.stroke();
                        }
                        // Veines secondaires
                        ctx.strokeStyle = 'rgba(180, 170, 160, 0.2)';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 15; i++) {
                            ctx.beginPath();
                            let x = Math.random() * width;
                            let y = Math.random() * height;
                            ctx.moveTo(x, y);
                            for (let j = 0; j < 5; j++) {
                                x += (Math.random() - 0.5) * 30;
                                y += (Math.random() - 0.5) * 30;
                                ctx.lineTo(x, y);
                            }
                            ctx.stroke();
                        }
                        break;
                        
                    case 'concrete':
                        // Texture b√©ton
                        ctx.fillStyle = '#a0a0a0';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < width * height * 0.2; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            const gray = 130 + Math.random() * 60;
                            ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray}, ${0.2 + Math.random() * 0.3})`;
                            const size = 1 + Math.random() * 4;
                            ctx.fillRect(x, y, size, size);
                        }
                        // Imperfections
                        for (let i = 0; i < 30; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            ctx.fillStyle = `rgba(80, 80, 80, ${0.1 + Math.random() * 0.1})`;
                            ctx.beginPath();
                            ctx.arc(x, y, 2 + Math.random() * 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'canvas':
                        // Texture toile de peintre
                        ctx.fillStyle = '#f5f0e6';
                        ctx.fillRect(0, 0, width, height);
                        ctx.strokeStyle = 'rgba(200, 190, 170, 0.5)';
                        ctx.lineWidth = 1;
                        // Trame horizontale
                        for (let y = 0; y < height; y += 3) {
                            ctx.beginPath();
                            ctx.moveTo(0, y);
                            ctx.lineTo(width, y);
                            ctx.stroke();
                        }
                        // Trame verticale
                        for (let x = 0; x < width; x += 3) {
                            ctx.beginPath();
                            ctx.moveTo(x, 0);
                            ctx.lineTo(x, height);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'cork':
                        // Texture li√®ge
                        ctx.fillStyle = '#c9a66b';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < width * height * 0.15; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            const size = 2 + Math.random() * 6;
                            ctx.fillStyle = `rgba(${150 + Math.random() * 50}, ${100 + Math.random() * 50}, ${50 + Math.random() * 30}, 0.3)`;
                            ctx.beginPath();
                            ctx.ellipse(x, y, size, size * 0.7, Math.random() * Math.PI, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'denim':
                        // Texture denim/jean
                        ctx.fillStyle = '#4a6a8a';
                        ctx.fillRect(0, 0, width, height);
                        ctx.strokeStyle = 'rgba(30, 50, 80, 0.3)';
                        // Diagonales caract√©ristiques du denim
                        for (let i = -height; i < width + height; i += 2) {
                            ctx.beginPath();
                            ctx.moveTo(i, 0);
                            ctx.lineTo(i + height, height);
                            ctx.stroke();
                        }
                        // Usure l√©g√®re
                        for (let i = 0; i < 100; i++) {
                            ctx.fillStyle = `rgba(100, 130, 160, ${Math.random() * 0.2})`;
                            ctx.fillRect(Math.random() * width, Math.random() * height, 2, 2);
                        }
                        break;
                        
                    case 'velvet':
                        // Texture velours
                        ctx.fillStyle = '#722f37';
                        ctx.fillRect(0, 0, width, height);
                        // Effet de brillance
                        const velvetGradient = ctx.createLinearGradient(0, 0, width, height);
                        velvetGradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');
                        velvetGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.1)');
                        velvetGradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
                        ctx.fillStyle = velvetGradient;
                        ctx.fillRect(0, 0, width, height);
                        // Fibres
                        for (let i = 0; i < width * height * 0.05; i++) {
                            ctx.strokeStyle = `rgba(100, 30, 40, ${0.1 + Math.random() * 0.1})`;
                            ctx.beginPath();
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + (Math.random() - 0.5) * 4, y + 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'silk':
                        // Texture soie
                        ctx.fillStyle = '#d4af37';
                        ctx.fillRect(0, 0, width, height);
                        // Reflets ondul√©s
                        for (let y = 0; y < height; y += 5) {
                            const wave = Math.sin(y * 0.05) * 0.1;
                            ctx.fillStyle = `rgba(255, 255, 255, ${0.05 + wave})`;
                            ctx.fillRect(0, y, width, 3);
                        }
                        break;
                        
                    case 'grunge':
                        // Texture grunge/us√©e
                        ctx.fillStyle = '#3a3a3a';
                        ctx.fillRect(0, 0, width, height);
                        // Taches et usure
                        for (let i = 0; i < 200; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            const size = 5 + Math.random() * 30;
                            ctx.fillStyle = `rgba(${Math.random() * 60}, ${Math.random() * 60}, ${Math.random() * 60}, ${Math.random() * 0.3})`;
                            ctx.beginPath();
                            ctx.arc(x, y, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        // Rayures
                        ctx.strokeStyle = 'rgba(80, 80, 80, 0.3)';
                        for (let i = 0; i < 50; i++) {
                            ctx.beginPath();
                            ctx.moveTo(Math.random() * width, Math.random() * height);
                            ctx.lineTo(Math.random() * width, Math.random() * height);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'watercolor':
                        // Texture aquarelle
                        ctx.fillStyle = '#f8f4e8';
                        ctx.fillRect(0, 0, width, height);
                        // Taches d'aquarelle
                        for (let i = 0; i < 15; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            const radius = 30 + Math.random() * 80;
                            const hue = Math.random() * 60 + 180; // Bleus-verts
                            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                            gradient.addColorStop(0, `hsla(${hue}, 40%, 70%, 0.2)`);
                            gradient.addColorStop(0.5, `hsla(${hue}, 40%, 70%, 0.1)`);
                            gradient.addColorStop(1, `hsla(${hue}, 40%, 70%, 0)`);
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(x, y, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'stars':
                        // Texture ciel √©toil√©
                        const starsGradient = ctx.createLinearGradient(0, 0, 0, height);
                        starsGradient.addColorStop(0, '#0a0a20');
                        starsGradient.addColorStop(1, '#1a1a40');
                        ctx.fillStyle = starsGradient;
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < 100; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            const size = Math.random() * 2;
                            ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + Math.random() * 0.5})`;
                            ctx.beginPath();
                            ctx.arc(x, y, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    
                    // === NOUVELLES TEXTURES ===
                    
                    case 'paper_old':
                        ctx.fillStyle = '#e8dcc0';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < width * height * 0.4; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            ctx.fillStyle = `rgba(${150 + Math.random() * 50}, ${130 + Math.random() * 40}, ${90 + Math.random() * 30}, ${0.1 + Math.random() * 0.2})`;
                            ctx.fillRect(x, y, 1 + Math.random() * 2, 1 + Math.random() * 2);
                        }
                        // Taches d'usure
                        for (let i = 0; i < 10; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            ctx.fillStyle = `rgba(120, 100, 70, ${Math.random() * 0.15})`;
                            ctx.beginPath();
                            ctx.arc(x, y, 10 + Math.random() * 30, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'paper_craft':
                        ctx.fillStyle = '#c9a66b';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < width * height * 0.3; i++) {
                            ctx.fillStyle = `rgba(${160 + Math.random() * 40}, ${130 + Math.random() * 30}, ${80 + Math.random() * 20}, 0.2)`;
                            ctx.fillRect(Math.random() * width, Math.random() * height, 2, 2);
                        }
                        break;
                        
                    case 'parchment':
                        ctx.fillStyle = '#f0e6d3';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < 30; i++) {
                            ctx.strokeStyle = `rgba(180, 160, 130, ${0.1 + Math.random() * 0.1})`;
                            ctx.beginPath();
                            ctx.moveTo(Math.random() * width, Math.random() * height);
                            ctx.lineTo(Math.random() * width, Math.random() * height);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'cardboard':
                        ctx.fillStyle = '#b8956e';
                        ctx.fillRect(0, 0, width, height);
                        ctx.strokeStyle = 'rgba(100, 70, 40, 0.2)';
                        for (let y = 0; y < height; y += 5) {
                            ctx.beginPath();
                            ctx.moveTo(0, y);
                            ctx.lineTo(width, y);
                            ctx.stroke();
                        }
                        break;
                    
                    case 'wool':
                        ctx.fillStyle = '#e8ddd0';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < width * height * 0.02; i++) {
                            ctx.strokeStyle = `rgba(200, 180, 160, 0.5)`;
                            ctx.beginPath();
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            ctx.arc(x, y, 2 + Math.random() * 4, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'burlap':
                        ctx.fillStyle = '#a08060';
                        ctx.fillRect(0, 0, width, height);
                        ctx.strokeStyle = 'rgba(70, 50, 30, 0.4)';
                        for (let y = 0; y < height; y += 3) {
                            ctx.beginPath();
                            ctx.moveTo(0, y);
                            ctx.lineTo(width, y);
                            ctx.stroke();
                        }
                        for (let x = 0; x < width; x += 3) {
                            ctx.beginPath();
                            ctx.moveTo(x, 0);
                            ctx.lineTo(x, height);
                            ctx.stroke();
                        }
                        break;
                    
                    case 'wood_dark':
                        ctx.fillStyle = '#4a3728';
                        ctx.fillRect(0, 0, width, height);
                        for (let y = 0; y < height; y += 4) {
                            ctx.strokeStyle = `rgba(30, 20, 10, ${0.2 + Math.random() * 0.2})`;
                            ctx.lineWidth = 1 + Math.random() * 2;
                            ctx.beginPath();
                            ctx.moveTo(0, y);
                            for (let x = 0; x < width; x += 15) {
                                ctx.lineTo(x, y + Math.sin(x * 0.02) * 3);
                            }
                            ctx.stroke();
                        }
                        break;
                        
                    case 'wood_plank':
                        ctx.fillStyle = '#c9a66b';
                        ctx.fillRect(0, 0, width, height);
                        const plankWidth = width / 4;
                        for (let i = 0; i < 4; i++) {
                            ctx.strokeStyle = 'rgba(80, 50, 30, 0.5)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(i * plankWidth, 0);
                            ctx.lineTo(i * plankWidth, height);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'bamboo':
                        ctx.fillStyle = '#a8c090';
                        ctx.fillRect(0, 0, width, height);
                        const bambooWidth = width / 6;
                        for (let i = 0; i < 6; i++) {
                            ctx.strokeStyle = 'rgba(60, 80, 40, 0.4)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(i * bambooWidth, 0);
                            ctx.lineTo(i * bambooWidth, height);
                            ctx.stroke();
                            // Noeuds
                            for (let y = 30; y < height; y += 50 + Math.random() * 30) {
                                ctx.strokeStyle = 'rgba(60, 80, 40, 0.6)';
                                ctx.beginPath();
                                ctx.moveTo(i * bambooWidth, y);
                                ctx.lineTo((i + 1) * bambooWidth, y);
                                ctx.stroke();
                            }
                        }
                        break;
                    
                    case 'marble_black':
                        ctx.fillStyle = '#2a2a2a';
                        ctx.fillRect(0, 0, width, height);
                        ctx.strokeStyle = 'rgba(80, 80, 80, 0.4)';
                        for (let i = 0; i < 10; i++) {
                            ctx.beginPath();
                            let x = Math.random() * width;
                            let y = 0;
                            ctx.moveTo(x, y);
                            while (y < height) {
                                x += (Math.random() - 0.5) * 30;
                                y += 15 + Math.random() * 15;
                                ctx.lineTo(x, y);
                            }
                            ctx.stroke();
                        }
                        break;
                        
                    case 'granite':
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < width * height * 0.3; i++) {
                            const gray = Math.random() > 0.5 ? 60 + Math.random() * 40 : 100 + Math.random() * 50;
                            ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray}, 0.5)`;
                            ctx.fillRect(Math.random() * width, Math.random() * height, 2 + Math.random() * 3, 2 + Math.random() * 3);
                        }
                        break;
                        
                    case 'slate':
                        ctx.fillStyle = '#4a5568';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < 30; i++) {
                            ctx.strokeStyle = `rgba(60, 70, 85, ${0.3 + Math.random() * 0.3})`;
                            ctx.beginPath();
                            ctx.moveTo(0, Math.random() * height);
                            ctx.lineTo(width, Math.random() * height);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'brick':
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(0, 0, width, height);
                        const brickH = 15;
                        const brickW = 30;
                        for (let row = 0; row < height / brickH; row++) {
                            const offset = row % 2 === 0 ? 0 : brickW / 2;
                            for (let col = -1; col < width / brickW + 1; col++) {
                                ctx.strokeStyle = 'rgba(60, 30, 10, 0.6)';
                                ctx.strokeRect(col * brickW + offset, row * brickH, brickW - 2, brickH - 2);
                            }
                        }
                        break;
                    
                    case 'metal_brushed':
                        ctx.fillStyle = '#a0a0a0';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < height; i += 1) {
                            ctx.strokeStyle = `rgba(${120 + Math.random() * 40}, ${120 + Math.random() * 40}, ${120 + Math.random() * 40}, 0.3)`;
                            ctx.beginPath();
                            ctx.moveTo(0, i);
                            ctx.lineTo(width, i);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'gold':
                        const goldGrad = ctx.createLinearGradient(0, 0, width, height);
                        goldGrad.addColorStop(0, '#bf953f');
                        goldGrad.addColorStop(0.3, '#fcf6ba');
                        goldGrad.addColorStop(0.5, '#b38728');
                        goldGrad.addColorStop(0.7, '#fcf6ba');
                        goldGrad.addColorStop(1, '#bf953f');
                        ctx.fillStyle = goldGrad;
                        ctx.fillRect(0, 0, width, height);
                        break;
                        
                    case 'silver':
                        const silverGrad = ctx.createLinearGradient(0, 0, width, height);
                        silverGrad.addColorStop(0, '#c0c0c0');
                        silverGrad.addColorStop(0.3, '#ffffff');
                        silverGrad.addColorStop(0.5, '#a0a0a0');
                        silverGrad.addColorStop(0.7, '#ffffff');
                        silverGrad.addColorStop(1, '#c0c0c0');
                        ctx.fillStyle = silverGrad;
                        ctx.fillRect(0, 0, width, height);
                        break;
                        
                    case 'copper':
                        const copperGrad = ctx.createLinearGradient(0, 0, width, height);
                        copperGrad.addColorStop(0, '#b87333');
                        copperGrad.addColorStop(0.5, '#da8a67');
                        copperGrad.addColorStop(1, '#b87333');
                        ctx.fillStyle = copperGrad;
                        ctx.fillRect(0, 0, width, height);
                        break;
                        
                    case 'rust':
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < 100; i++) {
                            ctx.fillStyle = `rgba(${100 + Math.random() * 80}, ${40 + Math.random() * 40}, ${20 + Math.random() * 20}, ${0.2 + Math.random() * 0.3})`;
                            ctx.beginPath();
                            ctx.arc(Math.random() * width, Math.random() * height, 5 + Math.random() * 20, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    
                    case 'leather_black':
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < width * height * 0.08; i++) {
                            ctx.fillStyle = `rgba(40, 40, 40, ${0.3 + Math.random() * 0.3})`;
                            ctx.beginPath();
                            ctx.arc(Math.random() * width, Math.random() * height, 1 + Math.random() * 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'leather_red':
                        ctx.fillStyle = '#8b0000';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < width * height * 0.08; i++) {
                            ctx.fillStyle = `rgba(60, 0, 0, ${0.2 + Math.random() * 0.2})`;
                            ctx.beginPath();
                            ctx.arc(Math.random() * width, Math.random() * height, 1 + Math.random() * 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    
                    case 'gradient_sunset':
                        const sunsetGrad = ctx.createLinearGradient(0, 0, 0, height);
                        sunsetGrad.addColorStop(0, '#ff7e5f');
                        sunsetGrad.addColorStop(0.5, '#feb47b');
                        sunsetGrad.addColorStop(1, '#ff6b6b');
                        ctx.fillStyle = sunsetGrad;
                        ctx.fillRect(0, 0, width, height);
                        break;
                        
                    case 'gradient_ocean':
                        const oceanGrad = ctx.createLinearGradient(0, 0, 0, height);
                        oceanGrad.addColorStop(0, '#667eea');
                        oceanGrad.addColorStop(1, '#764ba2');
                        ctx.fillStyle = oceanGrad;
                        ctx.fillRect(0, 0, width, height);
                        break;
                        
                    case 'gradient_forest':
                        const forestGrad = ctx.createLinearGradient(0, 0, 0, height);
                        forestGrad.addColorStop(0, '#134e5e');
                        forestGrad.addColorStop(1, '#71b280');
                        ctx.fillStyle = forestGrad;
                        ctx.fillRect(0, 0, width, height);
                        break;
                        
                    case 'gradient_night':
                        const nightGrad = ctx.createLinearGradient(0, 0, 0, height);
                        nightGrad.addColorStop(0, '#0c1445');
                        nightGrad.addColorStop(0.5, '#1a237e');
                        nightGrad.addColorStop(1, '#0c1445');
                        ctx.fillStyle = nightGrad;
                        ctx.fillRect(0, 0, width, height);
                        break;
                        
                    case 'gradient_fire':
                        const fireGrad = ctx.createLinearGradient(0, 0, 0, height);
                        fireGrad.addColorStop(0, '#f12711');
                        fireGrad.addColorStop(0.5, '#f5af19');
                        fireGrad.addColorStop(1, '#f12711');
                        ctx.fillStyle = fireGrad;
                        ctx.fillRect(0, 0, width, height);
                        break;
                        
                    case 'gradient_purple':
                        const purpleGrad = ctx.createLinearGradient(0, 0, 0, height);
                        purpleGrad.addColorStop(0, '#7b4397');
                        purpleGrad.addColorStop(1, '#dc2430');
                        ctx.fillStyle = purpleGrad;
                        ctx.fillRect(0, 0, width, height);
                        break;
                        
                    case 'gradient_teal':
                        const tealGrad = ctx.createLinearGradient(0, 0, 0, height);
                        tealGrad.addColorStop(0, '#11998e');
                        tealGrad.addColorStop(1, '#38ef7d');
                        ctx.fillStyle = tealGrad;
                        ctx.fillRect(0, 0, width, height);
                        break;
                    
                    case 'splatter':
                        ctx.fillStyle = '#f5f5f5';
                        ctx.fillRect(0, 0, width, height);
                        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
                        for (let i = 0; i < 50; i++) {
                            ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                            ctx.globalAlpha = 0.3 + Math.random() * 0.4;
                            ctx.beginPath();
                            ctx.arc(Math.random() * width, Math.random() * height, 5 + Math.random() * 30, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                        break;
                        
                    case 'bokeh':
                        ctx.fillStyle = '#1a1a2e';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < 30; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            const r = 10 + Math.random() * 40;
                            const gradient = ctx.createRadialGradient(x, y, 0, x, y, r);
                            gradient.addColorStop(0, `rgba(255, 255, 255, ${0.1 + Math.random() * 0.2})`);
                            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(x, y, r, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'geometric':
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < 20; i++) {
                            ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 + Math.random() * 0.2})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            const size = 20 + Math.random() * 50;
                            ctx.moveTo(x, y - size);
                            ctx.lineTo(x + size, y + size);
                            ctx.lineTo(x - size, y + size);
                            ctx.closePath();
                            ctx.stroke();
                        }
                        break;
                        
                    case 'waves':
                        const wavesGrad = ctx.createLinearGradient(0, 0, 0, height);
                        wavesGrad.addColorStop(0, '#0077be');
                        wavesGrad.addColorStop(1, '#00a8cc');
                        ctx.fillStyle = wavesGrad;
                        ctx.fillRect(0, 0, width, height);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        for (let y = 20; y < height; y += 30) {
                            ctx.beginPath();
                            ctx.moveTo(0, y);
                            for (let x = 0; x < width; x += 5) {
                                ctx.lineTo(x, y + Math.sin(x * 0.05) * 10);
                            }
                            ctx.stroke();
                        }
                        break;
                    
                    case 'clouds':
                        ctx.fillStyle = '#87ceeb';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < 15; i++) {
                            const cx = Math.random() * width;
                            const cy = Math.random() * height * 0.6;
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                            for (let j = 0; j < 5; j++) {
                                ctx.beginPath();
                                ctx.arc(cx + j * 15 - 30, cy + Math.random() * 10, 15 + Math.random() * 15, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        break;
                        
                    case 'leaves':
                        ctx.fillStyle = '#228b22';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < 50; i++) {
                            ctx.fillStyle = `rgba(${30 + Math.random() * 50}, ${100 + Math.random() * 80}, ${30 + Math.random() * 50}, 0.5)`;
                            ctx.beginPath();
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            ctx.ellipse(x, y, 5 + Math.random() * 10, 10 + Math.random() * 20, Math.random() * Math.PI, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'snow':
                        ctx.fillStyle = '#e8f4f8';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < 200; i++) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + Math.random() * 0.5})`;
                            ctx.beginPath();
                            ctx.arc(Math.random() * width, Math.random() * height, 1 + Math.random() * 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'rain':
                        ctx.fillStyle = '#4a5568';
                        ctx.fillRect(0, 0, width, height);
                        ctx.strokeStyle = 'rgba(200, 220, 255, 0.4)';
                        for (let i = 0; i < 100; i++) {
                            ctx.beginPath();
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            ctx.moveTo(x, y);
                            ctx.lineTo(x - 2, y + 10 + Math.random() * 10);
                            ctx.stroke();
                        }
                        break;
                    
                    case 'distressed':
                        ctx.fillStyle = '#d4c4a8';
                        ctx.fillRect(0, 0, width, height);
                        for (let i = 0; i < 100; i++) {
                            ctx.fillStyle = `rgba(${100 + Math.random() * 50}, ${90 + Math.random() * 40}, ${70 + Math.random() * 30}, ${Math.random() * 0.3})`;
                            ctx.fillRect(Math.random() * width, Math.random() * height, Math.random() * 30, Math.random() * 30);
                        }
                        break;
                        
                    case 'noise':
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(0, 0, width, height);
                        const imageData = ctx.getImageData(0, 0, width, height);
                        for (let i = 0; i < imageData.data.length; i += 4) {
                            const noise = Math.random() * 60 - 30;
                            imageData.data[i] += noise;
                            imageData.data[i + 1] += noise;
                            imageData.data[i + 2] += noise;
                        }
                        ctx.putImageData(imageData, 0, 0);
                        break;
                        
                    case 'halftone':
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, width, height);
                        for (let y = 0; y < height; y += 6) {
                            for (let x = 0; x < width; x += 6) {
                                const size = 1 + Math.random() * 2;
                                ctx.fillStyle = '#000000';
                                ctx.beginPath();
                                ctx.arc(x, y, size, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        break;
                        
                    default:
                        // Couleur unie par d√©faut
                        ctx.fillStyle = baseColor;
                        ctx.fillRect(0, 0, width, height);
                }
                
                return canvas;
            };
            
            // Liste des textures avec cat√©gories
            const TEXTURE_LIST = [
                // üìÑ PAPER - Papier
                { name: 'paper', title: 'Papier', category: 'paper' },
                { name: 'paper_old', title: 'Vieux papier', category: 'paper' },
                { name: 'paper_craft', title: 'Papier kraft', category: 'paper' },
                { name: 'parchment', title: 'Parchemin', category: 'paper' },
                { name: 'cardboard', title: 'Carton', category: 'paper' },
                
                // üßµ FABRIC - Tissu
                { name: 'linen', title: 'Lin', category: 'fabric' },
                { name: 'canvas', title: 'Toile', category: 'fabric' },
                { name: 'denim', title: 'Jean', category: 'fabric' },
                { name: 'velvet', title: 'Velours', category: 'fabric' },
                { name: 'silk', title: 'Soie', category: 'fabric' },
                { name: 'wool', title: 'Laine', category: 'fabric' },
                { name: 'burlap', title: 'Toile de jute', category: 'fabric' },
                
                // ü™µ WOOD - Bois
                { name: 'wood', title: 'Bois clair', category: 'wood' },
                { name: 'wood_dark', title: 'Bois fonc√©', category: 'wood' },
                { name: 'wood_plank', title: 'Planches', category: 'wood' },
                { name: 'bamboo', title: 'Bambou', category: 'wood' },
                { name: 'cork', title: 'Li√®ge', category: 'wood' },
                
                // ü™® STONE - Pierre
                { name: 'marble', title: 'Marbre blanc', category: 'stone' },
                { name: 'marble_black', title: 'Marbre noir', category: 'stone' },
                { name: 'granite', title: 'Granit', category: 'stone' },
                { name: 'concrete', title: 'B√©ton', category: 'stone' },
                { name: 'slate', title: 'Ardoise', category: 'stone' },
                { name: 'brick', title: 'Brique', category: 'stone' },
                
                // ‚öôÔ∏è METAL - M√©tal
                { name: 'metal_brushed', title: 'M√©tal bross√©', category: 'metal' },
                { name: 'gold', title: 'Or', category: 'metal' },
                { name: 'silver', title: 'Argent', category: 'metal' },
                { name: 'copper', title: 'Cuivre', category: 'metal' },
                { name: 'rust', title: 'Rouille', category: 'metal' },
                
                // üëú LEATHER - Cuir
                { name: 'leather', title: 'Cuir marron', category: 'leather' },
                { name: 'leather_black', title: 'Cuir noir', category: 'leather' },
                { name: 'leather_red', title: 'Cuir rouge', category: 'leather' },
                
                // üåà GRADIENT - D√©grad√©s
                { name: 'gradient_sunset', title: 'Coucher de soleil', category: 'gradient' },
                { name: 'gradient_ocean', title: 'Oc√©an', category: 'gradient' },
                { name: 'gradient_forest', title: 'For√™t', category: 'gradient' },
                { name: 'gradient_night', title: 'Nuit', category: 'gradient' },
                { name: 'gradient_fire', title: 'Feu', category: 'gradient' },
                { name: 'gradient_purple', title: 'Violet', category: 'gradient' },
                { name: 'gradient_teal', title: 'Turquoise', category: 'gradient' },
                
                // üé® ABSTRACT - Abstrait
                { name: 'watercolor', title: 'Aquarelle', category: 'abstract' },
                { name: 'splatter', title: '√âclaboussures', category: 'abstract' },
                { name: 'bokeh', title: 'Bokeh', category: 'abstract' },
                { name: 'geometric', title: 'G√©om√©trique', category: 'abstract' },
                { name: 'waves', title: 'Vagues', category: 'abstract' },
                
                // üåø NATURE - Nature
                { name: 'stars', title: '√âtoiles', category: 'nature' },
                { name: 'clouds', title: 'Nuages', category: 'nature' },
                { name: 'leaves', title: 'Feuilles', category: 'nature' },
                { name: 'snow', title: 'Neige', category: 'nature' },
                { name: 'rain', title: 'Pluie', category: 'nature' },
                
                // üìú VINTAGE - Vintage
                { name: 'grunge', title: 'Grunge', category: 'vintage' },
                { name: 'distressed', title: 'Us√©', category: 'vintage' },
                { name: 'noise', title: 'Bruit', category: 'vintage' },
                { name: 'halftone', title: 'Demi-teinte', category: 'vintage' },
            ];
            
            // Cat√©gories de textures
            const TEXTURE_CATEGORIES = [
                { id: 'all', label: 'Tout', labelEn: 'All' },
                { id: 'paper', label: 'Papier', labelEn: 'Paper' },
                { id: 'fabric', label: 'Tissu', labelEn: 'Fabric' },
                { id: 'wood', label: 'Bois', labelEn: 'Wood' },
                { id: 'stone', label: 'Pierre', labelEn: 'Stone' },
                { id: 'metal', label: 'M√©tal', labelEn: 'Metal' },
                { id: 'leather', label: 'Cuir', labelEn: 'Leather' },
                { id: 'gradient', label: 'D√©grad√©s', labelEn: 'Gradients' },
                { id: 'abstract', label: 'Abstrait', labelEn: 'Abstract' },
                { id: 'nature', label: 'Nature', labelEn: 'Nature' },
                { id: 'vintage', label: 'Vintage', labelEn: 'Vintage' },
            ];
            
            // üî§ LISTE DES POLICES DISPONIBLES (avec cat√©gories)
            const FONT_LIST = [
                // Serif - Classiques
                { name: 'Georgia', category: 'Serif Classique' },
                { name: 'Times New Roman', category: 'Serif Classique' },
                { name: 'Playfair Display', category: 'Serif √âl√©gant' },
                { name: 'Merriweather', category: 'Serif √âl√©gant' },
                { name: 'Cinzel', category: 'Serif √âl√©gant' },
                { name: 'Cormorant Garamond', category: 'Serif √âl√©gant' },
                { name: 'Libre Baskerville', category: 'Serif Classique' },
                { name: 'Lora', category: 'Serif √âl√©gant' },
                { name: 'Spectral', category: 'Serif Moderne' },
                { name: 'Crimson Text', category: 'Serif Classique' },
                { name: 'EB Garamond', category: 'Serif Classique' },
                { name: 'Bitter', category: 'Serif Moderne' },
                { name: 'Roboto Slab', category: 'Serif Moderne' },
                // Sans-Serif - Modernes
                { name: 'Arial', category: 'Sans-Serif' },
                { name: 'Helvetica', category: 'Sans-Serif' },
                { name: 'Verdana', category: 'Sans-Serif' },
                { name: 'Oswald', category: 'Sans-Serif Impact' },
                { name: 'Montserrat', category: 'Sans-Serif Moderne' },
                { name: 'Raleway', category: 'Sans-Serif √âl√©gant' },
                { name: 'Poppins', category: 'Sans-Serif Moderne' },
                { name: 'Open Sans', category: 'Sans-Serif' },
                { name: 'Lato', category: 'Sans-Serif' },
                // Script - Manuscrites
                { name: 'Dancing Script', category: 'Script Romance' },
                { name: 'Pacifico', category: 'Script Fun' },
                { name: 'Great Vibes', category: 'Script √âl√©gant' },
                { name: 'Satisfy', category: 'Script Casual' },
                { name: 'Sacramento', category: 'Script √âl√©gant' },
                { name: 'Allura', category: 'Script √âl√©gant' },
                { name: 'Alex Brush', category: 'Script √âl√©gant' },
                { name: 'Tangerine', category: 'Script √âl√©gant' },
                { name: 'Pinyon Script', category: 'Script Formel' },
                // Display - Titrage
                { name: 'Impact', category: 'Display Bold' },
                { name: 'Berkshire Swash', category: 'Display Vintage' },
                { name: 'Abril Fatface', category: 'Display √âl√©gant' },
                { name: 'Alfa Slab One', category: 'Display Bold' },
                { name: 'Bangers', category: 'Display Comics' },
                { name: 'Permanent Marker', category: 'Display Casual' },
                { name: 'Righteous', category: 'Display Moderne' },
                // Horror / Fantasy
                { name: 'Creepster', category: 'Horror' },
                { name: 'Nosifer', category: 'Horror' },
                { name: 'Metal Mania', category: 'Horror Metal' },
                { name: 'Butcherman', category: 'Horror' },
                // Sci-Fi / Futuriste
                { name: 'Orbitron', category: 'Sci-Fi' },
                { name: 'Rubik Glitch', category: 'Sci-Fi Glitch' },
                { name: 'Press Start 2P', category: 'Pixel Retro' },
                { name: 'VT323', category: 'Retro Terminal' },
            ];
            
            // üìö COVER TEXT - Titre et Auteur (Face/Front) avec positions X/Y
            const [bookTitle, setBookTitle] = useState('');
            const [bookTitleSize, setBookTitleSize] = useState(48);
            const [bookTitleColor, setBookTitleColor] = useState('#ffffff');
            const [bookTitleFont, setBookTitleFont] = useState('Playfair Display');
            const [bookTitleX, setBookTitleX] = useState(50); // % depuis la gauche de la zone FRONT
            const [bookTitleY, setBookTitleY] = useState(30); // % depuis le haut
            
            const [authorName, setAuthorName] = useState('');
            const [authorNameSize, setAuthorNameSize] = useState(24);
            const [authorNameColor, setAuthorNameColor] = useState('#ffffff');
            const [authorNameFont, setAuthorNameFont] = useState('Montserrat');
            const [authorNameX, setAuthorNameX] = useState(50); // % depuis la gauche de la zone FRONT
            const [authorNameY, setAuthorNameY] = useState(85); // % depuis le haut
            
            // üìñ BACK COVER - 4√®me de couverture (Dos/Back) avec positions X/Y
            const [backCoverText, setBackCoverText] = useState('');
            const [backCoverTextSize, setBackCoverTextSize] = useState(14);
            const [backCoverTextColor, setBackCoverTextColor] = useState('#333333');
            const [backCoverTextFont, setBackCoverTextFont] = useState('Lora');
            const [backCoverTextX, setBackCoverTextX] = useState(50); // % depuis la gauche de la zone BACK
            const [backCoverTextY, setBackCoverTextY] = useState(15); // % depuis le haut
            
            // üñ±Ô∏è DRAG & DROP STATE
            const [draggingElement, setDraggingElement] = useState(null); // 'title', 'author', 'backText'
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            
            // üé® CUSTOM BACKGROUND - Fond personnalis√©
            const [backCoverBgColor, setBackCoverBgColor] = useState('#f5f5f5');
            const [backgroundApplyTo, setBackgroundApplyTo] = useState('none'); // 'none', 'back', 'front', 'full'
            const [backCoverTexture, setBackCoverTexture] = useState(null); // Image de texture
            const [textureCategory, setTextureCategory] = useState('all'); // Filtre cat√©gorie
            const [textureColorFilter, setTextureColorFilter] = useState(null); // Filtre couleur sur texture
            
            // üìä ISBN BARCODE ZONE
            const [showBarcodeZone, setShowBarcodeZone] = useState(true);
            const [barcodeZoneColor, setBarcodeZoneColor] = useState('#ffffff');
            const [frontImage, setFrontImage] = useState(null);
            const [backImage, setBackImage] = useState(null);
            const [spineImage, setSpineImage] = useState(null);
            const [spineColor, setSpineColor] = useState('#ffffff');
            const [spineTextColor, setSpineTextColor] = useState('#000000');
            const [spineTextSize, setSpineTextSize] = useState(12);
            const [spineTextFont, setSpineTextFont] = useState('Arial');
            // L'√©tat 'dimensions' est supprim√©
            const [warnings, setWarnings] = useState([]);
            const [overallScore, setOverallScore] = useState(0);
            const [zoomLevel, setZoomLevel] = useState(1.5);
            const [canvasQuality, setCanvasQuality] = useState('4K');
            const [exportFormat, setExportFormat] = useState('pdf');
            const [exportLimitInfo, setExportLimitInfo] = useState({ canExport: false, remaining: 0, level: 'anonymous' });
            const [viewMode, setViewMode] = useState('2d'); // '2d' ou '3d'
            const [mockup3dStyle, setMockup3dStyle] = useState('perspective'); // 'perspective', 'flat', 'standing'
            
            // üéÆ √âtats pour le contr√¥le 3D interactif
            const [rotationY, setRotationY] = useState(-35); // Angle initial
            const [isAutoRotating, setIsAutoRotating] = useState(false);
            const animationRef = useRef(null);
            
            // üñºÔ∏è √âtats pour le drag & drop d'images (repositionnement)
            const [frontImageOffset, setFrontImageOffset] = useState({ x: 0, y: 0 });
            const [backImageOffset, setBackImageOffset] = useState({ x: 0, y: 0 });
            const [spineImageOffset, setSpineImageOffset] = useState({ x: 0, y: 0 });
            const [dragStartPos, setDragStartPos] = useState({ x: 0, y: 0 });
            
            // üîç √âtats pour le zoom des images
            const [frontImageZoom, setFrontImageZoom] = useState(1.0);
            const [backImageZoom, setBackImageZoom] = useState(1.0);
            const [spineImageZoom, setSpineImageZoom] = useState(1.0);
            
            // üéØ Image actuellement s√©lectionn√©e (pour afficher les contr√¥les)
            const [selectedImage, setSelectedImage] = useState(null); // 'front', 'back', 'spine' ou null
            
            // üõí MARKETPLACE INTEGRATION - √âtats pour les templates charg√©s via URL
            const [marketplaceTemplate, setMarketplaceTemplate] = useState(null);
            const [isMarketplacePreview, setIsMarketplacePreview] = useState(false);
            const [showStripeModal, setShowStripeModal] = useState(false); // D√©sactiv√© pour beta

            // üìö Design Library (local) ‚Äî historique + sauvegardes
            const [designsModalOpen, setDesignsModalOpen] = useState(false);
            const [designsList, setDesignsList] = useState([]);
            const [designTitle, setDesignTitle] = useState('');
            const [activeDesignId, setActiveDesignId] = useState(() => localStorage.getItem('gkdp_active_design_id') || null);

            
            const canvasRef = useRef(null);

            // üéØ DEBUG - V√©rifier que React monte bien le composant
            console.log('üéØ [DEBUG] KDPCoverGenerator component mounted!');
            console.log('üéØ [DEBUG] Current URL:', window.location.href);
            console.log('üéØ [DEBUG] URLSearchParams template:', new URLSearchParams(window.location.search).get('template'));
            console.log('üéØ [DEBUG] React version:', React.version);

            // üî• MARKETPLACE URL BOOTSTRAP ‚Äî DOIT √äTRE TOUT EN HAUT (apr√®s useState/useRef)
            useEffect(() => {
                console.log('üõí [MARKETPLACE] useEffect MOUNT - Checking for template...');
                
                // R√©cup√©rer depuis capture early OU URL directe
                const imageUrl =
                    window.__GKDP_TEMPLATE_URL__ ||
                    sessionStorage.getItem("gkdp_template_url") ||
                    new URLSearchParams(window.location.search).get("template") ||
                    new URLSearchParams(window.location.search).get("img");
                
                console.log('üõí [MARKETPLACE] imageUrl found:', imageUrl);

                if (!imageUrl) {
                    console.log('üõí [MARKETPLACE] Aucun template - mode normal');
                    return;
                }

                console.log('üõí [MARKETPLACE] ‚úÖ Template d√©tect√©:', imageUrl);

                setMarketplaceTemplate(imageUrl);
                setIsMarketplacePreview(true);
                window.setActiveTemplateUrl && window.setActiveTemplateUrl(imageUrl);

                const isFullCover = imageUrl.toLowerCase().includes('fullcover');
                console.log('üõí [MARKETPLACE] Type:', isFullCover ? 'FULL COVER' : 'BACKGROUND');

                // Auto-s√©lectionner format par d√©faut
                setFormat('6x9');
                setPageCount(100);
                console.log('üõí [MARKETPLACE] Format auto-s√©lectionn√©: 6x9, 100 pages');

                const img = new Image();
                img.crossOrigin = 'anonymous';

                img.onload = () => {
                    console.log('‚úÖ [MARKETPLACE] Image charg√©e', img.naturalWidth, 'x', img.naturalHeight);

                    const imageData = {
                        url: imageUrl,
                        naturalWidth: img.naturalWidth,
                        naturalHeight: img.naturalHeight,
                        file: null,
                        isMarketplace: true,
                        isFullCover: isFullCover
                    };
                    
                    setFrontImage(imageData);
                    console.log('üõí [MARKETPLACE] Image d√©finie dans frontImage');
                    
                    // Nettoyer sessionStorage apr√®s utilisation
                    sessionStorage.removeItem("gkdp_template_url");
                };

                img.onerror = () => {
                    console.error('‚ùå [MARKETPLACE] Erreur chargement image:', imageUrl);
                    sessionStorage.removeItem("gkdp_template_url");
                };

                img.src = imageUrl;
            }, []);

            const t = (key) => texts[language][key] || texts.en[key];

            const kdpFormats = {
                '5x8': { width: 127, height: 203.2, name: '12,7 √ó 20,32 cm (5" √ó 8")', binding: ['paperback'], popular: true },
                '5.25x8': { width: 133.4, height: 203.2, name: '13,34 √ó 20,32 cm (5,25" √ó 8")', binding: ['paperback'], popular: true },
                '5.5x8.5': { width: 139.7, height: 215.9, name: '13,97 √ó 21,59 cm (5,5" √ó 8,5")', binding: ['paperback'], popular: true },
                '6x9': { width: 152.4, height: 228.6, name: '15,24 √ó 22,86 cm (6" √ó 9") ‚≠ê', binding: ['paperback'], popular: true },
                '5.06x7.81': { width: 128.5, height: 198.4, name: '12,85 √ó 19,84 cm (5,06" √ó 7,81")', binding: ['paperback'] },
                '6.14x9.21': { width: 156, height: 233.9, name: '15,6 √ó 23,39 cm (6,14" √ó 9,21")', binding: ['paperback'] },
                '6.69x9.61': { width: 169.9, height: 244, name: '16,99 √ó 24,4 cm (6,69" √ó 9,61")', binding: ['paperback'] },
                '7x10': { width: 177.8, height: 254, name: '17,78 √ó 25,4 cm (7" √ó 10")', binding: ['paperback'] },
                '8x10': { width: 203.2, height: 254, name: '20,32 √ó 25,4 cm (8" √ó 10")', binding: ['paperback'] },
                '8.5x11': { width: 215.9, height: 279.4, name: '21,59 √ó 27,94 cm (8,5" √ó 11") ‚ö†Ô∏è COMPLEXE', binding: ['paperback'], complex: true },
                '6x9-hc': { width: 152.4, height: 228.6, name: '15,24 √ó 22,86 cm (6" √ó 9") - Reli√© ‚≠ê', binding: ['hardcover'], popular: true },
                '7x10-hc': { width: 177.8, height: 254, name: '17,78 √ó 25,4 cm (7" √ó 10") - Reli√©', binding: ['hardcover'] },
                '8.25x11-hc': { width: 209.5, height: 279.4, name: '20,95 √ó 27,94 cm (8,25" √ó 11") - Reli√©', binding: ['hardcover'] }
            };

            // üîí KDP STRICT - Table d'√©paisseur par page (en pouces)
            // Source: sp√©cifications officielles Amazon KDP
            const KDP_INCH_PER_PAGE = {
                paperback: {
                    bw_white: 0.002252,      // Noir & blanc sur papier blanc
                    bw_cream: 0.0025,        // Noir & blanc sur papier cr√®me  
                    color_standard: 0.002347, // Couleur standard
                    color_premium: 0.002347,  // Couleur premium
                },
                hardcover: {
                    bw_white: 0.0025,
                    bw_cream: 0.002347,
                    color: 0.002347,
                },
            };

            // Mapping UI paperType -> preset KDP
            function getKdpPresetKey(bindingType, paperType) {
                if (bindingType === "paperback") {
                    if (paperType === "white") return "bw_white";
                    if (paperType === "cream") return "bw_cream";
                    if (paperType === "color_standard") return "color_standard";
                    if (paperType === "color_premium") return "color_premium";
                }
                if (bindingType === "hardcover") {
                    if (paperType === "white") return "bw_white";
                    if (paperType === "cream") return "bw_cream";
                    if (paperType === "color") return "color";
                }
                throw new Error(`Unsupported preset: ${bindingType}/${paperType}`);
            }

            // Calcul spine en mm avec preset KDP strict
            function computeSpineMm(bindingType, paperType, pageCount) {
                const presetKey = getKdpPresetKey(bindingType, paperType);
                const inchPerPage = KDP_INCH_PER_PAGE[bindingType]?.[presetKey];
                if (!inchPerPage) throw new Error(`Missing inchPerPage for ${bindingType}/${presetKey}`);
                return pageCount * inchPerPage * 25.4; // inch -> mm
            }

            // üîí KDP STRICT - Validation bloquante
            function assertFinite(name, v) {
                if (typeof v !== "number" || !Number.isFinite(v)) throw new Error(`${name} invalid: ${v}`);
            }

            function validateKdpStrict({ format, bindingType, paperType, pageCount, hasBleed, dimensions, kdpStrictConfirmed, language }) {
                if (!kdpStrictConfirmed) {
                    throw new Error(language === 'fr' 
                        ? "üîí KDP Strict: Vous devez confirmer que vos param√®tres correspondent √† votre projet KDP."
                        : "üîí KDP Strict: You must confirm your parameters match your KDP project.");
                }

                if (!format) throw new Error("KDP strict: format required.");
                if (!bindingType) throw new Error("KDP strict: bindingType required.");
                if (!paperType) throw new Error("KDP strict: paperType required.");

                const pc = Number(pageCount);
                const minPages = bindingType === 'hardcover' ? 75 : 24;
                if (!Number.isInteger(pc) || pc < minPages) {
                    throw new Error(`KDP strict: pageCount must be >= ${minPages}.`);
                }

                if (!dimensions?.total) throw new Error("KDP strict: dimensions not available.");

                assertFinite("totalWidthMm", dimensions.total.width);
                assertFinite("totalHeightMm", dimensions.total.height);

                if (dimensions.total.width < 50 || dimensions.total.height < 50) {
                    throw new Error("KDP strict: computed size looks wrong.");
                }

                return { pageCount: pc };
            }

            // üîí Helpers de conversion pour PDF
            const mmToIn = (mm) => mm / 25.4;
            const inToPt = (inch) => inch * 72;
            const mmToPt = (mm) => inToPt(mmToIn(mm));

            const paperOptions = {
                paperback: [
                    { value: 'white', labelFr: 'Int√©rieur noir et blanc avec papier blanc ‚≠ê', labelEn: 'Black & white interior with white paper ‚≠ê' },
                    { value: 'cream', labelFr: 'Int√©rieur noir et blanc avec papier cr√®me', labelEn: 'Black & white interior with cream paper' },
                    { value: 'color_standard', labelFr: 'Int√©rieur couleur standard avec papier blanc', labelEn: 'Standard color interior with white paper' },
                    { value: 'color_premium', labelFr: 'Int√©rieur couleur premium avec papier blanc', labelEn: 'Premium color interior with white paper' }
                ],
                hardcover: [
                    { value: 'white', labelFr: 'Int√©rieur noir et blanc avec papier blanc ‚≠ê', labelEn: 'Black & white interior with white paper ‚≠ê' },
                    { value: 'cream', labelFr: 'Int√©rieur noir et blanc avec papier cr√®me', labelEn: 'Black & white interior with cream paper' },
                    { value: 'color', labelFr: 'Int√©rieur couleur premium avec papier blanc', labelEn: 'Premium color interior with white paper' }
                ]
            };
            
            // Les dimensions sont maintenant calcul√©es directement √† chaque rendu via useMemo.
            // Cela √©vite la cascade de mises √† jour d'√©tat qui causait le bug.
            const dimensions = useMemo(() => {
                try {
                    if (!format || !pageCount || !bindingType) return null;
                    const formatData = kdpFormats[format];
                    if (!formatData || !formatData.binding.includes(bindingType)) return null;

                    // üîí KDP STRICT - Utiliser computeSpineMm avec preset
                    const spineWidth = computeSpineMm(bindingType, paperType, pageCount);
                    let bleed = 0;
                    if (hasBleed) {
                        bleed = bindingType === 'hardcover' ? 6.35 : 3.175;
                    }

                    if (bindingType === 'hardcover') {
    const totalWidth = (formatData.width * 2) + spineWidth + (bleed * 2);
    const totalHeight = formatData.height + (bleed * 2);
    return {
      format: formatData,
      spine: spineWidth,
      total: { width: totalWidth, height: totalHeight },
      bleed,
      safeZone: hasBleed ? 12.7 : 6.35,
      barcodeZone: { width: 51, height: 23 },
      bindingType: 'hardcover',
      hasBleed
    };
}

                    const totalWidth = (formatData.width * 2) + spineWidth + (bleed * 2);
                    const totalHeight = formatData.height + (bleed * 2);

                    return { format: formatData, spine: spineWidth, total: { width: totalWidth, height: totalHeight }, bleed, safeZone: hasBleed ? 6.35 : 3.175, barcodeZone: { width: 51, height: 23 }, bindingType: 'paperback', hasBleed };
                } catch (error) {
                    console.error('Erreur dans calculateDimensions:', error);
                    return null;
                }
            }, [format, pageCount, paperType, bindingType, hasBleed]);
            
            const getDeviceFingerprint = () => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    ctx.textBaseline = 'top';
                    ctx.font = '14px Arial';
                    ctx.fillText('GabaritKDP-Device', 2, 2);
                    const fingerprint = canvas.toDataURL().slice(-20) +
                        screen.width + 'x' + screen.height +
                        navigator.language;
                    return btoa(fingerprint).slice(0, 16);
                } catch (e) {
                    return 'fallback-' + Math.random().toString(36).substr(2, 9);
                }
            };
            const checkExportLimits = () => {
                if (localStorage.getItem('userProfile') === 'pro') {
                    return { canExport: true, remaining: Infinity, level: 'pro' };
                }
                const exportCredits = parseInt(localStorage.getItem('exportCredits') || '0', 10);
                if (exportCredits > 0) {
                    return { canExport: true, remaining: exportCredits, level: 'pack' };
                }
                const today = new Date().toDateString();
                const exportHistory = JSON.parse(localStorage.getItem('exportHistory') || '{}');
                const todayExports = exportHistory[today] || 0;
                const dailyLimit = 3;

                return { canExport: todayExports < dailyLimit, remaining: dailyLimit - todayExports, level: 'anonymous' };
            };
            const recordExport = () => {
                const exportCredits = parseInt(localStorage.getItem('exportCredits') || '0', 10);
                if (exportCredits > 0) {
                    localStorage.setItem('exportCredits', exportCredits - 1);
                    return;
                }
                const today = new Date().toDateString();
                const exportHistory = JSON.parse(localStorage.getItem('exportHistory') || '{}');
                exportHistory[today] = (exportHistory[today] || 0) + 1;
                localStorage.setItem('exportHistory', JSON.stringify(exportHistory));
            };
            
            const coverFinishOptions = [ { value: 'matte', label: 'Mat ‚≠ê' }, { value: 'glossy', label: 'Brillant' } ];
            const handleZoomIn = () => setZoomLevel(prev => Math.min(prev + 0.2, 3.0));
            const handleZoomOut = () => setZoomLevel(prev => Math.max(prev - 0.2, 0.3));

            const validateKDPCompliance = useCallback(() => {
                if (!dimensions) return { alerts: [], score: 0 };
                const alerts = [];
                let totalScore = 0;
                let scoreComponents = 0;
                const formatData = dimensions.format;

                if (format === '8.5x11') {
                    alerts.push({ type: 'critical', category: 'format_complex', message: t('format8511Message') });
                    alerts.push({ type: 'warning', category: 'format_complex', message: t('format8511Tips') });
                    totalScore -= 3;
                }
                
                if (pageCount < 24 || (bindingType === 'hardcover' && pageCount < 75)) {
                    alerts.push({ type: 'critical', category: 'pages', message: `REJET AMAZON: Minimum de pages non atteint (${pageCount})` });
                } else {
                    alerts.push({ type: 'excellent', category: 'pages', message: `Pages conformes: ${pageCount} pages` });
                    totalScore += 25;
                }
                scoreComponents++;
                
                [ { image: frontImage, name: 'Face' }, { image: backImage, name: 'Verso' } ].forEach(({ image, name }) => {
                    if (image) {
                        const actualDPI = Math.round((image.naturalWidth / formatData.width) * 25.4);
                        if (actualDPI >= 300) { totalScore += 25; alerts.push({ type: 'excellent', message: `${name}: R√©solution PARFAITE (${actualDPI} DPI)` }); }
                        else if (actualDPI >= 200) { totalScore += 18; alerts.push({ type: 'warning', message: `${name}: R√©solution acceptable (${actualDPI} DPI)` }); }
                        else { totalScore += 10; alerts.push({ type: 'critical', message: `${name}: R√©solution CRITIQUE (${actualDPI} DPI)` }); }
                        scoreComponents++;
                    }
                });
                
                if (dimensions.bindingType === 'paperback') {
                     const spineWidthMM = dimensions.spine;
                    if (spineText && spineWidthMM < 2.8) {
                        alerts.push({ type: 'warning', category: 'spine', message: `Tranche fine (${spineWidthMM.toFixed(1)}mm): Texte possible mais peu lisible.` });
                    }
                    totalScore += 20;
                    scoreComponents++;
                }

                if (backImage) {
                    alerts.push({ type: 'info', category: 'barcode', message: `Amazon placera le code-barres en bas-droite.` });
                }
                if (!hasBleed && (frontImage || backImage)) {
                    alerts.push({ type: 'info', category: 'bleed', message: `Activez le fond perdu pour √©viter les liser√©s blancs.` });
                }

                return { alerts, score: scoreComponents > 0 ? Math.round(totalScore / scoreComponents) : 0 };
            }, [dimensions, frontImage, backImage, spineText, hasBleed, pageCount, language, format]);

            useEffect(() => {
                const validation = validateKDPCompliance();
                setWarnings(validation.alerts);
                setOverallScore(validation.score);
            }, [validateKDPCompliance]);

            const getScoreClass = (score) => {
                if (score >= 23) return 'score-excellent';
                if (score >= 19) return 'score-tres-bon';
                if (score >= 15) return 'score-acceptable';
                return 'score-problematique';
            };
            const getScoreLabel = (score) => {
                if (score >= 23) return { label: t('scoreExcellent'), subtitle: t('scoreSubtitleExcellent') };
                if (score >= 19) return { label: t('scoreTresBon'), subtitle: t('scoreSubtitleTresBon') };
                if (score >= 15) return { label: t('scoreAcceptable'), subtitle: t('scoreSubtitleAcceptable') };
                return { label: t('scoreProblematique'), subtitle: t('scoreSubtitleProblematique') };
            };
            const handleImageUpload = (file, type) => {
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const imageData = {
                            file, url: e.target.result,
                            naturalWidth: img.naturalWidth, naturalHeight: img.naturalHeight,
                            quality: img.naturalWidth > 3000 ? 'Ultra HD 4K' : 'Standard',
                            source: 'upload'
                        };
                        switch (type) {
                            case 'front': 
                                setFrontImage(imageData); 
                                setFrontImageOffset({x:0, y:0}); 
                                setFrontImageZoom(1.0);
                                break;
                            case 'back': 
                                setBackImage(imageData); 
                                setBackImageOffset({x:0, y:0}); 
                                setBackImageZoom(1.0);
                                break;
                            case 'spine': 
                                setSpineImage(imageData); 
                                setSpineImageOffset({x:0, y:0}); 
                                setSpineImageZoom(1.0);
                                break;
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            };

            const removeImage = (type) => {
                switch (type) {
                    case 'front': 
                        setFrontImage(null); 
                        setFrontImageOffset({x:0, y:0}); 
                        setFrontImageZoom(1.0);
                        break;
                    case 'back': 
                        setBackImage(null); 
                        setBackImageOffset({x:0, y:0}); 
                        setBackImageZoom(1.0);
                        break;
                    case 'spine': 
                        setSpineImage(null); 
                        setSpineImageOffset({x:0, y:0}); 
                        setSpineImageZoom(1.0);
                        break;
                }
            };
            
            // Fonction pour importer une image depuis Canva
            const handleCanvaImageUpload = async (imageUrl, type) => {
                try {
                    console.log(`üì• T√©l√©chargement image Canva pour ${type}:`, imageUrl);
                    
                    // T√©l√©charger l'image depuis Canva
                    const response = await fetch(imageUrl);
                    const blob = await response.blob();
                    
                    // Convertir en data URL
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const imageData = {
                                file: new File([blob], 'canva-design.png', { type: 'image/png' }),
                                url: e.target.result,
                                naturalWidth: img.naturalWidth,
                                naturalHeight: img.naturalHeight,
                                quality: img.naturalWidth > 3000 ? 'Ultra HD 4K' : 'Standard',
                                source: 'canva'
                            };
                            
                            console.log(`‚úÖ Image Canva charg√©e pour ${type}:`, {
                                width: img.naturalWidth,
                                height: img.naturalHeight,
                                quality: imageData.quality
                            });
                            
                            // Mettre √† jour l'√©tat React
                            switch (type) {
                                case 'front': setFrontImage(imageData); break;
                                case 'back': setBackImage(imageData); break;
                                case 'spine': setSpineImage(imageData); break;
                            }
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(blob);
                    
                } catch (error) {
                    console.error(`‚ùå Erreur lors de l'import depuis Canva (${type}):`, error);
                    alert(`Erreur lors de l'import de l'image Canva. Veuillez r√©essayer.`);
                }
            };
            
            // Exposer la fonction globalement pour l'√©v√©nement canva:design-imported
            React.useEffect(() => {
                window.__kdp_handleCanvaUpload = handleCanvaImageUpload;
                return () => {
                    delete window.__kdp_handleCanvaUpload;
                };
            }, []);
            
            const drawPreview = useCallback(() => {
                if (!dimensions || !canvasRef.current) return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const displayWidth = 600;
                const displayHeight = 400;

                canvas.width = displayWidth; canvas.height = displayHeight;
                canvas.style.width = `${displayWidth}px`; canvas.style.height = `${displayHeight}px`;

                ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';

                const bookWidth = displayWidth - 40; const bookHeight = displayHeight - 40;
                const startX = 20; const startY = 20;
                const scaleFactor = bookWidth / dimensions.total.width;
                const frontWidth = dimensions.format.width * scaleFactor;
                const spineWidth = dimensions.spine * scaleFactor;
                const backWidth = frontWidth;
                const bleedWidth = dimensions.bleed * scaleFactor;
                const bleedHeight = dimensions.bleed * scaleFactor;
                const exaggeratedSafeZoneReal = dimensions.safeZone + 5; 
                const safeZoneWidth = exaggeratedSafeZoneReal * scaleFactor;
                const safeZoneHeight = exaggeratedSafeZoneReal * scaleFactor;

                // üõí MARKETPLACE: Fonction pour dessiner le watermark
                const drawWatermark = () => {
                    if (!isMarketplacePreview) return;
                    
                    ctx.save();
                    ctx.globalAlpha = 0.15;
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 32px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Watermark en diagonale
                    ctx.translate(displayWidth / 2, displayHeight / 2);
                    ctx.rotate(-Math.PI / 6); // -30 degr√©s
                    ctx.fillText('GabaritKDP', 0, 0);
                    ctx.fillText('PREVIEW', 0, 40);
                    
                    ctx.restore();
                };

                const drawOverlays = () => {
                    ctx.strokeStyle = '#888888'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
                    if (spineWidth > 1) {
                        ctx.beginPath(); ctx.moveTo(startX + backWidth, startY); ctx.lineTo(startX + backWidth, startY + bookHeight); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(startX + backWidth + spineWidth, startY); ctx.lineTo(startX + backWidth + spineWidth, startY + bookHeight); ctx.stroke();
                    }
                    if (spineText && spineWidth > 15) {
                        ctx.fillStyle = spineTextColor || '#333333'; ctx.font = `${Math.max(10, spineTextSize)}px ${spineTextFont}`; ctx.textAlign = 'center';
                        ctx.save(); ctx.translate(startX + backWidth + spineWidth / 2, startY + bookHeight / 2); ctx.rotate(-Math.PI / 2); ctx.fillText(spineText, 0, 0); ctx.restore();
                    }
                    if (hasBleed) {
                        ctx.strokeStyle = 'rgba(0, 100, 255, 0.8)'; ctx.lineWidth = 1; ctx.setLineDash([6, 3]);
                        ctx.strokeRect(startX + bleedWidth, startY + bleedHeight, bookWidth - (bleedWidth * 2), bookHeight - (bleedHeight * 2));
                    }
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; ctx.lineWidth = 1.5; ctx.setLineDash([4, 4]);
                    ctx.strokeRect(startX + safeZoneWidth, startY + safeZoneHeight, backWidth - (safeZoneWidth * 2), bookHeight - (safeZoneHeight * 2));
                    ctx.strokeRect(startX + backWidth + spineWidth + safeZoneWidth, startY + safeZoneHeight, frontWidth - (safeZoneWidth * 2), bookHeight - (safeZoneHeight * 2));
                    
                    ctx.setLineDash([]); ctx.strokeStyle = '#333333'; ctx.lineWidth = 2; ctx.strokeRect(10, 10, displayWidth - 20, displayHeight - 20);
                    ctx.fillStyle = '#374151'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'left';
                    ctx.fillText(`${Math.round(dimensions.total.width)}√ó${Math.round(dimensions.total.height)}mm`, 15, displayHeight - 15);
                    
                    // üõí MARKETPLACE: Dessiner watermark apr√®s les overlays
                    drawWatermark();
                    
                    // üìö COVER TEXT: Dessiner titre, auteur, 4√®me de couv et zone code-barre
                    drawCoverText();
                };
                
                // üìö COVER TEXT FUNCTION
                const drawCoverText = () => {
                    // Zone FRONT (face) - pour titre et auteur
                    const frontStartX = startX + backWidth + spineWidth;
                    
                    // Zone BACK (dos) - pour 4√®me de couv et code-barre
                    const backStartX = startX;
                    
                    // üìñ TITRE DU LIVRE (sur la face)
                    if (bookTitle) {
                        ctx.save();
                        ctx.fillStyle = bookTitleColor;
                        const titleFontSize = Math.max(12, bookTitleSize * scaleFactor / 5);
                        ctx.font = `bold ${titleFontSize}px ${bookTitleFont}`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Position X/Y bas√©e sur les pourcentages
                        const titleX = frontStartX + (frontWidth * bookTitleX / 100);
                        const titleY = startY + (bookHeight * bookTitleY / 100);
                        
                        // Dessiner avec ombre pour meilleure lisibilit√©
                        ctx.shadowColor = 'rgba(0,0,0,0.5)';
                        ctx.shadowBlur = 4;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;
                        
                        // Word wrap si le titre est long
                        const maxWidth = frontWidth - (safeZoneWidth * 2);
                        wrapText(ctx, bookTitle, titleX, titleY, maxWidth, titleFontSize * 1.2);
                        
                        // Indicateur de position si dragging
                        if (draggingElement === 'title') {
                            ctx.strokeStyle = '#ff00ff';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.strokeRect(titleX - 50, titleY - 20, 100, 40);
                            ctx.setLineDash([]);
                        }
                        
                        ctx.restore();
                    }
                    
                    // üë§ NOM DE L'AUTEUR (sur la face)
                    if (authorName) {
                        ctx.save();
                        ctx.fillStyle = authorNameColor;
                        const authorFontSize = Math.max(8, authorNameSize * scaleFactor / 5);
                        ctx.font = `${authorFontSize}px ${authorNameFont}`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        const authorX = frontStartX + (frontWidth * authorNameX / 100);
                        const authorY = startY + (bookHeight * authorNameY / 100);
                        
                        ctx.shadowColor = 'rgba(0,0,0,0.5)';
                        ctx.shadowBlur = 3;
                        ctx.shadowOffsetX = 1;
                        ctx.shadowOffsetY = 1;
                        
                        ctx.fillText(authorName, authorX, authorY);
                        
                        // Indicateur de position si dragging
                        if (draggingElement === 'author') {
                            ctx.strokeStyle = '#00ffff';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.strokeRect(authorX - 40, authorY - 15, 80, 30);
                            ctx.setLineDash([]);
                        }
                        
                        ctx.restore();
                    }
                    
                    // üìñ 4√àME DE COUVERTURE (sur le dos)
                    if (backCoverText) {
                        ctx.save();
                        ctx.fillStyle = backCoverTextColor;
                        const backTextFontSize = Math.max(6, backCoverTextSize * scaleFactor / 6);
                        ctx.font = `${backTextFontSize}px ${backCoverTextFont}`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        
                        // Position X/Y bas√©e sur les pourcentages
                        const textX = backStartX + (backWidth * backCoverTextX / 100);
                        const textY = startY + (bookHeight * backCoverTextY / 100);
                        const maxWidth = backWidth - (safeZoneWidth * 2) - 10;
                        
                        wrapText(ctx, backCoverText, textX, textY, maxWidth, backTextFontSize * 1.4);
                        
                        // Indicateur de position si dragging
                        if (draggingElement === 'backText') {
                            ctx.strokeStyle = '#ffff00';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.strokeRect(textX - 60, textY - 5, 120, 60);
                            ctx.setLineDash([]);
                        }
                        
                        ctx.restore();
                    }
                    
                    // üìä ZONE CODE-BARRE ISBN (sur le dos, en bas √† droite)
                    if (showBarcodeZone) {
                        ctx.save();
                        // Dimensions standards du code-barre ISBN: ~50.8mm x 30.5mm
                        const barcodeWidth = 50 * scaleFactor;
                        const barcodeHeight = 30 * scaleFactor;
                        const barcodeX = startX + backWidth - safeZoneWidth - barcodeWidth - 5;
                        const barcodeY = startY + bookHeight - safeZoneHeight - barcodeHeight - 5;
                        
                        // Fond blanc pour le code-barre
                        ctx.fillStyle = barcodeZoneColor;
                        ctx.fillRect(barcodeX, barcodeY, barcodeWidth, barcodeHeight);
                        
                        // Bordure
                        ctx.strokeStyle = '#cccccc';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([]);
                        ctx.strokeRect(barcodeX, barcodeY, barcodeWidth, barcodeHeight);
                        
                        // Texte indicatif
                        ctx.fillStyle = '#999999';
                        ctx.font = `${Math.max(6, 8 * scaleFactor / 4)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ISBN', barcodeX + barcodeWidth / 2, barcodeY + barcodeHeight / 2 - 5);
                        ctx.fillText('BARCODE', barcodeX + barcodeWidth / 2, barcodeY + barcodeHeight / 2 + 5);
                        
                        ctx.restore();
                    }
                };
                
                // üìù Helper function pour word wrap
                const wrapText = (context, text, x, y, maxWidth, lineHeight) => {
                    const words = text.split(' ');
                    let line = '';
                    let currentY = y;
                    
                    for (let n = 0; n < words.length; n++) {
                        const testLine = line + words[n] + ' ';
                        const metrics = context.measureText(testLine);
                        const testWidth = metrics.width;
                        
                        if (testWidth > maxWidth && n > 0) {
                            context.fillText(line.trim(), x, currentY);
                            line = words[n] + ' ';
                            currentY += lineHeight;
                        } else {
                            line = testLine;
                        }
                    }
                    context.fillText(line.trim(), x, currentY);
                };

                ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, displayWidth, displayHeight);

                // ‚úÖ AJOUT: Afficher la couleur de la tranche dans l'aper√ßu (comme dans l'export)
                if (dimensions.spine >= 1.0 && spineColor && spineColor !== '#ffffff' && spineWidth > 0) {
                    ctx.fillStyle = spineColor;
                    ctx.fillRect(startX + backWidth, startY, spineWidth, bookHeight);
                }

                // üé® DESSIN DU FOND DE LA 4√àME DE COUVERTURE
                // Fonction pour dessiner le fond personnalis√© sur une zone
                const drawCustomBackground = (targetX, targetY, targetWidth, targetHeight, callback) => {
                    // Dessiner la couleur de fond
                    ctx.fillStyle = backCoverBgColor;
                    ctx.fillRect(targetX, targetY, targetWidth, targetHeight);
                    
                    // Si une texture est d√©finie
                    if (backCoverTexture) {
                        // Si c'est une image custom (data URL ou URL externe)
                        if (backCoverTexture.url) {
                            const textureImg = new Image();
                            if (!backCoverTexture.url.startsWith('data:')) {
                                textureImg.crossOrigin = "anonymous";
                            }
                            textureImg.onload = () => {
                                ctx.drawImage(textureImg, targetX, targetY, targetWidth, targetHeight);
                                // Appliquer le filtre de couleur
                                if (textureColorFilter) {
                                    ctx.save();
                                    const hexToRgba = (hex, alpha) => {
                                        const r = parseInt(hex.slice(1, 3), 16);
                                        const g = parseInt(hex.slice(3, 5), 16);
                                        const b = parseInt(hex.slice(5, 7), 16);
                                        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                                    };
                                    ctx.globalCompositeOperation = 'overlay';
                                    ctx.fillStyle = hexToRgba(textureColorFilter, 0.7);
                                    ctx.fillRect(targetX, targetY, targetWidth, targetHeight);
                                    ctx.restore();
                                }
                                callback();
                            };
                            textureImg.onerror = () => callback();
                            textureImg.src = backCoverTexture.url;
                        } 
                        // Si c'est une texture proc√©durale
                        else if (backCoverTexture.name) {
                            const textureCanvas = generateTexture(backCoverTexture.name, Math.round(targetWidth * 2), Math.round(targetHeight * 2), backCoverBgColor);
                            ctx.drawImage(textureCanvas, targetX, targetY, targetWidth, targetHeight);
                            
                            // Appliquer le filtre de couleur si d√©fini
                            if (textureColorFilter) {
                                ctx.save();
                                const hexToRgba = (hex, alpha) => {
                                    const r = parseInt(hex.slice(1, 3), 16);
                                    const g = parseInt(hex.slice(3, 5), 16);
                                    const b = parseInt(hex.slice(5, 7), 16);
                                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                                };
                                ctx.globalCompositeOperation = 'overlay';
                                ctx.fillStyle = hexToRgba(textureColorFilter, 0.7);
                                ctx.fillRect(targetX, targetY, targetWidth, targetHeight);
                                ctx.restore();
                            }
                            callback();
                        } else {
                            callback();
                        }
                    } else {
                        callback();
                    }
                };

                // Dessiner le fond personnalis√© selon la zone choisie
                const drawBackgroundByZone = (callback) => {
                    if (backgroundApplyTo === 'none') {
                        callback();
                        return;
                    }
                    
                    if (backgroundApplyTo === 'full') {
                        // Full cover: back + spine + front
                        drawCustomBackground(startX, startY, bookWidth, bookHeight, callback);
                    } else if (backgroundApplyTo === 'back') {
                        // Back only
                        drawCustomBackground(startX, startY, backWidth, bookHeight, callback);
                    } else if (backgroundApplyTo === 'front') {
                        // Front only
                        const frontX = startX + backWidth + spineWidth;
                        drawCustomBackground(frontX, startY, frontWidth, bookHeight, callback);
                    } else {
                        callback();
                    }
                };

                const images = [];
                
                // üõí FULL COVER: Si c'est un Full Cover, afficher sur tout le canvas
                if (frontImage && frontImage.isFullCover) {
                    images.push({ 
                        img: frontImage, 
                        x: startX, 
                        y: startY, 
                        w: bookWidth, // Toute la largeur (back + spine + front)
                        h: bookHeight,
                        isFullCover: true,
                        type: 'fullcover',
                        offsetX: frontImageOffset.x,
                        offsetY: frontImageOffset.y,
                        zoom: frontImageZoom
                    });
                } else {
                    // Mode normal: images s√©par√©es pour back, spine, front
                    // Ne pas ajouter backImage si le fond personnalis√© couvre back ou full
                    if (backImage && backgroundApplyTo !== 'back' && backgroundApplyTo !== 'full') {
                        images.push({ 
                            img: backImage, 
                            x: startX, 
                            y: startY, 
                            w: backWidth, 
                            h: bookHeight,
                            type: 'back',
                            offsetX: backImageOffset.x,
                            offsetY: backImageOffset.y,
                            zoom: backImageZoom
                        });
                    }
                    if (spineImage && spineWidth > 10) {
                        images.push({ 
                            img: spineImage, 
                            x: startX + backWidth, 
                            y: startY, 
                            w: spineWidth, 
                            h: bookHeight,
                            type: 'spine',
                            offsetX: spineImageOffset.x,
                            offsetY: spineImageOffset.y,
                            zoom: spineImageZoom
                        });
                    }
                    // Ne pas ajouter frontImage si le fond personnalis√© couvre front ou full
                    if (frontImage && backgroundApplyTo !== 'front' && backgroundApplyTo !== 'full') {
                        images.push({ 
                            img: frontImage, 
                            x: startX + backWidth + spineWidth, 
                            y: startY, 
                            w: frontWidth, 
                            h: bookHeight,
                            type: 'front',
                            offsetX: frontImageOffset.x,
                            offsetY: frontImageOffset.y,
                            zoom: frontImageZoom
                        });
                    }
                }

                // Fonction pour dessiner les images
                const drawImages = () => {
                    const bgActive = backgroundApplyTo !== 'none';
                    
                    // Cas 1: Pas d'images et pas de fond personnalis√©
                    if (images.length === 0 && !bgActive) {
                        ctx.fillStyle = '#f3f4f6';
                        ctx.fillRect(startX, startY, backWidth, bookHeight);
                        ctx.fillRect(startX + backWidth + spineWidth, startY, frontWidth, bookHeight);
                        
                        if (spineWidth > 0) {
                            if (dimensions.spine >= 1.0 && spineColor && spineColor !== '#ffffff') {
                                ctx.fillStyle = spineColor;
                            } else {
                                ctx.fillStyle = '#f3f4f6';
                            }
                            ctx.fillRect(startX + backWidth, startY, spineWidth, bookHeight);
                        }
                        
                        ctx.fillStyle = '#6b7280'; ctx.font = '14px Arial'; ctx.textAlign = 'center';
                        ctx.fillText('VERSO', startX + backWidth / 2, startY + bookHeight / 2);
                        ctx.fillText('FACE', startX + backWidth + spineWidth + frontWidth / 2, startY + bookHeight / 2);
                        drawOverlays();
                    } 
                    // Cas 2: Fond personnalis√© actif
                    else if (bgActive) {
                        // Le fond est d√©j√† dessin√© par drawBackgroundByZone
                        
                        // Si back only ou full: rien √† faire pour back
                        // Si front only: dessiner back normal
                        if (backgroundApplyTo === 'front') {
                            if (backImage) {
                                const backImg = new Image();
                                backImg.crossOrigin = "anonymous";
                                backImg.onload = () => {
                                    ctx.drawImage(backImg, startX, startY, backWidth, bookHeight);
                                };
                                backImg.src = backImage.url;
                            } else {
                                ctx.fillStyle = '#f3f4f6';
                                ctx.fillRect(startX, startY, backWidth, bookHeight);
                                ctx.fillStyle = '#6b7280'; ctx.font = '14px Arial'; ctx.textAlign = 'center';
                                ctx.fillText('VERSO', startX + backWidth / 2, startY + bookHeight / 2);
                            }
                        }
                        
                        // Dessiner la tranche (sauf si full cover avec fond)
                        if (spineWidth > 0 && backgroundApplyTo !== 'full') {
                            if (spineImage) {
                                const spineImg = new Image();
                                spineImg.crossOrigin = "anonymous";
                                spineImg.onload = () => {
                                    ctx.drawImage(spineImg, startX + backWidth, startY, spineWidth, bookHeight);
                                };
                                spineImg.src = spineImage.url;
                            } else if (dimensions.spine >= 1.0 && spineColor && spineColor !== '#ffffff') {
                                ctx.fillStyle = spineColor;
                                ctx.fillRect(startX + backWidth, startY, spineWidth, bookHeight);
                            } else {
                                ctx.fillStyle = '#e5e7eb';
                                ctx.fillRect(startX + backWidth, startY, spineWidth, bookHeight);
                            }
                        }
                        
                        // Si back only: dessiner front normal
                        if (backgroundApplyTo === 'back') {
                            if (frontImage) {
                                const frontImg = new Image();
                                frontImg.crossOrigin = "anonymous";
                                frontImg.onload = () => {
                                    ctx.drawImage(frontImg, startX + backWidth + spineWidth, startY, frontWidth, bookHeight);
                                    drawOverlays();
                                };
                                frontImg.onerror = () => { drawOverlays(); };
                                frontImg.src = frontImage.url;
                            } else {
                                ctx.fillStyle = '#f3f4f6';
                                ctx.fillRect(startX + backWidth + spineWidth, startY, frontWidth, bookHeight);
                                ctx.fillStyle = '#6b7280'; ctx.font = '14px Arial'; ctx.textAlign = 'center';
                                ctx.fillText('FACE', startX + backWidth + spineWidth + frontWidth / 2, startY + bookHeight / 2);
                                drawOverlays();
                            }
                        } else {
                            drawOverlays();
                        }
                    }
                    // Cas 3: Images pr√©sentes sans fond personnalis√©
                    else {
                        let loadedCount = 0;
                        images.forEach(item => {
                            const img = new Image(); img.crossOrigin = "anonymous";
                            img.onload = () => {
                                // Utiliser drawImageCover avec offset et zoom
                                const box = { x: item.x, y: item.y, width: item.w, height: item.h };
                                const offsetX = item.offsetX || 0;
                                const offsetY = item.offsetY || 0;
                                const zoom = item.zoom || 1.0;
                                drawImageCover(ctx, img, box, 0.5, 0.5, zoom, offsetX, offsetY);
                                if (++loadedCount === images.length) drawOverlays();
                            };
                            img.onerror = () => { if (++loadedCount === images.length) drawOverlays(); };
                            img.src = item.img.url;
                        });
                    }
                };
                
                // Ex√©cuter le dessin: d'abord le fond, puis les images
                drawBackgroundByZone(drawImages);
                
            }, [dimensions, frontImage, backImage, spineImage, spineText, spineColor, spineTextColor, spineTextSize, spineTextFont, hasBleed, isMarketplacePreview, bookTitle, bookTitleSize, bookTitleColor, bookTitleFont, bookTitleX, bookTitleY, authorName, authorNameSize, authorNameColor, authorNameFont, authorNameX, authorNameY, backCoverText, backCoverTextSize, backCoverTextColor, backCoverTextFont, backCoverTextX, backCoverTextY, showBarcodeZone, barcodeZoneColor, draggingElement, backgroundApplyTo, backCoverBgColor, backCoverTexture, textureColorFilter, viewMode, frontImageOffset, backImageOffset, spineImageOffset, frontImageZoom, backImageZoom, spineImageZoom]);
            
            const exportImage = () => {
                if (format === '8.5x11' && !confirm(t('format8511Message'))) return;
                setIsExporting(true);
                setTimeout(() => {
                    try {
                        const exportCanvas = document.createElement('canvas');
                        const exportCtx = exportCanvas.getContext('2d');
                        
                        // üéØ DPI selon la qualit√© choisie ET le format d'export
                        // ‚ö†Ô∏è IMPORTANT: Pour PDF, on FORCE 300 DPI car KDP interpr√®te les images √† 300 DPI
                        // Si on exporte √† 400 DPI, KDP recalcule les dimensions et obtient du A4 !
                        let baseDpiScale;
                        let qualityLabel;
                        
                        // Pour PDF: toujours 300 DPI (KDP standard)
                        // Pour PNG/JPEG: qualit√© choisie par l'utilisateur
                        const isPdfExport = exportFormat === 'pdf';
                        
                        if (isPdfExport) {
                            // üìÑ PDF = 300 DPI obligatoire pour compatibilit√© KDP
                            baseDpiScale = 11.811; // 300 DPI
                            qualityLabel = '300 DPI (KDP)';
                            console.log('üìÑ [PDF] Export forc√© √† 300 DPI pour compatibilit√© KDP');
                        } else {
                            // PNG/JPEG: qualit√© au choix
                            switch(canvasQuality) {
                                case 'Standard':
                                    baseDpiScale = 11.811; // 300 DPI
                                    qualityLabel = '300 DPI';
                                    break;
                                case '8K':
                                    baseDpiScale = 23.622; // 600 DPI
                                    qualityLabel = '600 DPI';
                                    break;
                                case '4K':
                                default:
                                    baseDpiScale = 15.748; // 400 DPI
                                    qualityLabel = '400 DPI';
                                    break;
                            }
                        }
                        
                        const dpiScale = format === '8.5x11' ? baseDpiScale * 1.2 : baseDpiScale;
                        const exportWidth = Math.round(dimensions.total.width * dpiScale);
                        const exportHeight = Math.round(dimensions.total.height * dpiScale);
                        
                        // Avertissement pour 8K (fichiers tr√®s lourds)
                        if (canvasQuality === '8K' && exportWidth * exportHeight > 50000000) {
                            if (!confirm(language === 'fr' 
                                ? `‚ö†Ô∏è Export 8K (${qualityLabel})\n\nLe fichier sera tr√®s volumineux (${Math.round(exportWidth)}√ó${Math.round(exportHeight)} pixels).\n\nCela peut prendre du temps et consommer beaucoup de m√©moire.\n\nContinuer ?`
                                : `‚ö†Ô∏è 8K Export (${qualityLabel})\n\nThe file will be very large (${Math.round(exportWidth)}√ó${Math.round(exportHeight)} pixels).\n\nThis may take time and consume a lot of memory.\n\nContinue?`
                            )) {
                                setIsExporting(false);
                                return;
                            }
                        }
                        
                        console.log(`üìê Export: ${exportWidth}√ó${exportHeight}px @ ${qualityLabel}`);
                        
                        exportCanvas.width = exportWidth; exportCanvas.height = exportHeight;
                        exportCtx.imageSmoothingEnabled = true; exportCtx.imageSmoothingQuality = 'high';
                        exportCtx.fillStyle = '#ffffff'; exportCtx.fillRect(0, 0, exportWidth, exportHeight);

                        if (dimensions.bindingType === 'paperback') {
                            const frontWidth = dimensions.format.width * dpiScale;
                            const spineWidth = dimensions.spine * dpiScale;
                            const bleedMargin = dimensions.bleed * dpiScale;
                            
                            if (dimensions.spine >= 1.0 && spineColor && spineColor !== '#ffffff') {
                                exportCtx.fillStyle = spineColor;
                                exportCtx.fillRect(bleedMargin + frontWidth, 0, spineWidth, exportHeight);
                            }

                            const finalizeExport = () => {
                                if (spineText && spineWidth > 40 && dimensions.spine > 1.5) {
                                    exportCtx.save();
                                    exportCtx.translate(bleedMargin + frontWidth + spineWidth / 2, exportHeight / 2);
                                    exportCtx.rotate(-Math.PI / 2);
                                    exportCtx.fillStyle = spineTextColor || '#333333';
                                    const fontSize = Math.max(24, spineTextSize * dpiScale / 2.5);
                                    exportCtx.font = `${fontSize}px ${spineTextFont}`;
                                    exportCtx.textAlign = 'center'; exportCtx.textBaseline = 'middle';
                                    exportCtx.fillText(spineText, 0, 0);
                                    exportCtx.restore();
                                }
                                
                                // üìö EXPORT COVER TEXT - Titre, auteur, 4√®me de couv, code-barre
                                const safeZone = dimensions.safeZone * dpiScale;
                                
                                // Zone FRONT pour titre et auteur
                                const frontStartX = bleedMargin + frontWidth + spineWidth;
                                
                                // Zone BACK pour 4√®me de couv
                                const backStartXExport = bleedMargin;
                                
                                // üìñ TITRE DU LIVRE
                                if (bookTitle) {
                                    exportCtx.save();
                                    exportCtx.fillStyle = bookTitleColor;
                                    const titleFontSize = Math.max(48, bookTitleSize * dpiScale / 3);
                                    exportCtx.font = `bold ${titleFontSize}px ${bookTitleFont}`;
                                    exportCtx.textAlign = 'center';
                                    exportCtx.textBaseline = 'middle';
                                    
                                    // Positions X/Y bas√©es sur les pourcentages
                                    const titleX = frontStartX + (frontWidth * bookTitleX / 100);
                                    const titleY = exportHeight * bookTitleY / 100;
                                    
                                    // Ombre
                                    exportCtx.shadowColor = 'rgba(0,0,0,0.5)';
                                    exportCtx.shadowBlur = 8;
                                    exportCtx.shadowOffsetX = 4;
                                    exportCtx.shadowOffsetY = 4;
                                    
                                    // Word wrap
                                    const maxTitleWidth = frontWidth - (safeZone * 2);
                                    wrapTextExport(exportCtx, bookTitle, titleX, titleY, maxTitleWidth, titleFontSize * 1.2);
                                    
                                    exportCtx.restore();
                                }
                                
                                // üë§ NOM DE L'AUTEUR
                                if (authorName) {
                                    exportCtx.save();
                                    exportCtx.fillStyle = authorNameColor;
                                    const authorFontSize = Math.max(24, authorNameSize * dpiScale / 3);
                                    exportCtx.font = `${authorFontSize}px ${authorNameFont}`;
                                    exportCtx.textAlign = 'center';
                                    exportCtx.textBaseline = 'middle';
                                    
                                    const authorX = frontStartX + (frontWidth * authorNameX / 100);
                                    const authorY = exportHeight * authorNameY / 100;
                                    
                                    exportCtx.shadowColor = 'rgba(0,0,0,0.5)';
                                    exportCtx.shadowBlur = 6;
                                    exportCtx.shadowOffsetX = 2;
                                    exportCtx.shadowOffsetY = 2;
                                    
                                    exportCtx.fillText(authorName, authorX, authorY);
                                    exportCtx.restore();
                                }
                                
                                // üìñ 4√àME DE COUVERTURE
                                if (backCoverText) {
                                    exportCtx.save();
                                    exportCtx.fillStyle = backCoverTextColor;
                                    const backTextFontSize = Math.max(18, backCoverTextSize * dpiScale / 4);
                                    exportCtx.font = `${backTextFontSize}px ${backCoverTextFont}`;
                                    exportCtx.textAlign = 'center';
                                    exportCtx.textBaseline = 'top';
                                    
                                    const textX = backStartXExport + (frontWidth * backCoverTextX / 100);
                                    const textY = exportHeight * backCoverTextY / 100;
                                    const maxWidth = frontWidth - (safeZone * 2);
                                    
                                    wrapTextExport(exportCtx, backCoverText, textX, textY, maxWidth, backTextFontSize * 1.5);
                                    exportCtx.restore();
                                }
                                
                                // üìä ZONE CODE-BARRE ISBN
                                if (showBarcodeZone) {
                                    exportCtx.save();
                                    // Dimensions standards: 50.8mm x 30.5mm
                                    const barcodeWidth = 50.8 * dpiScale;
                                    const barcodeHeight = 30.5 * dpiScale;
                                    const barcodeX = bleedMargin + frontWidth - safeZone - barcodeWidth - 20;
                                    const barcodeY = exportHeight - safeZone - barcodeHeight - 20;
                                    
                                    exportCtx.fillStyle = barcodeZoneColor;
                                    exportCtx.fillRect(barcodeX, barcodeY, barcodeWidth, barcodeHeight);
                                    
                                    exportCtx.strokeStyle = '#cccccc';
                                    exportCtx.lineWidth = 2;
                                    exportCtx.strokeRect(barcodeX, barcodeY, barcodeWidth, barcodeHeight);
                                    
                                    // Texte indicatif
                                    exportCtx.fillStyle = '#999999';
                                    exportCtx.font = `${Math.max(12, 16 * dpiScale / 10)}px Arial`;
                                    exportCtx.textAlign = 'center';
                                    exportCtx.textBaseline = 'middle';
                                    exportCtx.fillText('ISBN BARCODE', barcodeX + barcodeWidth / 2, barcodeY + barcodeHeight / 2);
                                    
                                    exportCtx.restore();
                                }
                                
                                // Helper function pour word wrap export
                                function wrapTextExport(context, text, x, y, maxWidth, lineHeight) {
                                    const words = text.split(' ');
                                    let line = '';
                                    let currentY = y;
                                    
                                    for (let n = 0; n < words.length; n++) {
                                        const testLine = line + words[n] + ' ';
                                        const metrics = context.measureText(testLine);
                                        
                                        if (metrics.width > maxWidth && n > 0) {
                                            context.fillText(line.trim(), x, currentY);
                                            line = words[n] + ' ';
                                            currentY += lineHeight;
                                        } else {
                                            line = testLine;
                                        }
                                    }
                                    context.fillText(line.trim(), x, currentY);
                                }
                                
                                const userLevel = checkExportLimits().level;
                                const actualDPI = format === '8.5x11' ? '360' : '300';
                                // üîí KDP STRICT - Nom de fichier avec tous les param√®tres
                                const baseFilename = `couverture-kdp-${userLevel}-${format}-${pageCount}pages-${actualDPI}dpi-${bindingType}-${paperType}-${hasBleed ? 'bleed' : 'nobleed'}`;

                                if (exportFormat === 'pdf') {
                                    try {
                                        // üîí KDP STRICT - Validation bloquante
                                        validateKdpStrict({
                                            format, bindingType, paperType, pageCount, hasBleed,
                                            dimensions,
                                            kdpStrictConfirmed,
                                            language
                                        });

                                        const { jsPDF } = window.jspdf;

                                        // üîí Conversion dimensions mm -> points (pt)
                                        const Wpt = mmToPt(dimensions.total.width);
                                        const Hpt = mmToPt(dimensions.total.height);

                                        // Garde-fous anti valeurs bizarres
                                        if (!Number.isFinite(Wpt) || !Number.isFinite(Hpt)) {
                                            throw new Error("Export PDF: invalid page size.");
                                        }

                                        const orientation = (Wpt >= Hpt) ? 'landscape' : 'portrait';

                                        // üîí jsPDF en POINTS (pas mm) - √©vite le fallback A4
                                        const pdf = new jsPDF({
                                            orientation,
                                            unit: 'pt',
                                            format: [Wpt, Hpt],
                                            compress: true
                                        });

                                        // Image plac√©e exactement √† la taille de page
                                        const imgData = exportCanvas.toDataURL('image/png', 1.0);
                                        pdf.addImage(imgData, 'PNG', 0, 0, Wpt, Hpt);

                                        console.log(`üîí [KDP STRICT] Export PDF: ${Wpt.toFixed(2)}pt √ó ${Hpt.toFixed(2)}pt (${(Wpt/72).toFixed(3)}" √ó ${(Hpt/72).toFixed(3)}")`);

                                        pdf.save(`${baseFilename}.pdf`);
                                    } catch (err) {
                                        alert(err.message);
                                        setIsExporting(false);
                                        return;
                                    }
                                } else {
                                    const mimeType = exportFormat === 'jpeg' ? 'image/jpeg' : 'image/png';
                                    const filename = `${baseFilename}.${exportFormat === 'jpeg' ? 'jpg' : 'png'}`;
                                    const link = document.createElement('a');
                                    link.download = filename;
                                    link.href = exportCanvas.toDataURL(mimeType, 0.95);
                                    link.click();
                                }
                                alert(t('disclaimerExport'));

showFeedbackPrompt(document.documentElement.lang || 'en'); // feedback

                                setIsExporting(false);
                            };

                            const processImage4K = (imageData, box) => {
                                return new Promise((resolve) => {
                                    if (!imageData?.url) {
                                        console.log('‚ö†Ô∏è [EXPORT] Image sans URL, skip');
                                        resolve();
                                        return;
                                    }
                                    console.log('üñºÔ∏è [EXPORT] Chargement image:', imageData.url.substring(0, 50) + '...');
                                    const img = new Image();
                                    img.crossOrigin = "anonymous";
                                    img.onload = () => {
                                        console.log('‚úÖ [EXPORT] Image charg√©e, dessin √†', box.x, box.y, box.width, box.height);
                                        exportCtx.drawImage(img, box.x, box.y, box.width, box.height);
                                        resolve();
                                    };
                                    img.onerror = (err) => {
                                        console.error('‚ùå [EXPORT] Erreur chargement image:', err);
                                        resolve();
                                    };
                                    img.src = imageData.url;
                                });
                            };
                            
                            // ‚úÖ CORRECTION FINALE : Layout KDP officiel avec bleed
                            // Le canvas total fait : totalWidth √ó totalHeight (avec bleed inclus)
                            // Les images D√âBORDENT dans le bleed, elles ne sont pas CONTENUES dedans
                            
                            const totalHeight = exportHeight; // Inclut d√©j√† le bleed haut et bas
                            
                            // VERSO : commence √† x=0 (d√©borde dans le bleed gauche)
                            const backBox = { 
                                x: 0, 
                                y: 0, 
                                width: frontWidth + bleedMargin,  // Inclut le bleed √† droite du verso
                                height: totalHeight 
                            };
                            
                            // TRANCHE : au milieu (pas de bleed sur la tranche)
                            const spineBox = { 
                                x: frontWidth + bleedMargin, 
                                y: 0, 
                                width: spineWidth, 
                                height: totalHeight 
                            };
                            
                            // RECTO : commence apr√®s tranche, jusqu'au bout (d√©borde dans le bleed droit)
                            const frontBox = { 
                                x: frontWidth + bleedMargin + spineWidth, 
                                y: 0, 
                                width: frontWidth + bleedMargin,  // Inclut le bleed √† droite du recto
                                height: totalHeight 
                            };

                            // üé® Fonction async pour dessiner toutes les images
                            const drawAllImages = async () => {
                                console.log('üé® [EXPORT] D√©but du dessin des images...');
                                console.log('üìä [EXPORT] frontImage:', !!frontImage, 'backImage:', !!backImage, 'spineImage:', !!spineImage);
                                
                                // üõí FULL COVER: Si c'est un Full Cover, exporter l'image sur tout le canvas
                                if (frontImage && frontImage.isFullCover) {
                                    console.log('üõí [EXPORT] Mode Full Cover');
                                    const fullCoverBox = {
                                        x: 0,
                                        y: 0,
                                        width: exportWidth,
                                        height: exportHeight
                                    };
                                    await processImage4K(frontImage, fullCoverBox);
                                } else {
                                    // üé® EXPORT: Fond personnalis√© selon la zone choisie
                                    const drawExportBackground = (targetBox) => {
                                        return new Promise((resolve) => {
                                            // Dessiner la couleur de fond
                                            exportCtx.fillStyle = backCoverBgColor;
                                            exportCtx.fillRect(targetBox.x, targetBox.y, targetBox.width, targetBox.height);
                                            
                                            // Si une texture est d√©finie
                                            if (backCoverTexture) {
                                                if (backCoverTexture.url) {
                                                    const textureImg = new Image();
                                                    textureImg.crossOrigin = "anonymous";
                                                    textureImg.onload = () => {
                                                        exportCtx.drawImage(textureImg, targetBox.x, targetBox.y, targetBox.width, targetBox.height);
                                                        if (textureColorFilter) {
                                                            exportCtx.save();
                                                            const hexToRgba = (hex, alpha) => {
                                                                const r = parseInt(hex.slice(1, 3), 16);
                                                                const g = parseInt(hex.slice(3, 5), 16);
                                                                const b = parseInt(hex.slice(5, 7), 16);
                                                                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                                                            };
                                                            exportCtx.globalCompositeOperation = 'overlay';
                                                            exportCtx.fillStyle = hexToRgba(textureColorFilter, 0.7);
                                                            exportCtx.fillRect(targetBox.x, targetBox.y, targetBox.width, targetBox.height);
                                                            exportCtx.restore();
                                                        }
                                                        resolve();
                                                    };
                                                    textureImg.onerror = () => resolve();
                                                    textureImg.src = backCoverTexture.url;
                                                } else if (backCoverTexture.name) {
                                                    const textureCanvas = generateTexture(backCoverTexture.name, Math.round(targetBox.width), Math.round(targetBox.height), backCoverBgColor);
                                                    exportCtx.drawImage(textureCanvas, targetBox.x, targetBox.y, targetBox.width, targetBox.height);
                                                    if (textureColorFilter) {
                                                        exportCtx.save();
                                                        const hexToRgba = (hex, alpha) => {
                                                            const r = parseInt(hex.slice(1, 3), 16);
                                                            const g = parseInt(hex.slice(3, 5), 16);
                                                            const b = parseInt(hex.slice(5, 7), 16);
                                                            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                                                        };
                                                        exportCtx.globalCompositeOperation = 'overlay';
                                                        exportCtx.fillStyle = hexToRgba(textureColorFilter, 0.7);
                                                        exportCtx.fillRect(targetBox.x, targetBox.y, targetBox.width, targetBox.height);
                                                        exportCtx.restore();
                                                    }
                                                    resolve();
                                                } else {
                                                    resolve();
                                                }
                                            } else {
                                                resolve();
                                            }
                                        });
                                    };

                                    // Dessiner le fond si n√©cessaire
                                    if (backgroundApplyTo === 'full') {
                                        const fullBox = { x: backBox.x, y: backBox.y, width: backBox.width + spineBox.width + frontBox.width, height: backBox.height };
                                        await drawExportBackground(fullBox);
                                    } else if (backgroundApplyTo === 'back') {
                                        await drawExportBackground(backBox);
                                    } else if (backgroundApplyTo === 'front') {
                                        await drawExportBackground(frontBox);
                                    }

                                    // Dessiner les images selon la zone
                                    if (backgroundApplyTo === 'back') {
                                        // Back a le fond, dessiner front et spine
                                        if (frontImage) await processImage4K(frontImage, frontBox);
                                        if (dimensions.spine >= 2.0 && spineImage) await processImage4K(spineImage, spineBox);
                                    } else if (backgroundApplyTo === 'front') {
                                        // Front a le fond, dessiner back et spine
                                        if (backImage) await processImage4K(backImage, backBox);
                                        if (dimensions.spine >= 2.0 && spineImage) await processImage4K(spineImage, spineBox);
                                    } else if (backgroundApplyTo === 'full') {
                                        // Full cover - juste spine si pr√©sent
                                        if (dimensions.spine >= 2.0 && spineImage) await processImage4K(spineImage, spineBox);
                                    } else {
                                        // None - dessiner toutes les images
                                        if (backImage) await processImage4K(backImage, backBox);
                                        if (frontImage) await processImage4K(frontImage, frontBox);
                                        if (dimensions.spine >= 2.0 && spineImage) await processImage4K(spineImage, spineBox);
                                    }
                                }
                                
                                console.log('‚úÖ [EXPORT] Toutes les images dessin√©es, finalisation...');
                                finalizeExport();
                            };

                            // Lancer le dessin
                            drawAllImages();
                        }
                    } catch (error) {
                        alert(`Erreur lors de l'export: ${error.message}`);
                        setIsExporting(false);
                    }
                }, 200);
            };
            
            // üìö EXPORT MOCKUP 3D
            const export3DMockup = async () => {
                const mockupContainer = document.getElementById('mockup-3d-export');
                if (!mockupContainer) {
                    alert(language === 'fr' ? 'Passez en mode 3D pour exporter le mockup' : 'Switch to 3D mode to export mockup');
                    return;
                }
                
                setIsExporting(true);
                
                try {
                    // V√©rifier que html2canvas est charg√©
                    if (typeof html2canvas === 'undefined') {
                        throw new Error('html2canvas not loaded');
                    }
                    
                    const canvas = await html2canvas(mockupContainer, {
                        backgroundColor: '#1a1a2e',
                        scale: 2, // Haute r√©solution
                        useCORS: true,
                        allowTaint: true,
                        logging: false
                    });
                    
                    // T√©l√©charger l'image
                    const link = document.createElement('a');
                    const title = bookTitle || 'book';
                    const safeName = title.replace(/[^a-z0-9]/gi, '_').substring(0, 30);
                    link.download = `${safeName}_3D_mockup.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    
                    // Incr√©menter le compteur d'export si applicable
                    if (window.trackExport) window.trackExport();
                    
                } catch (error) {
                    console.error('Erreur export 3D:', error);
                    alert(language === 'fr' 
                        ? 'Erreur lors de l\'export 3D. Essayez de faire une capture d\'√©cran (Ctrl+Shift+S).' 
                        : '3D export error. Try taking a screenshot (Ctrl+Shift+S).');
                }
                
                setIsExporting(false);
            };

            // üñ±Ô∏è DRAG & DROP HANDLERS pour d√©placer le texte sur le canvas
            const handleCanvasMouseDown = useCallback((e) => {
                if (!dimensions || !canvasRef.current) return;
                
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Dimensions du canvas
                const displayWidth = 600;
                const displayHeight = 400;
                const bookWidth = displayWidth - 40;
                const bookHeight = displayHeight - 40;
                const startX = 20;
                const startY = 20;
                const scaleFactor = bookWidth / dimensions.total.width;
                const frontWidth = dimensions.format.width * scaleFactor;
                const spineWidth = dimensions.spine * scaleFactor;
                const backWidth = frontWidth;
                
                // Zone FRONT (face) - pour titre et auteur
                const frontStartX = startX + backWidth + spineWidth;
                const frontEndX = frontStartX + frontWidth;
                const endY = startY + bookHeight;
                
                // Zone BACK (dos) - pour 4√®me de couverture
                const backStartX = startX;
                const backEndX = startX + backWidth;
                
                // V√©rifier quel √©l√©ment on touche (avec zone de tol√©rance)
                const tolerance = 30;
                
                // Titre (sur la face) - PRIORIT√â au texte
                if (bookTitle && x >= frontStartX && x <= frontEndX) {
                    const titleY = startY + (bookHeight * bookTitleY / 100);
                    if (Math.abs(y - titleY) < tolerance) {
                        setDraggingElement('title');
                        setDragOffset({ x: x - (frontStartX + frontWidth * bookTitleX / 100), y: y - titleY });
                        return;
                    }
                }
                
                // Auteur (sur la face)
                if (authorName && x >= frontStartX && x <= frontEndX) {
                    const authorY = startY + (bookHeight * authorNameY / 100);
                    if (Math.abs(y - authorY) < tolerance) {
                        setDraggingElement('author');
                        setDragOffset({ x: x - (frontStartX + frontWidth * authorNameX / 100), y: y - authorY });
                        return;
                    }
                }
                
                // Texte 4√®me de couv (sur le dos)
                if (backCoverText && x >= backStartX && x <= backEndX) {
                    const backTextY = startY + (bookHeight * backCoverTextY / 100);
                    if (Math.abs(y - backTextY) < tolerance) {
                        setDraggingElement('backText');
                        setDragOffset({ x: x - (backStartX + backWidth * backCoverTextX / 100), y: y - backTextY });
                        return;
                    }
                }
                
                // üñºÔ∏è DRAG IMAGE FRONT (si pas de texte touch√©)
                if (frontImage && x >= frontStartX && x <= frontEndX && y >= startY && y <= endY) {
                    setDraggingElement('frontImage');
                    setSelectedImage('front');
                    setDragStartPos({ x: x - frontImageOffset.x, y: y - frontImageOffset.y });
                    return;
                }
                
                // üñºÔ∏è DRAG IMAGE BACK (4√®me de couverture)
                if (backImage && x >= backStartX && x <= backEndX && y >= startY && y <= endY) {
                    setDraggingElement('backImage');
                    setSelectedImage('back');
                    setDragStartPos({ x: x - backImageOffset.x, y: y - backImageOffset.y });
                    return;
                }
                
                // üñºÔ∏è DRAG IMAGE SPINE (tranche)
                const spineStartX = startX + backWidth;
                const spineEndX = spineStartX + spineWidth;
                if (spineImage && x >= spineStartX && x <= spineEndX && y >= startY && y <= endY) {
                    setDraggingElement('spineImage');
                    setSelectedImage('spine');
                    setDragStartPos({ x: x - spineImageOffset.x, y: y - spineImageOffset.y });
                    return;
                }
                
                // Si clic ailleurs, d√©s√©lectionner
                setSelectedImage(null);
            }, [dimensions, bookTitle, bookTitleX, bookTitleY, authorName, authorNameX, authorNameY, backCoverText, backCoverTextX, backCoverTextY, frontImage, backImage, spineImage, frontImageOffset, backImageOffset, spineImageOffset]);
            
            const handleCanvasMouseMove = useCallback((e) => {
                if (!draggingElement || !dimensions || !canvasRef.current) return;
                
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const displayWidth = 600;
                const displayHeight = 400;
                const bookWidth = displayWidth - 40;
                const bookHeight = displayHeight - 40;
                const startX = 20;
                const startY = 20;
                const scaleFactor = bookWidth / dimensions.total.width;
                const frontWidth = dimensions.format.width * scaleFactor;
                const spineWidth = dimensions.spine * scaleFactor;
                const backWidth = frontWidth;
                
                const frontStartX = startX + backWidth + spineWidth;
                const backStartX = startX;
                
                // üñºÔ∏è DRAG IMAGE FRONT
                if (draggingElement === 'frontImage') {
                    setFrontImageOffset({
                        x: x - dragStartPos.x,
                        y: y - dragStartPos.y
                    });
                    return;
                }
                
                // üñºÔ∏è DRAG IMAGE BACK
                if (draggingElement === 'backImage') {
                    setBackImageOffset({
                        x: x - dragStartPos.x,
                        y: y - dragStartPos.y
                    });
                    return;
                }
                
                // üñºÔ∏è DRAG IMAGE SPINE
                if (draggingElement === 'spineImage') {
                    setSpineImageOffset({
                        x: x - dragStartPos.x,
                        y: y - dragStartPos.y
                    });
                    return;
                }
                
                // Calculer les nouvelles positions en pourcentage pour le TEXTE
                const xAdjusted = x - dragOffset.x;
                const yAdjusted = y - dragOffset.y;
                
                if (draggingElement === 'title') {
                    const newX = Math.max(10, Math.min(90, ((xAdjusted - frontStartX) / frontWidth) * 100));
                    const newY = Math.max(5, Math.min(95, ((yAdjusted - startY) / bookHeight) * 100));
                    setBookTitleX(newX);
                    setBookTitleY(newY);
                } else if (draggingElement === 'author') {
                    const newX = Math.max(10, Math.min(90, ((xAdjusted - frontStartX) / frontWidth) * 100));
                    const newY = Math.max(5, Math.min(95, ((yAdjusted - startY) / bookHeight) * 100));
                    setAuthorNameX(newX);
                    setAuthorNameY(newY);
                } else if (draggingElement === 'backText') {
                    const newX = Math.max(10, Math.min(90, ((xAdjusted - backStartX) / backWidth) * 100));
                    const newY = Math.max(5, Math.min(95, ((yAdjusted - startY) / bookHeight) * 100));
                    setBackCoverTextX(newX);
                    setBackCoverTextY(newY);
                }
            }, [draggingElement, dimensions, dragOffset, dragStartPos]);
            
            const handleCanvasMouseUp = useCallback(() => {
                setDraggingElement(null);
            }, []);

            // üéØ FONCTION PRINCIPALE D'EXPORT avec gestion compl√®te
            const getCurrentDesignData = () => {
                return {
                    format, pageCount, paperType, bindingType, coverFinish, hasBleed,
                    spineText, bookTitle, authorName, backCoverText,
                    spineColor, spineTextColor, spineTextFont,
                    bookTitleColor, bookTitleFont, bookTitleSize,
                    authorNameColor, authorNameFont, authorNameSize,
                    backCoverTextColor, backCoverTextFont, backCoverTextSize,
                    backCoverBgColor,
                    bookTitleX, bookTitleY, authorNameX, authorNameY,
                    isFullCover: !!(frontImage && frontImage.isFullCover),
                    frontImage: frontImage ? { 
                        url: frontImage.url, 
                        naturalWidth: frontImage.naturalWidth, 
                        naturalHeight: frontImage.naturalHeight,
                        isFullCover: frontImage.isFullCover,
                        isMarketplace: frontImage.isMarketplace
                    } : null,
                    backImage: backImage ? { 
                        url: backImage.url, 
                        naturalWidth: backImage.naturalWidth, 
                        naturalHeight: backImage.naturalHeight 
                    } : null,
                    templateUrl: (window.getActiveTemplateUrl ? window.getActiveTemplateUrl() : null),
                    title: (designTitle || bookTitle || 'Design').trim()
                };
            };
            
            // Exposer globalement pour la sauvegarde depuis window.gkdpSaveCurrentDesign
            window.getCurrentDesignData = getCurrentDesignData;

            const applyDesignData = (saved) => {
                if (!saved) return;
                // Param√®tres livre
                if (saved.format) setFormat(saved.format);
                if (saved.pageCount) setPageCount(saved.pageCount);
                if (saved.paperType) setPaperType(saved.paperType);
                if (saved.bindingType) setBindingType(saved.bindingType);
                if (saved.coverFinish) setCoverFinish(saved.coverFinish);
                if (saved.hasBleed !== undefined) setHasBleed(saved.hasBleed);

                // Texte
                if (saved.spineText !== undefined) setSpineText(saved.spineText);
                if (saved.bookTitle !== undefined) setBookTitle(saved.bookTitle);
                if (saved.authorName !== undefined) setAuthorName(saved.authorName);
                if (saved.backCoverText !== undefined) setBackCoverText(saved.backCoverText);

                // Couleurs / polices
                if (saved.spineColor) setSpineColor(saved.spineColor);
                if (saved.spineTextColor) setSpineTextColor(saved.spineTextColor);
                if (saved.spineTextFont) setSpineTextFont(saved.spineTextFont);
                if (saved.bookTitleColor) setBookTitleColor(saved.bookTitleColor);
                if (saved.bookTitleFont) setBookTitleFont(saved.bookTitleFont);
                if (saved.bookTitleSize) setBookTitleSize(saved.bookTitleSize);
                if (saved.authorNameColor) setAuthorNameColor(saved.authorNameColor);
                if (saved.authorNameFont) setAuthorNameFont(saved.authorNameFont);
                if (saved.authorNameSize) setAuthorNameSize(saved.authorNameSize);
                if (saved.backCoverTextColor) setBackCoverTextColor(saved.backCoverTextColor);
                if (saved.backCoverTextFont) setBackCoverTextFont(saved.backCoverTextFont);
                if (saved.backCoverTextSize) setBackCoverTextSize(saved.backCoverTextSize);
                if (saved.backCoverBgColor) setBackCoverBgColor(saved.backCoverBgColor);

                // Positions
                if (saved.bookTitleX !== undefined) setBookTitleX(saved.bookTitleX);
                if (saved.bookTitleY !== undefined) setBookTitleY(saved.bookTitleY);
                if (saved.authorNameX !== undefined) setAuthorNameX(saved.authorNameX);
                if (saved.authorNameY !== undefined) setAuthorNameY(saved.authorNameY);

                // Images - charger depuis URL si n√©cessaire
                if (saved.frontImage && saved.frontImage.url) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        setFrontImage({
                            ...saved.frontImage,
                            naturalWidth: img.naturalWidth,
                            naturalHeight: img.naturalHeight
                        });
                        console.log('‚úÖ [RESTORE] Front image loaded:', img.naturalWidth, 'x', img.naturalHeight);
                    };
                    img.onerror = (err) => {
                        console.error('‚ùå [RESTORE] Error loading front image:', err);
                    };
                    img.src = saved.frontImage.url;
                } else if (saved.frontImage) {
                    setFrontImage(saved.frontImage);
                }
                
                if (saved.backImage && saved.backImage.url) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        setBackImage({
                            ...saved.backImage,
                            naturalWidth: img.naturalWidth,
                            naturalHeight: img.naturalHeight
                        });
                        console.log('‚úÖ [RESTORE] Back image loaded:', img.naturalWidth, 'x', img.naturalHeight);
                    };
                    img.onerror = (err) => {
                        console.error('‚ùå [RESTORE] Error loading back image:', err);
                    };
                    img.src = saved.backImage.url;
                } else if (saved.backImage) {
                    setBackImage(saved.backImage);
                }

                if (saved.templateUrl) window.setActiveTemplateUrl && window.setActiveTemplateUrl(saved.templateUrl);
                setDesignRestored(true);
            };

            const refreshDesignsList = () => {
                const items = window.gkdpListDesigns ? window.gkdpListDesigns() : [];
                setDesignsList(items || []);
            };

            const openDesignsModal = () => {
                refreshDesignsList();
                setDesignsModalOpen(true);
            };
            
            const openDesignById = (id) => {
                const rec = window.gkdpGetDesign ? window.gkdpGetDesign(id) : null;

                if (!rec) {
                    alert(language === 'fr' ? "Design introuvable." : "Design not found.");
                    return;
                }
                if (!rec.designData) {
                    alert(language === 'fr'
                        ? "Ce design est incomplet (donn√©es manquantes). Supprime-le et re-sauvegarde."
                        : "This design is incomplete (missing data). Delete it and save again."
                    );
                    return;
                }

                if (rec.templateUrl) window.setActiveTemplateUrl && window.setActiveTemplateUrl(rec.templateUrl);

                setActiveDesignId(rec.id);
                localStorage.setItem('gkdp_active_design_id', rec.id);
                setDesignTitle(rec.title || '');

                window.gkdpTouchDesign && window.gkdpTouchDesign(rec.id);

                applyDesignData(rec.designData);
                setDesignsModalOpen(false);
                
                console.log('‚úÖ [DESIGN LIBRARY] Design opened:', rec.title);
            };

            const saveCurrentToLibrary = () => {
                const data = getCurrentDesignData();
                const title = (designTitle || bookTitle || 'Design').trim();
                const record = window.gkdpUpsertDesign ? window.gkdpUpsertDesign({
                    // NE PAS passer d'ID pour forcer la cr√©ation d'un nouveau design
                    title,
                    templateUrl: data.templateUrl,
                    designData: data,
                    lastUsedAt: new Date().toISOString()
                }) : null;

                if (record && record.id) {
                    setActiveDesignId(record.id);
                    localStorage.setItem('gkdp_active_design_id', record.id);
                    setDesignTitle(record.title || title);
                    refreshDesignsList();
                    alert(language === 'fr' ? '‚úÖ Design sauvegard√© dans votre biblioth√®que.' : '‚úÖ Design saved to your library.');
                } else {
                    alert(language === 'fr' ? '‚ùå Impossible de sauvegarder le design.' : '‚ùå Could not save design.');
                }
            };

            const createNewDesign = () => {
                // Nouveau design = on oublie l'id actif + on r√©initialise (via onReset)
                setActiveDesignId(null);
                localStorage.removeItem('gkdp_active_design_id');
                setDesignTitle('');
                // √âvite que le restore automatique ne remette un ancien design
                window.clearTempDesign && window.clearTempDesign();
                // R√©initialiser l'UI / √©tats (re-montage du composant)
                onReset && onReset();

            };

            useEffect(() => {
                if (!activeDesignId) return;
                const rec = window.gkdpGetDesign ? window.gkdpGetDesign(activeDesignId) : null;
                if (rec && rec.title && !designTitle) setDesignTitle(rec.title);
            }, [activeDesignId]);

            const handleExportClick = async () => {
                if (!dimensions) { 
                    alert(t('selectFormat')); 
                    return; 
                }
                
                // 1Ô∏è‚É£ V√âRIFIER SI L'UTILISATEUR EST CONNECT√â (via Supabase OU localStorage)
                let isLoggedIn = false;
                let userEmail = localStorage.getItem('userEmail');
                
                // Double v√©rification: localStorage ET session Supabase
                if (userEmail) {
                    isLoggedIn = true;
                } else if (window.supabaseClient) {
                    try {
                        const { data: { session } } = await window.supabaseClient.auth.getSession();
                        if (session && session.user) {
                            isLoggedIn = true;
                            userEmail = session.user.email;
                            localStorage.setItem('userEmail', userEmail);
                            // Rafra√Æchir les cr√©dits
                            if (window.refreshExportCredits) {
                                await window.refreshExportCredits();
                            }
                        }
                    } catch (e) {
                        console.log('Erreur v√©rification session:', e);
                    }
                }
                
                if (!isLoggedIn) {
                    // üíæ Sauvegarder le design AVANT de rediriger
                    const designData = {
                        format, pageCount, paperType, bindingType, coverFinish, hasBleed,
                        spineText, bookTitle, authorName, backCoverText,
                        spineColor, spineTextColor, spineTextFont,
                        bookTitleColor, bookTitleFont, bookTitleSize,
                        authorNameColor, authorNameFont, authorNameSize,
                        backCoverTextColor, backCoverTextFont, backCoverTextSize,
                        backCoverBgColor,
                        bookTitleX, bookTitleY, authorNameX, authorNameY,
                        // Sauvegarder aussi le mode full cover
                        isFullCover: !!(frontImage && frontImage.isFullCover),
                        frontImage: frontImage ? { 
                            url: frontImage.url, 
                            naturalWidth: frontImage.naturalWidth, 
                            naturalHeight: frontImage.naturalHeight,
                            isFullCover: frontImage.isFullCover 
                        } : null,
                        backImage: backImage ? { 
                            url: backImage.url, 
                            naturalWidth: backImage.naturalWidth, 
                            naturalHeight: backImage.naturalHeight 
                        } : null,
                    };
                    window.saveTempDesign && window.saveTempDesign(designData);
                    
                    // üîÄ Rediriger vers inscription
                    const msg = language === 'fr' 
                        ? 'üìù Inscrivez-vous gratuitement pour exporter!\n\nVous recevrez 3 exports gratuits.\nVotre design sera sauvegard√©.'
                        : 'üìù Sign up for free to export!\n\nYou will get 3 free exports.\nYour design will be saved.';
                    alert(msg);
                    window.location.href = 'inscription.html';
                    return;
                }
                
                // 2Ô∏è‚É£ V√âRIFIER LES CR√âDITS
                const credits = window.getExportCredits ? window.getExportCredits() : 0;
                const isPro = localStorage.getItem('userProfile') === 'pro';
                
                if (!isPro && credits <= 0) {
                    const msg = language === 'fr'
                        ? 'üò¢ Vous avez utilis√© tous vos exports gratuits!\n\nPassez √† PRO pour des exports illimit√©s.'
                        : 'üò¢ You have used all your free exports!\n\nUpgrade to PRO for unlimited exports.';
                    alert(msg);
                    window.location.href = 'index.html#tarifs';
                    return;
                }
                
                // 3Ô∏è‚É£ EXPORTER LE DESIGN
                exportImage();
                
                // 4Ô∏è‚É£ D√âCOMPTER LE CR√âDIT (si pas PRO)
                if (!isPro && window.decrementExportCredit) {
                    await window.decrementExportCredit();
                    // Mettre √† jour l'affichage
                    const newCredits = window.getExportCredits ? window.getExportCredits() : 0;
                    setExportLimitInfo({ canExport: newCredits > 0, remaining: newCredits, level: 'free' });
                }
            };

            // üõí STRIPE - G√©rer le paiement
            const handleStripePayment = (type) => {
                const lang = localStorage.getItem('preferredLanguage') || 'en';
                
                if (type === 'payPerExport') {
                    // Rediriger vers Stripe Pay-per-Export
                    window.open(STRIPE_LINKS.payPerExport, '_blank');
                } else if (type === 'proUnlimited') {
                    // Rediriger vers Stripe Pro Unlimited
                    window.open(STRIPE_LINKS.proUnlimited, '_blank');
                }
                
                setShowStripeModal(false);
                
                // Message d'information
                const msg = lang === 'fr'
                    ? 'üìß Apr√®s le paiement, vous recevrez un email de confirmation. Rechargez cette page pour exporter.'
                    : 'üìß After payment, you will receive a confirmation email. Reload this page to export.';
                alert(msg);
            };

            const resetForm = () => {
                if (confirm(t('resetForm') + '?')) {
                    onReset();
                }
            };
            
            useEffect(() => {
                window.reactSetLanguage = setLanguage;
            }, []);

            // Exposer les fonctions pour l'int√©gration Canva
            useEffect(() => {
                window.reactSetFrontImage = (imageData) => {
                    console.log('üéØ [REACT] setFrontImage appel√©', imageData);
                    setFrontImage(imageData);
                };
                
                window.reactSetBackImage = (imageData) => {
                    console.log('üéØ [REACT] setBackImage appel√©', imageData);
                    setBackImage(imageData);
                };
                
                return () => {
                    delete window.reactSetFrontImage;
                    delete window.reactSetBackImage;
                };
            }, []);

            useEffect(() => {
                // Initialiser les cr√©dits depuis localStorage
                const credits = window.getExportCredits ? window.getExportCredits() : 0;
                const isPro = localStorage.getItem('userProfile') === 'pro';
                setExportLimitInfo({ 
                    canExport: isPro || credits > 0, 
                    remaining: isPro ? Infinity : credits, 
                    level: isPro ? 'pro' : 'free' 
                });
            }, []);
            
            // üíæ STATE pour les notifications
            const [designRestored, setDesignRestored] = useState(false);
            
            // üíæ CHARGER LE DESIGN SAUVEGARD√â AU MOUNT (temp ou permanent)
            useEffect(() => {
                const timer = setTimeout(() => {
                    // D'abord essayer de charger un design temporaire (apr√®s inscription)
                    let saved = window.loadTempDesign && window.loadTempDesign();
                    let isTemp = !!saved;
                    
                    // Si pas de design temp, essayer le permanent (utilisateur connect√©)
                    if (!saved && window.isUserLoggedIn && window.isUserLoggedIn()) {
                        saved = window.loadPermanentDesign && window.loadPermanentDesign();
                    }
                    
                    // ‚úÖ Eviter de restaurer un ancien design sur un template diff√©rent
                    const activeTemplateUrl = (window.getActiveTemplateUrl ? window.getActiveTemplateUrl() : null);
                    if (activeTemplateUrl && saved && saved.templateUrl && saved.templateUrl !== activeTemplateUrl) {
                        console.log('üíæ [RESTORE] Ignored: saved design is for another template.', saved.templateUrl, '!=', activeTemplateUrl);
                        saved = null;
                    }

                    if (saved && !isMarketplacePreview) {
                        console.log('üíæ [RESTORE] Restauration du design...');
                        
                        // Restaurer les param√®tres du livre
                        if (saved.format) setFormat(saved.format);
                        if (saved.pageCount) setPageCount(saved.pageCount);
                        if (saved.paperType) setPaperType(saved.paperType);
                        if (saved.bindingType) setBindingType(saved.bindingType);
                        if (saved.coverFinish) setCoverFinish(saved.coverFinish);
                        if (saved.hasBleed !== undefined) setHasBleed(saved.hasBleed);
                        
                        // Restaurer le texte
                        if (saved.spineText) setSpineText(saved.spineText);
                        if (saved.bookTitle) setBookTitle(saved.bookTitle);
                        if (saved.authorName) setAuthorName(saved.authorName);
                        if (saved.backCoverText) setBackCoverText(saved.backCoverText);
                        
                        // Restaurer les couleurs et polices
                        if (saved.spineColor) setSpineColor(saved.spineColor);
                        if (saved.spineTextColor) setSpineTextColor(saved.spineTextColor);
                        if (saved.spineTextFont) setSpineTextFont(saved.spineTextFont);
                        if (saved.bookTitleColor) setBookTitleColor(saved.bookTitleColor);
                        if (saved.bookTitleFont) setBookTitleFont(saved.bookTitleFont);
                        if (saved.authorNameColor) setAuthorNameColor(saved.authorNameColor);
                        if (saved.authorNameFont) setAuthorNameFont(saved.authorNameFont);
                        if (saved.backCoverTextColor) setBackCoverTextColor(saved.backCoverTextColor);
                        if (saved.backCoverTextFont) setBackCoverTextFont(saved.backCoverTextFont);
                        if (saved.backCoverBgColor) setBackCoverBgColor(saved.backCoverBgColor);
                        
                        // Restaurer les positions
                        if (saved.bookTitleX) setBookTitleX(saved.bookTitleX);
                        if (saved.bookTitleY) setBookTitleY(saved.bookTitleY);
                        if (saved.authorNameX) setAuthorNameX(saved.authorNameX);
                        if (saved.authorNameY) setAuthorNameY(saved.authorNameY);
                        
                        // Restaurer les images
                        if (saved.frontImage) setFrontImage(saved.frontImage);
                        if (saved.backImage) setBackImage(saved.backImage);
                        
                        setDesignRestored(true);
                        console.log('üíæ [RESTORE] ‚úÖ Design restaur√©!');
                        
                        // Si c'√©tait un design temporaire, le supprimer et le sauvegarder en permanent
                        if (isTemp) {
                            window.clearTempDesign && window.clearTempDesign();
                            // Sauvegarder en permanent si connect√©
                            if (window.isUserLoggedIn && window.isUserLoggedIn()) {
                                window.saveDesignPermanent && window.saveDesignPermanent(saved);
                            }
                        }
                    }
                    
                    // Rafra√Æchir les cr√©dits depuis Supabase
                    if (window.isUserLoggedIn && window.isUserLoggedIn() && window.refreshExportCredits) {
                        window.refreshExportCredits().then(credits => {
                            const isPro = localStorage.getItem('userProfile') === 'pro';
                            setExportLimitInfo({ 
                                canExport: isPro || credits > 0, 
                                remaining: isPro ? Infinity : credits, 
                                level: isPro ? 'pro' : 'free' 
                            });
                        });
                    }
                }, 1000);
                return () => clearTimeout(timer);
            }, []);
            
            // üõí STRIPE PAYMENT LINKS
            const STRIPE_LINKS = {
                payPerExport: 'https://buy.stripe.com/8x228rd9b071c8afE5gUM01', // 2,50‚Ç¨
                proUnlimited: 'https://buy.stripe.com/cN17sLg1n2f9fkmeA1gUM03'   // 19,99‚Ç¨/mois
            };
            
            // V√©rifier si l'utilisateur est Pro (abonn√©) ou UNLIMITED
            const isProUser = () => {
                const subscriptionType = localStorage.getItem('subscription_type');
                const isPro = localStorage.getItem('userProfile') === 'pro';
                const legacyPro = localStorage.getItem('gabaritkdp_pro') === 'true';
                
                // UNLIMITED = acc√®s total, PRO = acc√®s, ou ancien syst√®me
                return subscriptionType === 'unlimited' || subscriptionType === 'pro' || isPro || legacyPro;
            };
            
            useEffect(() => {
                if (dimensions && canvasRef.current) {
                    drawPreview();
                }
            }, [dimensions, drawPreview]);
            
            // üéÆ Gestion de l'auto-rotation 3D
            useEffect(() => {
                if (isAutoRotating) {
                    let lastTime = performance.now();
                    const animate = (time) => {
                        const delta = time - lastTime;
                        if (delta > 16) { // ~60fps cap
                            setRotationY(prev => (prev + 0.5) % 360);
                            lastTime = time;
                        }
                        animationRef.current = requestAnimationFrame(animate);
                    };
                    animationRef.current = requestAnimationFrame(animate);
                } else {
                    cancelAnimationFrame(animationRef.current);
                }
                return () => cancelAnimationFrame(animationRef.current);
            }, [isAutoRotating]);

            return (
                <div className="min-h-screen bg-gray-50">
                    {/* üíæ NOTIFICATION DE RESTAURATION */}

                    {/* üìö DESIGN LIBRARY MODAL */}
                    {designsModalOpen && (
                        <div style={{
                            position: 'fixed',
                            inset: 0,
                            background: 'rgba(0,0,0,0.65)',
                            zIndex: 9999,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            padding: '20px'
                        }}>
                            <div style={{
                                background: 'white',
                                borderRadius: '16px',
                                width: 'min(900px, 95vw)',
                                maxHeight: '85vh',
                                overflow: 'hidden',
                                boxShadow: '0 20px 60px rgba(0,0,0,0.25)',
                                display: 'flex',
                                flexDirection: 'column'
                            }}>
                                <div style={{
                                    padding: '16px 18px',
                                    borderBottom: '1px solid #e5e7eb',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'space-between',
                                    gap: '12px'
                                }}>
                                    <div style={{display:'flex', flexDirection:'column', gap:'2px'}}>
                                        <div style={{fontWeight: 800, fontSize: '16px', color:'#111827'}}>
                                            {language === 'fr' ? 'Mes designs' : 'My designs'}
                                        </div>
                                        <div style={{fontSize:'12px', color:'#6b7280'}}>
                                            {language === 'fr' ? 'Ouvrir, dupliquer ou supprimer un design.' : 'Open, duplicate, or delete a design.'}
                                        </div>
                                    </div>
                                    <div style={{display:'flex', gap:'8px', alignItems:'center'}}>
                                        <button
                                            onClick={() => { refreshDesignsList(); }}
                                            style={{
                                                padding: '8px 12px',
                                                borderRadius: '10px',
                                                border: '1px solid #e5e7eb',
                                                background: 'white',
                                                cursor: 'pointer',
                                                fontWeight: 700,
                                                fontSize: '12px'
                                            }}
                                            type="button"
                                        >
                                            üîÑ {language === 'fr' ? 'Rafra√Æchir' : 'Refresh'}
                                        </button>
                                        <button
                                            onClick={() => setDesignsModalOpen(false)}
                                            style={{
                                                padding: '8px 12px',
                                                borderRadius: '10px',
                                                border: '1px solid #e5e7eb',
                                                background: 'white',
                                                cursor: 'pointer',
                                                fontWeight: 700,
                                                fontSize: '12px'
                                            }}
                                            type="button"
                                        >
                                            ‚úï {language === 'fr' ? 'Fermer' : 'Close'}
                                        </button>
                                    </div>
                                </div>

                                <div style={{padding: '14px 18px', overflow:'auto'}}>
                                    {(!designsList || designsList.length === 0) ? (
                                        <div style={{padding:'28px 12px', textAlign:'center', color:'#6b7280'}}>
                                            {language === 'fr' ? 'Aucun design sauvegard√© pour le moment.' : 'No saved designs yet.'}
                                        </div>
                                    ) : (
                                        <div style={{display:'grid', gridTemplateColumns:'1fr', gap:'10px'}}>
                                            {designsList.map((d) => (
                                                <div 
                                                    key={d.id} 
                                                    onClick={() => openDesignById(d.id)}
                                                    style={{
                                                        border: '1px solid #e5e7eb',
                                                        borderRadius: '12px',
                                                        padding: '12px',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'space-between',
                                                        gap: '12px',
                                                        cursor: 'pointer',
                                                        transition: 'all 0.2s',
                                                        ':hover': {
                                                            borderColor: '#10b981',
                                                            boxShadow: '0 2px 8px rgba(16, 185, 129, 0.1)'
                                                        }
                                                    }}
                                                    onMouseEnter={(e) => {
                                                        e.currentTarget.style.borderColor = '#10b981';
                                                        e.currentTarget.style.boxShadow = '0 2px 8px rgba(16, 185, 129, 0.1)';
                                                    }}
                                                    onMouseLeave={(e) => {
                                                        e.currentTarget.style.borderColor = '#e5e7eb';
                                                        e.currentTarget.style.boxShadow = 'none';
                                                    }}
                                                >
                                                    {/* Miniature de l'image */}
                                                    {d.templateUrl && (
                                                        <div style={{
                                                            flexShrink: 0,
                                                            width: '80px',
                                                            height: '60px',
                                                            borderRadius: '8px',
                                                            overflow: 'hidden',
                                                            background: '#f3f4f6',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            justifyContent: 'center'
                                                        }}>
                                                            <img 
                                                                src={d.templateUrl} 
                                                                alt={d.title || 'Design'}
                                                                style={{
                                                                    width: '100%',
                                                                    height: '100%',
                                                                    objectFit: 'cover'
                                                                }}
                                                                onError={(e) => {
                                                                    e.target.style.display = 'none';
                                                                    e.target.parentElement.innerHTML = '<span style="font-size:24px">üñºÔ∏è</span>';
                                                                }}
                                                            />
                                                        </div>
                                                    )}
                                                    
                                                    <div style={{minWidth:0, flex: 1}}>
                                                        <div style={{fontWeight: 800, color:'#111827', fontSize:'14px', whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis'}}>
                                                            {d.title || (language === 'fr' ? 'Sans titre' : 'Untitled')}
                                                        </div>
                                                        <div style={{fontSize:'12px', color:'#6b7280'}}>
                                                            {(language === 'fr' ? 'Derni√®re utilisation' : 'Last used')}: {d.lastUsedAt ? new Date(d.lastUsedAt).toLocaleString() : (d.updatedAt ? new Date(d.updatedAt).toLocaleString() : '')}
                                                        </div>
                                                        <div style={{fontSize:'11px', color:'#9ca3af', whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis'}}>
                                                            {d.templateUrl ? d.templateUrl : (language === 'fr' ? 'Template: inconnu' : 'Template: unknown')}
                                                        </div>
                                                    </div>

                                                    <div style={{display:'flex', gap:'8px', flexWrap:'wrap', justifyContent:'flex-end'}}>
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                const rec = window.gkdpGetDesign ? window.gkdpGetDesign(d.id) : null;
                                                                if (!rec || !rec.designData) return;
                                                                const copyTitle = (rec.title || 'Design') + (language === 'fr' ? ' (copie)' : ' (copy)');
                                                                const created = window.gkdpUpsertDesign ? window.gkdpUpsertDesign({
                                                                    title: copyTitle,
                                                                    templateUrl: rec.templateUrl || null,
                                                                    designData: rec.designData,
                                                                    lastUsedAt: new Date().toISOString()
                                                                }) : null;
                                                                if (created) refreshDesignsList();
                                                            }}
                                                            style={{
                                                                padding: '8px 12px',
                                                                borderRadius: '10px',
                                                                border: '1px solid #e5e7eb',
                                                                background: 'white',
                                                                cursor: 'pointer',
                                                                fontWeight: 800,
                                                                fontSize: '12px'
                                                            }}
                                                            type="button"
                                                        >
                                                            üìÑ {language === 'fr' ? 'Dupliquer' : 'Duplicate'}
                                                        </button>

                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                const ok = confirm(language === 'fr' ? 'Supprimer ce design ?' : 'Delete this design?');
                                                                if (!ok) return;
                                                                window.gkdpDeleteDesign && window.gkdpDeleteDesign(d.id);
                                                                if (activeDesignId === d.id) {
                                                                    setActiveDesignId(null);
                                                                    localStorage.removeItem('gkdp_active_design_id');
                                                                }
                                                                refreshDesignsList();
                                                            }}
                                                            style={{
                                                                padding: '8px 12px',
                                                                borderRadius: '10px',
                                                                border: '1px solid #ef4444',
                                                                background: 'white',
                                                                color: '#ef4444',
                                                                cursor: 'pointer',
                                                                fontWeight: 900,
                                                                fontSize: '12px'
                                                            }}
                                                            type="button"
                                                        >
                                                            üóëÔ∏è {language === 'fr' ? 'Supprimer' : 'Delete'}
                                                        </button>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {designRestored && (
                        <div style={{
                            position: 'fixed',
                            bottom: '20px',
                            left: '50%',
                            transform: 'translateX(-50%)',
                            zIndex: 9999,
                            background: 'linear-gradient(135deg, #6366f1, #4f46e5)',
                            color: 'white',
                            padding: '14px 24px',
                            borderRadius: '12px',
                            boxShadow: '0 8px 25px rgba(99,102,241,0.4)',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '12px',
                            fontSize: '0.95rem',
                            fontWeight: '600'
                        }}>
                            <span style={{fontSize: '1.3rem'}}>üéâ</span>
                            <span>{language === 'fr' ? 'Votre design a √©t√© restaur√©! Cliquez sur EXPORTER pour t√©l√©charger.' : 'Your design has been restored! Click EXPORT to download.'}</span>
                            <button 
                                onClick={() => setDesignRestored(false)}
                                style={{
                                    background: 'rgba(255,255,255,0.2)',
                                    border: 'none',
                                    borderRadius: '6px',
                                    padding: '4px 10px',
                                    color: 'white',
                                    cursor: 'pointer',
                                    marginLeft: '8px'
                                }}
                            >OK</button>
                        </div>
                    )}
                    
                    {/* üõí MARKETPLACE PREVIEW BANNER */}
                    {/* Bandeau Mode Pr√©visualisation supprim√© - d√©plac√© sous le bouton EXPORT */}
                    
                    {/* üõí STRIPE PAYMENT MODAL - D√©sactiv√© pour beta testing
                    {showStripeModal && (
                        <div style={{
                            position: 'fixed',
                            inset: 0,
                            background: 'rgba(0,0,0,0.8)',
                            zIndex: 9999,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            padding: '20px'
                        }}>
                            <div style={{
                                background: 'white',
                                borderRadius: '20px',
                                padding: '32px',
                                maxWidth: '500px',
                                width: '100%',
                                textAlign: 'center',
                                boxShadow: '0 25px 50px rgba(0,0,0,0.3)'
                            }}>
                                <button 
                                    onClick={() => setShowStripeModal(false)}
                                    style={{
                                        position: 'absolute',
                                        top: '16px',
                                        right: '16px',
                                        background: 'none',
                                        border: 'none',
                                        fontSize: '1.5rem',
                                        cursor: 'pointer',
                                        color: '#666'
                                    }}
                                >‚úï</button>
                                
                                <div style={{fontSize: '4rem', marginBottom: '16px'}}>üí≥</div>
                                <h2 style={{fontSize: '1.75rem', fontWeight: '700', marginBottom: '8px', color: '#1e293b'}}>
                                    {language === 'fr' ? 'Exporter ce template' : 'Export this template'}
                                </h2>
                                <p style={{color: '#64748b', marginBottom: '24px'}}>
                                    {language === 'fr' 
                                        ? 'Choisissez votre option pour t√©l√©charger l\'image HD sans watermark'
                                        : 'Choose your option to download the HD image without watermark'}
                                </p>
                                
                                <div style={{display: 'flex', flexDirection: 'column', gap: '16px'}}>
                                    <button 
                                        onClick={() => handleStripePayment('payPerExport')}
                                        style={{
                                            padding: '20px',
                                            borderRadius: '12px',
                                            border: '2px solid #e2e8f0',
                                            background: 'white',
                                            cursor: 'pointer',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '16px',
                                            transition: 'all 0.3s'
                                        }}
                                        onMouseOver={(e) => {e.currentTarget.style.borderColor = '#FF9900'; e.currentTarget.style.transform = 'scale(1.02)'}}
                                        onMouseOut={(e) => {e.currentTarget.style.borderColor = '#e2e8f0'; e.currentTarget.style.transform = 'scale(1)'}}
                                    >
                                        <div style={{fontSize: '2rem'}}>üìÑ</div>
                                        <div style={{textAlign: 'left', flex: 1}}>
                                            <div style={{fontWeight: '700', fontSize: '1.1rem', color: '#1e293b'}}>
                                                {language === 'fr' ? 'Achat unique' : 'One-time purchase'}
                                            </div>
                                            <div style={{color: '#64748b', fontSize: '0.875rem'}}>
                                                {language === 'fr' ? 'Un seul export' : 'Single export'}
                                            </div>
                                        </div>
                                        <div style={{fontWeight: '800', fontSize: '1.5rem', color: '#FF9900'}}>2,50‚Ç¨</div>
                                    </button>
                                    
                                    <button 
                                        onClick={() => handleStripePayment('proUnlimited')}
                                        style={{
                                            padding: '20px',
                                            borderRadius: '12px',
                                            border: '2px solid #10b981',
                                            background: 'linear-gradient(135deg, #ecfdf5, #d1fae5)',
                                            cursor: 'pointer',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '16px',
                                            transition: 'all 0.3s',
                                            position: 'relative'
                                        }}
                                        onMouseOver={(e) => {e.currentTarget.style.transform = 'scale(1.02)'}}
                                        onMouseOut={(e) => {e.currentTarget.style.transform = 'scale(1)'}}
                                    >
                                        <span style={{
                                            position: 'absolute',
                                            top: '-10px',
                                            right: '16px',
                                            background: '#10b981',
                                            color: 'white',
                                            padding: '4px 10px',
                                            borderRadius: '6px',
                                            fontSize: '0.7rem',
                                            fontWeight: '700'
                                        }}>BEST VALUE</span>
                                        <div style={{fontSize: '2rem'}}>‚≠ê</div>
                                        <div style={{textAlign: 'left', flex: 1}}>
                                            <div style={{fontWeight: '700', fontSize: '1.1rem', color: '#1e293b'}}>
                                                Pro Unlimited
                                            </div>
                                            <div style={{color: '#64748b', fontSize: '0.875rem'}}>
                                                {language === 'fr' ? 'Exports illimit√©s / mois' : 'Unlimited exports / month'}
                                            </div>
                                        </div>
                                        <div style={{fontWeight: '800', fontSize: '1.5rem', color: '#10b981'}}>19,99‚Ç¨<span style={{fontSize: '0.875rem', fontWeight: '500'}}>/mo</span></div>
                                    </button>
                                </div>
                                
                                <p style={{marginTop: '20px', fontSize: '0.8rem', color: '#94a3b8'}}>
                                    <i className="fas fa-lock" style={{marginRight: '6px'}}></i>
                                    {language === 'fr' ? 'Paiement s√©curis√© par Stripe' : 'Secure payment by Stripe'}
                                </p>
                            </div>
                        </div>
                    )}
                    FIN MODAL STRIPE */}
                    
                    <div className="generator-layout">
                        <div className="sidebar">
                             <div className="sidebar-section">
                                <h2 className="sidebar-title">
                                    <i className="fas fa-book-open text-blue-500"></i>
                                    {t('howToTitle')}
                                </h2>
                                <div className="space-y-3 text-sm text-gray-700 bg-gradient-to-br from-blue-50 to-green-50 p-4 rounded-lg border border-blue-200">
                                    <p className="font-medium text-gray-800">{t('howToStep1')}</p>
                                    
                                    <div>
                                        <p className="font-medium text-gray-800 mb-1">{t('howToStep2')}</p>
                                        <p className="text-xs text-blue-600 mt-1">
                                            {t('howToStep2Tip')} {' '}
                                            <a 
                                                href="https://gabaritkdp.com/generator-magic.html" 
                                                target="_blank" 
                                                rel="noopener noreferrer"
                                                className="underline font-semibold hover:text-blue-800"
                                            >
                                                {t('howToStep2Link')}
                                            </a>
                                        </p>
                                    </div>
                                    
                                    <div>
                                        <p className="font-medium text-gray-800 mb-1">{t('howToStep3')}</p>
                                        <p className="text-xs text-amber-700 bg-amber-50 p-2 rounded border border-amber-200 mt-1">
                                            {t('howToStep3Tip')}
                                        </p>
                                    </div>
                                    
                                    <p className="font-medium text-gray-800">{t('howToStep4')}</p>
                                </div>
                            </div>

                            <div className="sidebar-section">
                                <h2 className="sidebar-title">
                                    <i className="fas fa-cog text-gray-500"></i>
                                    {t('bookSettings')}
                                </h2>

                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">{t('bindingType')}</label>
                                        <select
                                            value={bindingType}
                                            onChange={(e) => setBindingType(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                        >
                                            <option value="paperback">{t('paperback')}</option>
                                            <option value="hardcover">{t('hardcover')}</option>
                                        </select>
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">{t('kdpFormat')}</label>
                                        <select
                                            value={format}
                                            onChange={(e) => setFormat(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                        >
                                            <option value="">{t('selectFormat')}</option>

                                            {bindingType === 'paperback' && (
                                                <optgroup label={`${t('popularSizes')}`}>
                                                    {Object.entries(kdpFormats)
                                                        .filter(([key, data]) => data.binding.includes(bindingType) && data.popular)
                                                        .map(([key, data]) => (
                                                            <option key={key} value={key}>{data.name}</option>
                                                        ))}
                                                </optgroup>
                                            )}

                                            <optgroup label={`${bindingType === 'paperback' ? t('otherSizes') : t('hardcoverFormats')}`}>
                                                {Object.entries(kdpFormats)
                                                    .filter(([key, data]) => data.binding.includes(bindingType) && !data.popular)
                                                    .map(([key, data]) => (
                                                        <option key={key} value={key}>{data.name}</option>
                                                    ))}
                                            </optgroup>
                                        </select>

                                        {format === '8.5x11' &&
                                            (
                                                <div className="format-alert-critical">
                                                    <div className="alert-title">
                                                        {t('format8511Warning')}
                                                    </div>
                                                    <div className="alert-content">
                                                        {t('format8511Message')}
                                                        <br /><br />
                                                        <strong>{t('format8511Tips')}</strong>
                                                    </div>
                                                </div>
                                            )}
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">{t('pageCount')}</label>
                                        <input
                                            type="number"
                                            value={pageCount}
                                            onChange={(e) => setPageCountDebounced(parseInt(e.target.value) || 0)}
                                            min={bindingType === 'hardcover' ? 75 : 24}
                                            max={bindingType === 'hardcover' ? 550 : 828}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                        />
                                    </div>

                                    <div>
                                        <label className="flex items-center space-x-2">
                                            <input
                                                type="checkbox"
                                                checked={hasBleed}
                                                onChange={(e) => setHasBleed(e.target.checked)}
                                                className="rounded"
                                            />
                                            <span className="text-sm">{t('bleed')}</span>
                                        </label>
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">{t('paperType')}</label>
                                        <select
                                            value={paperType}
                                            onChange={(e) => setPaperType(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                        >
                                            {paperOptions[bindingType].map(option => (
                                                <option key={option.value} value={option.value}>
                                                    {language === 'fr' ? option.labelFr : option.labelEn}
                                                </option>
                                            ))}
                                        </select>
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">{t('coverFinish')}</label>
                                        <select
                                            value={coverFinish}
                                            onChange={(e) => setCoverFinish(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                        >
                                            {coverFinishOptions.map(option => (
                                                <option key={option.value} value={option.value}>
                                                    {option.label}
                                                </option>
                                            ))}
                                        </select>
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">{t('spineText')}</label>
                                        <input
                                            type="text"
                                            value={spineText}
                                            onChange={(e) => setSpineText(e.target.value)}
                                            placeholder={bindingType === 'hardcover' ? t('spineTextAuto') : dimensions && dimensions.spine < 1.5 ? t('spineTextThin') : t('spineTextHelp')}
                                            disabled={bindingType === 'hardcover' || (dimensions && dimensions.spine < 1.5)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 disabled:bg-gray-100"
                                        />

                                        {spineText && bindingType === 'paperback' && dimensions && dimensions.spine > 1.5 && (
                                            <div className="mt-4 p-4 bg-gray-50 rounded-lg space-y-3">
                                                <h4 className="font-medium text-gray-700">Spine text options</h4>

                                                <div className="grid grid-cols-1 gap-3">
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700 mb-1">{t('spineTextFont')}</label>
                                                        <select
                                                            value={spineTextFont}
                                                            onChange={(e) => setSpineTextFont(e.target.value)}
                                                            className="w-full p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 text-sm"
                                                        >
                                                            <option value="Arial">Arial</option>
                                                            <option value="Georgia">Georgia</option>
                                                            <option value="Times New Roman">Times New Roman</option>
                                                            <option value="Helvetica">Helvetica</option>
                                                            <option value="Verdana">Verdana</option>
                                                            <option value="Impact">Impact</option>
                                                        </select>
                                                    </div>

                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700 mb-1">{t('spineTextSize')}</label>
                                                        <input
                                                            type="range"
                                                            min="8"
                                                            max="300"
                                                            value={spineTextSize}
                                                            onChange={(e) => setSpineTextSize(parseInt(e.target.value))}
                                                            className="w-full"
                                                        />
                                                        <div className="text-xs text-gray-500 text-center">{spineTextSize}px</div>
                                                    </div>

                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700 mb-1">{t('spineTextColor')}</label>
                                                        <div className="flex items-center space-x-3">
                                                            <input
                                                                type="color"
                                                                value={spineTextColor}
                                                                onChange={(e) => setSpineTextColor(e.target.value)}
                                                                className="w-12 h-8 border border-gray-300 rounded cursor-pointer"
                                                            />
                                                            <span className="text-sm text-gray-600">{spineTextColor}</span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        )}
                                    </div>

                                    {/* üìö COVER TEXT SECTION - Titre et Auteur */}
                                    <div className="mt-6 p-4 bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg border border-purple-200">
                                        <h3 className="font-bold text-purple-800 mb-4">
                                            {t('coverTextSection')}
                                        </h3>
                                        
                                        {/* Instruction drag & drop */}
                                        <div className="mb-4 p-2 bg-purple-100 rounded text-sm text-purple-700 flex items-center gap-2">
                                            <span>üñ±Ô∏è</span>
                                            {language === 'fr' 
                                                ? 'Glissez le texte directement sur le canvas pour le repositionner !' 
                                                : 'Drag text directly on the canvas to reposition it!'}
                                        </div>
                                        
                                        {/* Titre du livre */}
                                        <div className="mb-4">
                                            <label className="block text-sm font-medium text-gray-700 mb-2">{t('bookTitle')}</label>
                                            <input
                                                type="text"
                                                value={bookTitle}
                                                onChange={(e) => setBookTitle(e.target.value)}
                                                placeholder={t('bookTitlePlaceholder')}
                                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500"
                                            />
                                            
                                            {bookTitle && (
                                                <div className="mt-3 space-y-3">
                                                    {/* Police avec aper√ßu */}
                                                    <FontSelect 
                                                        value={bookTitleFont}
                                                        onChange={setBookTitleFont}
                                                        fonts={FONT_LIST}
                                                        label={t('bookTitleFont')}
                                                    />
                                                    
                                                    <div className="grid grid-cols-2 gap-3">
                                                        <div>
                                                            <label className="block text-xs font-medium text-gray-600 mb-1">{t('bookTitleSize')}: {bookTitleSize}px</label>
                                                            <input
                                                                type="range"
                                                                min="24"
                                                                max="300"
                                                                value={bookTitleSize}
                                                                onChange={(e) => setBookTitleSize(parseInt(e.target.value))}
                                                                className="w-full"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="block text-xs font-medium text-gray-600 mb-1">{t('bookTitleColor')}</label>
                                                            <input
                                                                type="color"
                                                                value={bookTitleColor}
                                                                onChange={(e) => setBookTitleColor(e.target.value)}
                                                                className="w-full h-8 border border-gray-300 rounded cursor-pointer"
                                                            />
                                                        </div>
                                                    </div>
                                                    
                                                    {/* Positions X et Y */}
                                                    <div className="p-2 bg-gray-50 rounded text-xs text-gray-500">
                                                        üìç Position: X={Math.round(bookTitleX)}% Y={Math.round(bookTitleY)}%
                                                        <span className="ml-2 text-purple-600">(drag on canvas)</span>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                        
                                        {/* Nom de l'auteur */}
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700 mb-2">{t('authorName')}</label>
                                            <input
                                                type="text"
                                                value={authorName}
                                                onChange={(e) => setAuthorName(e.target.value)}
                                                placeholder={t('authorNamePlaceholder')}
                                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500"
                                            />
                                            
                                            {authorName && (
                                                <div className="mt-3 space-y-3">
                                                    {/* Police avec aper√ßu */}
                                                    <FontSelect 
                                                        value={authorNameFont}
                                                        onChange={setAuthorNameFont}
                                                        fonts={FONT_LIST}
                                                        label={language === 'fr' ? 'Police' : 'Font'}
                                                    />
                                                    
                                                    <div className="grid grid-cols-2 gap-3">
                                                        <div>
                                                            <label className="block text-xs font-medium text-gray-600 mb-1">{t('authorNameSize')}: {authorNameSize}px</label>
                                                            <input
                                                                type="range"
                                                                min="12"
                                                                max="300"
                                                                value={authorNameSize}
                                                                onChange={(e) => setAuthorNameSize(parseInt(e.target.value))}
                                                                className="w-full"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="block text-xs font-medium text-gray-600 mb-1">{t('authorNameColor')}</label>
                                                            <input
                                                                type="color"
                                                                value={authorNameColor}
                                                                onChange={(e) => setAuthorNameColor(e.target.value)}
                                                                className="w-full h-8 border border-gray-300 rounded cursor-pointer"
                                                            />
                                                        </div>
                                                    </div>
                                                    
                                                    {/* Positions X et Y */}
                                                    <div className="p-2 bg-gray-50 rounded text-xs text-gray-500">
                                                        üìç Position: X={Math.round(authorNameX)}% Y={Math.round(authorNameY)}%
                                                        <span className="ml-2 text-purple-600">(drag on canvas)</span>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </div>

                                    {/* üìñ BACK COVER SECTION - 4√®me de couverture */}
                                    <div className="mt-6 p-4 bg-gradient-to-r from-amber-50 to-orange-50 rounded-lg border border-amber-200">
                                        <h3 className="font-bold text-amber-800 mb-4">
                                            {t('backCoverSection')}
                                        </h3>
                                        
                                        {/* üé® FOND DE LA 4√àME DE COUVERTURE */}
                                        <div className="mb-6 p-4 bg-white rounded-lg border border-amber-200">
                                            <h4 className="font-medium text-amber-700 mb-3">
                                                {t('backCoverBgSection')}
                                            </h4>
                                            
                                            {/* S√©lecteur de zone - Style Coverjig */}
                                            <div className="mb-4">
                                                <label className="block text-xs font-medium text-gray-600 mb-2">
                                                    {language === 'fr' ? 'Appliquer √† :' : 'Apply to:'}
                                                </label>
                                                <div className="grid grid-cols-4 gap-1">
                                                    {/* None */}
                                                    <button
                                                        onClick={() => setBackgroundApplyTo('none')}
                                                        className={`p-2 rounded border-2 text-center transition-all ${backgroundApplyTo === 'none' ? 'border-amber-500 bg-amber-50' : 'border-gray-200 hover:border-gray-300'}`}
                                                    >
                                                        <div className="flex justify-center gap-px mb-1">
                                                            <div className="w-3 h-5 border border-gray-300 rounded-sm"></div>
                                                            <div className="w-1 h-5 border border-gray-300"></div>
                                                            <div className="w-3 h-5 border border-gray-300 rounded-sm"></div>
                                                        </div>
                                                        <span className="text-xs">{language === 'fr' ? 'Non' : 'None'}</span>
                                                    </button>
                                                    
                                                    {/* Full Cover */}
                                                    <button
                                                        onClick={() => setBackgroundApplyTo('full')}
                                                        className={`p-2 rounded border-2 text-center transition-all ${backgroundApplyTo === 'full' ? 'border-amber-500 bg-amber-50' : 'border-gray-200 hover:border-gray-300'}`}
                                                    >
                                                        <div className="flex justify-center gap-0 mb-1">
                                                            <div className="w-3 h-5 bg-amber-400 rounded-l-sm"></div>
                                                            <div className="w-1 h-5 bg-amber-400"></div>
                                                            <div className="w-3 h-5 bg-amber-400 rounded-r-sm"></div>
                                                        </div>
                                                        <span className="text-xs">Full</span>
                                                    </button>
                                                    
                                                    {/* Back Only */}
                                                    <button
                                                        onClick={() => setBackgroundApplyTo('back')}
                                                        className={`p-2 rounded border-2 text-center transition-all ${backgroundApplyTo === 'back' ? 'border-amber-500 bg-amber-50' : 'border-gray-200 hover:border-gray-300'}`}
                                                    >
                                                        <div className="flex justify-center gap-px mb-1">
                                                            <div className="w-3 h-5 bg-amber-400 rounded-sm"></div>
                                                            <div className="w-1 h-5 border border-gray-300"></div>
                                                            <div className="w-3 h-5 border border-gray-300 rounded-sm"></div>
                                                        </div>
                                                        <span className="text-xs">Back</span>
                                                    </button>
                                                    
                                                    {/* Front Only */}
                                                    <button
                                                        onClick={() => setBackgroundApplyTo('front')}
                                                        className={`p-2 rounded border-2 text-center transition-all ${backgroundApplyTo === 'front' ? 'border-amber-500 bg-amber-50' : 'border-gray-200 hover:border-gray-300'}`}
                                                    >
                                                        <div className="flex justify-center gap-px mb-1">
                                                            <div className="w-3 h-5 border border-gray-300 rounded-sm"></div>
                                                            <div className="w-1 h-5 border border-gray-300"></div>
                                                            <div className="w-3 h-5 bg-amber-400 rounded-sm"></div>
                                                        </div>
                                                        <span className="text-xs">Front</span>
                                                    </button>
                                                </div>
                                            </div>
                                            
                                            {backgroundApplyTo !== 'none' && (
                                                <div className="space-y-4">
                                                    {/* Couleur de fond - Grille de couleurs */}
                                                    <div>
                                                        <label className="block text-xs font-medium text-gray-600 mb-2">{t('backCoverBgColorLabel')}</label>
                                                        <div className="flex items-center gap-2 mb-2">
                                                            <input
                                                                type="color"
                                                                value={backCoverBgColor}
                                                                onChange={(e) => setBackCoverBgColor(e.target.value)}
                                                                className="w-10 h-8 border border-gray-300 rounded cursor-pointer"
                                                            />
                                                            <span className="text-xs text-gray-500">{backCoverBgColor}</span>
                                                        </div>
                                                        
                                                        {/* Grille de couleurs pr√©d√©finies */}
                                                        <div className="grid grid-cols-10 gap-1">
                                                            {[
                                                                // Blancs et gris
                                                                '#ffffff', '#f8f9fa', '#e9ecef', '#dee2e6', '#ced4da', '#adb5bd', '#6c757d', '#495057', '#343a40', '#212529',
                                                                // Noirs et bruns
                                                                '#000000', '#1a1a1a', '#2d2d2d', '#3d3d3d', '#4a4a4a', '#8b4513', '#a0522d', '#cd853f', '#d2691e', '#deb887',
                                                                // Bleus
                                                                '#0d6efd', '#0dcaf0', '#6610f2', '#6f42c1', '#1e3a5f', '#2c3e50', '#34495e', '#1abc9c', '#16a085', '#17a2b8',
                                                                // Verts
                                                                '#198754', '#20c997', '#2d4a3e', '#27ae60', '#2ecc71', '#1d8348', '#145a32', '#0b5345', '#117a65', '#148f77',
                                                                // Rouges et oranges
                                                                '#dc3545', '#fd7e14', '#ffc107', '#e74c3c', '#c0392b', '#922b21', '#641e16', '#f39c12', '#d68910', '#b9770e',
                                                                // Roses et violets
                                                                '#d63384', '#e83e8c', '#9b59b6', '#8e44ad', '#7d3c98', '#6c3483', '#5b2c6f', '#4a235a', '#f1948a', '#d7bde2'
                                                            ].map(color => (
                                                                <button
                                                                    key={color}
                                                                    onClick={() => setBackCoverBgColor(color)}
                                                                    className={`w-6 h-6 rounded border-2 transition-transform hover:scale-110 ${backCoverBgColor === color ? 'border-amber-500 ring-2 ring-amber-300' : 'border-gray-200'}`}
                                                                    style={{ backgroundColor: color }}
                                                                    title={color}
                                                                />
                                                            ))}
                                                        </div>
                                                    </div>
                                                    
                                                    {/* Textures avec filtres */}
                                                    <div>
                                                        <label className="block text-xs font-medium text-gray-600 mb-2">{t('backCoverTextureLabel')}</label>
                                                        
                                                        {/* Filtres de cat√©gorie */}
                                                        <div className="flex flex-wrap gap-1 mb-3">
                                                            {TEXTURE_CATEGORIES.map(cat => (
                                                                <button
                                                                    key={cat.id}
                                                                    onClick={() => setTextureCategory(cat.id)}
                                                                    className={`px-2 py-1 text-xs rounded-full transition-colors ${
                                                                        textureCategory === cat.id 
                                                                            ? 'bg-amber-500 text-white' 
                                                                            : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                                                                    }`}
                                                                >
                                                                    {language === 'fr' ? cat.label : cat.labelEn}
                                                                </button>
                                                            ))}
                                                        </div>
                                                        
                                                        {/* Grille de textures filtr√©es */}
                                                        <div className="grid grid-cols-5 gap-2 max-h-64 overflow-y-auto p-1">
                                                            {/* Aucune texture */}
                                                            {textureCategory === 'all' && (
                                                                <button
                                                                    onClick={() => setBackCoverTexture(null)}
                                                                    className={`h-14 rounded border-2 flex items-center justify-center text-xs ${!backCoverTexture ? 'border-amber-500 bg-amber-50' : 'border-gray-200 hover:border-gray-300'}`}
                                                                    title={language === 'fr' ? 'Aucune' : 'None'}
                                                                >
                                                                    ‚àÖ
                                                                </button>
                                                            )}
                                                            
                                                            {/* Textures filtr√©es par cat√©gorie */}
                                                            {TEXTURE_LIST
                                                                .filter(texture => textureCategory === 'all' || texture.category === textureCategory)
                                                                .map(texture => {
                                                                    const previewCanvas = generateTexture(texture.name, 60, 50);
                                                                    const previewUrl = previewCanvas.toDataURL();
                                                                    
                                                                    return (
                                                                        <button
                                                                            key={texture.name}
                                                                            onClick={() => setBackCoverTexture({ 
                                                                                url: null, 
                                                                                name: texture.name 
                                                                            })}
                                                                            className={`h-14 rounded border-2 overflow-hidden transition-transform hover:scale-105 ${backCoverTexture?.name === texture.name ? 'border-amber-500 ring-2 ring-amber-300' : 'border-gray-200'}`}
                                                                            title={texture.title}
                                                                        >
                                                                            <img 
                                                                                src={previewUrl} 
                                                                                alt={texture.title}
                                                                                className="w-full h-full object-cover"
                                                                            />
                                                                        </button>
                                                                    );
                                                                })
                                                            }
                                                        </div>
                                                        
                                                        {/* Nom de la texture s√©lectionn√©e */}
                                                        {backCoverTexture?.name && backCoverTexture.name !== 'custom' && (
                                                            <div className="mt-2 text-xs text-amber-600 font-medium">
                                                                ‚úì {TEXTURE_LIST.find(t => t.name === backCoverTexture.name)?.title || backCoverTexture.name}
                                                            </div>
                                                        )}
                                                        
                                                        {/* üé® FILTRE DE COULEUR */}
                                                        {backCoverTexture?.name && backCoverTexture.name !== 'custom' && (
                                                            <div className="mt-3 pt-3 border-t border-gray-200">
                                                                <label className="block text-xs font-medium text-gray-600 mb-2">
                                                                    üé® {language === 'fr' ? 'Filtre de couleur' : 'Color Filter'}
                                                                </label>
                                                                <div className="flex flex-wrap gap-1">
                                                                    {/* Pas de filtre */}
                                                                    <button
                                                                        onClick={() => setTextureColorFilter(null)}
                                                                        className={`w-6 h-6 rounded border-2 flex items-center justify-center text-xs ${!textureColorFilter ? 'border-amber-500 ring-1 ring-amber-300' : 'border-gray-300'}`}
                                                                        title={language === 'fr' ? 'Aucun filtre' : 'No filter'}
                                                                    >
                                                                        ‚àÖ
                                                                    </button>
                                                                    {/* Palette de couleurs pour le filtre */}
                                                                    {[
                                                                        // Rouges/Oranges
                                                                        '#ff6b6b', '#ff8c42', '#ffa502', '#ff7f50', '#e74c3c', '#c0392b',
                                                                        // Jaunes
                                                                        '#ffd93d', '#f1c40f', '#ffeaa7', '#fdcb6e',
                                                                        // Verts
                                                                        '#6bcb77', '#1dd1a1', '#00b894', '#27ae60', '#2ecc71', '#16a085',
                                                                        // Bleus/Cyans
                                                                        '#74b9ff', '#0984e3', '#00cec9', '#48dbfb', '#45aaf2', '#3498db', '#2980b9',
                                                                        // Violets/Roses
                                                                        '#a29bfe', '#6c5ce7', '#fd79a8', '#e84393', '#9b59b6', '#8e44ad',
                                                                        // Neutres
                                                                        '#dfe6e9', '#b2bec3', '#636e72', '#2d3436',
                                                                    ].map(color => (
                                                                        <button
                                                                            key={color}
                                                                            onClick={() => setTextureColorFilter(color)}
                                                                            className={`w-6 h-6 rounded border-2 transition-transform hover:scale-110 ${textureColorFilter === color ? 'border-amber-500 ring-1 ring-amber-300' : 'border-gray-200'}`}
                                                                            style={{ backgroundColor: color }}
                                                                            title={color}
                                                                        />
                                                                    ))}
                                                                </div>
                                                                {textureColorFilter && (
                                                                    <div className="mt-1 text-xs text-gray-500">
                                                                        {language === 'fr' ? 'Filtre actif:' : 'Active filter:'} {textureColorFilter}
                                                                    </div>
                                                                )}
                                                            </div>
                                                        )}
                                                        
                                                        {/* Upload personnalis√© */}
                                                        <div className="mt-3 pt-3 border-t border-gray-200">
                                                            <label className="flex items-center gap-2 text-xs text-gray-500 cursor-pointer hover:text-amber-600">
                                                                <span>üìÅ</span>
                                                                <span>{language === 'fr' ? 'Ou importer votre propre image...' : 'Or upload your own image...'}</span>
                                                                <input
                                                                    type="file"
                                                                    accept="image/*"
                                                                    className="hidden"
                                                                    onChange={(e) => {
                                                                        const file = e.target.files[0];
                                                                        if (file) {
                                                                            const reader = new FileReader();
                                                                            reader.onload = (event) => {
                                                                                setBackCoverTexture({
                                                                                    url: event.target.result,
                                                                                    name: 'custom'
                                                                                });
                                                                            };
                                                                            reader.readAsDataURL(file);
                                                                        }
                                                                    }}
                                                                />
                                                            </label>
                                                            
                                                            {/* Aper√ßu si image custom */}
                                                            {backCoverTexture?.name === 'custom' && backCoverTexture?.url && (
                                                                <div className="mt-2 relative inline-block">
                                                                    <img 
                                                                        src={backCoverTexture.url} 
                                                                        alt="Custom" 
                                                                        className="h-14 w-24 object-cover rounded border-2 border-amber-500"
                                                                    />
                                                                    <button
                                                                        onClick={() => setBackCoverTexture(null)}
                                                                        className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs hover:bg-red-600 shadow"
                                                                    >
                                                                        √ó
                                                                    </button>
                                                                </div>
                                                            )}
                                                        </div>
                                                    </div>
                                                    
                                                    <p className="text-xs text-gray-500 italic">
                                                        üí° {t('backCoverBgTip')}
                                                    </p>
                                                </div>
                                            )}
                                        </div>
                                        
                                        <div className="mb-4">
                                            <label className="block text-sm font-medium text-gray-700 mb-2">{t('backCoverText')}</label>
                                            <textarea
                                                value={backCoverText}
                                                onChange={(e) => setBackCoverText(e.target.value)}
                                                placeholder={t('backCoverTextPlaceholder')}
                                                rows={4}
                                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500 resize-none"
                                            />
                                            
                                            {backCoverText && (
                                                <div className="mt-3 space-y-3">
                                                    {/* Police avec aper√ßu */}
                                                    <FontSelect 
                                                        value={backCoverTextFont}
                                                        onChange={setBackCoverTextFont}
                                                        fonts={FONT_LIST}
                                                        label={language === 'fr' ? 'Police du texte' : 'Text Font'}
                                                    />
                                                    
                                                    <div className="grid grid-cols-2 gap-3">
                                                        <div>
                                                            <label className="block text-xs font-medium text-gray-600 mb-1">{t('backCoverTextSize')}: {backCoverTextSize}px</label>
                                                            <input
                                                                type="range"
                                                                min="10"
                                                                max="300"
                                                                value={backCoverTextSize}
                                                                onChange={(e) => setBackCoverTextSize(parseInt(e.target.value))}
                                                                className="w-full"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="block text-xs font-medium text-gray-600 mb-1">{t('backCoverTextColor')}</label>
                                                            <input
                                                                type="color"
                                                                value={backCoverTextColor}
                                                                onChange={(e) => setBackCoverTextColor(e.target.value)}
                                                                className="w-full h-8 border border-gray-300 rounded cursor-pointer"
                                                            />
                                                        </div>
                                                    </div>
                                                    
                                                    {/* Positions X et Y */}
                                                    <div className="p-2 bg-gray-50 rounded text-xs text-gray-500">
                                                        üìç Position: X={Math.round(backCoverTextX)}% Y={Math.round(backCoverTextY)}%
                                                        <span className="ml-2 text-amber-600">(drag on canvas)</span>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                        
                                        {/* Zone code-barre ISBN */}
                                        <div className="pt-4 border-t border-amber-200">
                                            <h4 className="font-medium text-amber-700 mb-3">
                                                {t('barcodeSection')}
                                            </h4>
                                            <div className="flex items-center justify-between">
                                                <label className="flex items-center gap-2 text-sm text-gray-700">
                                                    <input
                                                        type="checkbox"
                                                        checked={showBarcodeZone}
                                                        onChange={(e) => setShowBarcodeZone(e.target.checked)}
                                                        className="w-4 h-4 rounded border-gray-300 text-amber-600 focus:ring-amber-500"
                                                    />
                                                    {t('showBarcodeZone')}
                                                </label>
                                                {showBarcodeZone && (
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-xs text-gray-600">{t('barcodeZoneColor')}:</span>
                                                        <input
                                                            type="color"
                                                            value={barcodeZoneColor}
                                                            onChange={(e) => setBarcodeZoneColor(e.target.value)}
                                                            className="w-8 h-6 border border-gray-300 rounded cursor-pointer"
                                                        />
                                                    </div>
                                                )}
                                            </div>
                                            <p className="text-xs text-gray-500 mt-2">{t('barcodeZoneHelp')}</p>
                                        </div>
                                    </div>

                                    {dimensions && (
                                        <div className="bg-blue-50 p-4 rounded-lg">
                                            <h3 className="font-medium text-blue-900 mb-2">{t('calculatedDimensions')}</h3>
                                            <div className="text-sm text-blue-800 space-y-1">
                                                <div><strong>{t('totalWidth')}: {Math.round(dimensions.total.width * 10) / 10} mm</strong></div>
                                                <div><strong>{t('totalHeight')}: {Math.round(dimensions.total.height * 10) / 10} mm</strong></div>
                                                {dimensions.bindingType === 'paperback' && (
                                                    <div>
                                                        {t('spineThickness')}: {Math.round(dimensions.spine * 10) / 10} mm
                                                        {dimensions.spine < 1.5 && (
                                                            <span className="text-orange-600 ml-2">{t('thinSpine')}</span>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    )}

                                    {/* üé® CANVA DIMENSIONS SECTION */}
                                    {dimensions && (
                                        <div className="bg-gradient-to-r from-purple-50 to-pink-50 p-4 rounded-lg border-2 border-purple-200">
                                            <h3 className="font-bold text-purple-900 mb-3 flex items-center gap-2">
                                                <span>üé®</span> {t('canvaDimensions')}
                                            </h3>
                                            
                                            {/* Dimensions en POUCES - IMPORTANT */}
                                            <div className="bg-white p-3 rounded-lg mb-3 border border-purple-300">
                                                <div className="text-xs text-purple-600 font-medium mb-1">{t('canvaInches')}</div>
                                                <div className="text-2xl font-bold text-purple-900">
                                                    {(dimensions.total.width / 25.4).toFixed(3)}" √ó {(dimensions.total.height / 25.4).toFixed(3)}"
                                                </div>
                                                <div className="text-xs text-gray-500 mt-1">
                                                    {t('canvaInstructions')}
                                                </div>
                                            </div>

                                            {/* Bouton Copier */}
                                            <button
                                                onClick={() => {
                                                    const widthInches = (dimensions.total.width / 25.4).toFixed(3);
                                                    const heightInches = (dimensions.total.height / 25.4).toFixed(3);
                                                    const textToCopy = `${widthInches} x ${heightInches} in`;
                                                    navigator.clipboard.writeText(textToCopy).then(() => {
                                                        const btn = document.getElementById('canva-copy-btn');
                                                        const originalText = btn.innerText;
                                                        btn.innerText = t('copiedToClipboard');
                                                        btn.classList.add('bg-green-500');
                                                        btn.classList.remove('bg-purple-600');
                                                        setTimeout(() => {
                                                            btn.innerText = originalText;
                                                            btn.classList.remove('bg-green-500');
                                                            btn.classList.add('bg-purple-600');
                                                        }, 2000);
                                                    });
                                                }}
                                                id="canva-copy-btn"
                                                className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-all flex items-center justify-center gap-2"
                                            >
                                                {t('copyForCanva')}
                                            </button>

                                            {/* Alternative en mm */}
                                            <div className="mt-3 text-xs text-gray-500">
                                                <span className="font-medium">{t('canvaMM')}:</span> {Math.round(dimensions.total.width * 10) / 10} √ó {Math.round(dimensions.total.height * 10) / 10} mm
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>

                            <div className="sidebar-section">
                                <h2 className="sidebar-title">
                                    <i className="fas fa-image text-gray-500"></i>
                                    {t('images')}
                                </h2>

                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">{t('frontImage')}</label>
                                        <input
                                            type="file"
                                            accept="image/*"
                                            onChange={(e) => handleImageUpload(e.target.files[0], 'front')}
                                            className="hidden"
                                            id="front-image-input"
                                        />
                                        <button
                                            onClick={() => document.getElementById('front-image-input').click()}
                                            className="w-full p-3 border-2 border-dashed border-gray-300 rounded-lg text-sm text-gray-600 hover:border-blue-500 hover:text-blue-600 transition-all"
                                        >
                                            {language === 'fr' ? 'Choisir une image' : 'Choose image'}
                                        </button>
                                        {window.CanvaAuth && window.CanvaAuth.isAuthenticated() && window.CanvaDesignPicker && (
                                            <CanvaDesignPicker 
                                                onSelectImage={handleImageUpload} 
                                                imageType="front"
                                                language={language}
                                            />
                                        )}
                                        {frontImage && (
                                            <div className="mt-2 p-3 bg-gray-50 rounded-lg">
                                                <img src={frontImage.url} alt="Face" className="w-full h-16 object-cover rounded mb-2" />
                                                <div className="flex items-center justify-between text-xs text-gray-600 mb-2">
                                                    <span>{frontImage.naturalWidth}√ó{frontImage.naturalHeight}px</span>
                                                    <span className="px-2 py-1 bg-green-100 text-green-800 rounded">
                                                        {frontImage.quality}
                                                    </span>
                                                </div>
                                                <p className="text-xs text-gray-500 mb-2 text-center">
                                                    {language === 'fr' ? 'üñ±Ô∏è Cliquez sur l\'aper√ßu pour ajuster' : 'üñ±Ô∏è Click preview to adjust'}
                                                </p>
                                                <button
                                                    onClick={() => removeImage('front')}
                                                    className="w-full bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600"
                                                >
                                                    {t('removeImage')}
                                                </button>
                                            </div>
                                        )}
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">{t('backImage')}</label>
                                        <input
                                            type="file"
                                            accept="image/*"
                                            onChange={(e) => handleImageUpload(e.target.files[0], 'back')}
                                            className="hidden"
                                            id="back-image-input"
                                        />
                                        <button
                                            onClick={() => document.getElementById('back-image-input').click()}
                                            className="w-full p-3 border-2 border-dashed border-gray-300 rounded-lg text-sm text-gray-600 hover:border-blue-500 hover:text-blue-600 transition-all"
                                        >
                                            {language === 'fr' ? 'Choisir une image' : 'Choose image'}
                                        </button>
                                        {window.CanvaAuth && window.CanvaAuth.isAuthenticated() && window.CanvaDesignPicker && (
                                            <CanvaDesignPicker 
                                                onSelectImage={handleImageUpload} 
                                                imageType="back"
                                                language={language}
                                            />
                                        )}
                                        {backImage && (
                                            <div className="mt-2 p-3 bg-gray-50 rounded-lg">
                                                <img src={backImage.url} alt="Verso" className="w-full h-16 object-cover rounded mb-2" />
                                                <div className="flex items-center justify-between text-xs text-gray-600 mb-2">
                                                    <span>{backImage.naturalWidth}√ó{backImage.naturalHeight}px</span>
                                                    <span className="px-2 py-1 bg-green-100 text-green-800 rounded">
                                                        {backImage.quality}
                                                    </span>
                                                </div>
                                                <p className="text-xs text-gray-500 mb-2 text-center">
                                                    {language === 'fr' ? 'üñ±Ô∏è Cliquez sur l\'aper√ßu pour ajuster' : 'üñ±Ô∏è Click preview to adjust'}
                                                </p>
                                                <button
                                                    onClick={() => removeImage('back')}
                                                    className="w-full bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600"
                                                >
                                                    {t('removeImage')}
                                                </button>
                                            </div>
                                        )}
                                    </div>

                                    {bindingType === 'paperback' && dimensions && dimensions.spine > 1.5 && (
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700 mb-2">{t('spineImage')}</label>
                                            <input
                                                type="file"
                                                accept="image/*"
                                                onChange={(e) => handleImageUpload(e.target.files[0], 'spine')}
                                                className="hidden"
                                                id="spine-image-input"
                                            />
                                            <button
                                                onClick={() => document.getElementById('spine-image-input').click()}
                                                className="w-full p-3 border-2 border-dashed border-gray-300 rounded-lg text-sm text-gray-600 hover:border-blue-500 hover:text-blue-600 transition-all"
                                            >
                                                {language === 'fr' ? 'Choisir une image' : 'Choose image'}
                                            </button>
                                            {window.CanvaAuth && window.CanvaAuth.isAuthenticated() && window.CanvaDesignPicker && (
                                                <CanvaDesignPicker 
                                                    onSelectImage={handleImageUpload} 
                                                    imageType="spine"
                                                    language={language}
                                                />
                                            )}
                                            {spineImage && (
                                                <div className="mt-2 p-3 bg-gray-50 rounded-lg">
                                                    <img src={spineImage.url} alt="Dos" className="w-full h-16 object-cover rounded mb-2" />
                                                    <div className="flex items-center justify-between text-xs text-gray-600 mb-2">
                                                        <span>{spineImage.naturalWidth}√ó{spineImage.naturalHeight}px</span>
                                                        <span className="px-2 py-1 bg-green-100 text-green-800 rounded">
                                                            {spineImage.quality}
                                                        </span>
                                                    </div>
                                                    <p className="text-xs text-gray-500 mb-2 text-center">
                                                        {language === 'fr' ? 'üñ±Ô∏è Cliquez sur l\'aper√ßu pour ajuster' : 'üñ±Ô∏è Click preview to adjust'}
                                                    </p>
                                                    <button
                                                        onClick={() => removeImage('spine')}
                                                        className="w-full bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600"
                                                    >
                                                        {t('removeImage')}
                                                    </button>
                                                </div>
                                            )}

                                            <div className="mt-4">
                                                <label className="block text-sm font-medium text-gray-700 mb-2">{t('spineColor')}</label>
                                                <div className="flex items-center space-x-2">
                                                    <input
                                                        type="color"
                                                        value={spineColor}
                                                        onChange={(e) => setSpineColor(e.target.value)}
                                                        className="w-10 h-8 border border-gray-300 rounded cursor-pointer"
                                                    />
                                                    <input
                                                        type="text"
                                                        value={spineColor}
                                                        onChange={(e) => setSpineColor(e.target.value)}
                                                        className="flex-1 px-2 py-1 text-xs border border-gray-300 rounded"
                                                    />
                                                </div>
                                            </div>
                                        </div>
                                    )}

                                    {bindingType === 'paperback' && dimensions && dimensions.spine > 0 && dimensions.spine <= 1.5 && (
                                        <div className="bg-orange-50 border border-orange-200 rounded-lg p-3">
                                            <h4 className="font-medium text-orange-900 mb-2 text-sm">
                                                {language === 'fr' ? 'Tranche fine d√©tect√©e' : 'Thin spine detected'}
                                            </h4>
                                            <p className="text-orange-800 text-xs mb-3">
                                                {language === 'fr'
                                                    ?
                                                    `√âpaisseur: ${Math.round(dimensions.spine * 10) / 10}mm - Tranche trop fine pour du texte ou une image. Seule la couleur de fond est recommand√©e.`
                                                    : `Thickness: ${Math.round(dimensions.spine * 10) / 10}mm - Spine too thin for text or image. Only background color is recommended.`
                                                }
                                            </p>

                                            <div>
                                                <label className="block text-sm font-medium text-gray-700 mb-2">{t('spineColor')}</label>
                                                <div className="flex items-center space-x-2">
                                                    <input
                                                        type="color"
                                                        value={spineColor}
                                                        onChange={(e) => setSpineColor(e.target.value)}
                                                        className="w-10 h-8 border border-gray-300 rounded cursor-pointer"
                                                    />
                                                    <input
                                                        type="text"
                                                        value={spineColor}
                                                        onChange={(e) => setSpineColor(e.target.value)}
                                                        className="flex-1 px-2 py-1 text-xs border border-gray-300 rounded"
                                                    />
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>

                        <div className="preview-zone">
                            <div className="preview-header">
                                <div className="preview-title">
                                    {t('preview4k')}
                                </div>

                                <div className="preview-controls">
                                    <button
                                        onClick={handleZoomOut}
                                        className="zoom-btn"
                                        title={t('zoomOut')}
                                    >
                                        -
                                    </button>

                                    <span className="text-sm font-medium text-gray-600 mx-2">
                                        {Math.round(zoomLevel * 100)}%
                                    </span>

                                    <button
                                        onClick={handleZoomIn}
                                        className="zoom-btn"
                                        title={t('zoomIn')}
                                    >
                                        +
                                    </button>

                                    <select
                                        value={canvasQuality}
                                        onChange={(e) => setCanvasQuality(e.target.value)}
                                        className="ml-3 px-3 py-1 border border-gray-300 rounded text-sm"
                                        title={language === 'fr' ? 'Qualit√© d\'export' : 'Export quality'}
                                    >
                                        <option value="Standard">Standard (300 DPI)</option>
                                        <option value="4K">4K Ultra HD (400 DPI)</option>
                                        <option value="8K">8K Pro (600 DPI)</option>
                                    </select>
                                    
                                    {/* Toggle 2D / 3D */}
                                    <div className="view-toggle ml-3">
                                        <button 
                                            className={viewMode === '2d' ? 'active' : ''}
                                            onClick={() => setViewMode('2d')}
                                        >
                                            2D
                                        </button>
                                        <button 
                                            className={viewMode === '3d' ? 'active' : ''}
                                            onClick={() => setViewMode('3d')}
                                        >
                                            3D
                                        </button>
                                    </div>

                                    <button
                                        onClick={resetForm}
                                        className="ml-2 px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600"
                                        title={t('resetForm')}
                                    >
                                        üîÑ
                                    </button>
                                </div>
                            </div>

                            <div className="canvas-container">
                                {/* Mode 2D - Canvas classique */}
                                {viewMode === '2d' && (
                                    <>
                                        {dimensions && dimensions.bindingType === 'paperback' && (
                                            <div className="position-labels">
                                                <span>‚Üê BACK</span>
                                                <span>SPINE</span>
                                                <span>FRONT ‚Üí</span>
                                            </div>
                                        )}

                                        <div className="quality-indicator">
                                            {canvasQuality === 'Standard' ? '300 DPI' : canvasQuality === '4K' ? '4K' : '8K'}
                                        </div>

                                        {dimensions ?
                                            (
                                                <React.Fragment key="canvas-active">
                                                    <canvas
                                                        ref={canvasRef}
                                                        className="canvas-4k"
                                                        style={{ cursor: draggingElement ? 'grabbing' : ((bookTitle || authorName || backCoverText || frontImage || backImage || spineImage) ? 'grab' : 'default') }}
                                                        onMouseDown={handleCanvasMouseDown}
                                                        onMouseMove={handleCanvasMouseMove}
                                                        onMouseUp={handleCanvasMouseUp}
                                                        onMouseLeave={handleCanvasMouseUp}
                                                    />
                                                    
                                                    {/* üìç Instructions drag & drop */}
                                                    {(bookTitle || authorName || backCoverText || frontImage || backImage || spineImage) && (
                                                        <div className="absolute bottom-2 left-2 bg-black/60 text-white text-xs px-2 py-1 rounded">
                                                            üñ±Ô∏è {language === 'fr' ? 'Glissez texte ou images pour repositionner' : 'Drag text or images to reposition'}
                                                        </div>
                                                    )}

                                                    <div className="dimensions-overlay">
                                                        {Math.round(dimensions.total.width)}√ó{Math.round(dimensions.total.height)}mm | {canvasQuality === 'Standard' ? '300 DPI' : canvasQuality === '4K' ? '400 DPI' : '600 DPI'}
                                                        {format === '8.5x11' && (
                                                            <div className="text-orange-300 text-xs mt-1">
                                                                ‚ö†Ô∏è FORMAT COMPLEXE
                                                            </div>
                                                        )}
                                                    </div>
                                                </React.Fragment>
                                            ) : (
                                                <div key="canvas-placeholder" className="text-center py-20 text-gray-500">
                                                    <div className="text-6xl mb-4">üìñ</div>
                                                    <h3 className="text-xl font-semibold mb-2">
                                                        {language === 'fr' 
                                                            ? `Aper√ßu ${canvasQuality === 'Standard' ? 'Standard' : canvasQuality === '4K' ? '4K Ultra HD' : '8K Pro'}` 
                                                            : `${canvasQuality === 'Standard' ? 'Standard' : canvasQuality === '4K' ? '4K Ultra HD' : '8K Pro'} Preview`}
                                                    </h3>
                                                    <p className="text-gray-400 mb-4">
                                                        {language === 'fr' ? 'S√©lectionnez un format pour voir l\'aper√ßu' : 'Select a format to see preview'}
                                            </p>

                                            <div className="bg-white border-2 border-dashed border-gray-300 rounded-lg p-8 mx-auto max-w-md">
                                                <div className="grid grid-cols-3 gap-2 mb-4">
                                                    <div className="bg-gray-200 h-20 rounded flex items-center justify-center text-xs">BACK</div>
                                                    <div className="bg-gray-300 h-20 rounded flex items-center justify-center text-xs">SPINE</div>
                                                    <div className="bg-gray-200 h-20 rounded flex items-center justify-center text-xs">FRONT</div>
                                                </div>
                                                <p className="text-xs text-gray-500">
                                                    {language === 'fr' ? 'Mod√®le de couverture KDP' : 'KDP Cover Template'}
                                                </p>
                                            </div>
                                        </div>
                                    )}
                                    </>
                                )}
                                
                                {/* üéõÔ∏è BARRE DE CONTR√îLE IMAGE - Zoom & Position */}
                                {viewMode === '2d' && selectedImage && dimensions && (
                                    <div className="mt-4 p-4 bg-gray-100 rounded-lg border border-gray-300">
                                        <div className="flex items-center justify-between mb-3">
                                            <div className="flex items-center gap-3">
                                                <span className="text-sm font-medium text-gray-700">
                                                    üñºÔ∏è {selectedImage === 'front' ? (language === 'fr' ? 'Image Face' : 'Front Image') : 
                                                        selectedImage === 'back' ? (language === 'fr' ? 'Image Verso' : 'Back Image') : 
                                                        (language === 'fr' ? 'Image Tranche' : 'Spine Image')}
                                                </span>
                                                <span className="px-2 py-1 bg-blue-100 text-blue-800 rounded text-xs">
                                                    {selectedImage === 'front' ? `${Math.round(frontImageZoom * 100)}%` :
                                                     selectedImage === 'back' ? `${Math.round(backImageZoom * 100)}%` :
                                                     `${Math.round(spineImageZoom * 100)}%`}
                                                </span>
                                            </div>
                                            <div className="flex items-center gap-2">
                                                <button 
                                                    onClick={() => {
                                                        if (selectedImage === 'front') { setFrontImageZoom(1.0); setFrontImageOffset({x:0, y:0}); }
                                                        if (selectedImage === 'back') { setBackImageZoom(1.0); setBackImageOffset({x:0, y:0}); }
                                                        if (selectedImage === 'spine') { setSpineImageZoom(1.0); setSpineImageOffset({x:0, y:0}); }
                                                    }}
                                                    className="px-3 py-1 text-xs bg-gray-200 hover:bg-gray-300 rounded transition-colors"
                                                >
                                                    ‚Ü∫ Reset
                                                </button>
                                                <button 
                                                    onClick={() => setSelectedImage(null)}
                                                    className="px-3 py-1 text-xs bg-gray-200 hover:bg-gray-300 rounded transition-colors"
                                                >
                                                    ‚úï
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div className="flex items-center gap-4">
                                            <span className="text-xs text-gray-500 w-8">50%</span>
                                            <input 
                                                type="range" 
                                                min="0.5" 
                                                max="3" 
                                                step="0.05" 
                                                value={selectedImage === 'front' ? frontImageZoom : selectedImage === 'back' ? backImageZoom : spineImageZoom}
                                                onChange={(e) => {
                                                    const val = parseFloat(e.target.value);
                                                    if (selectedImage === 'front') setFrontImageZoom(val);
                                                    if (selectedImage === 'back') setBackImageZoom(val);
                                                    if (selectedImage === 'spine') setSpineImageZoom(val);
                                                }}
                                                className="flex-1 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer"
                                                style={{ accentColor: '#FF9900' }}
                                            />
                                            <span className="text-xs text-gray-500 w-10">300%</span>
                                        </div>
                                        
                                        <p className="text-xs text-gray-500 mt-2 text-center">
                                            {language === 'fr' 
                                                ? 'üñ±Ô∏è Glissez l\'image sur l\'aper√ßu pour la repositionner' 
                                                : 'üñ±Ô∏è Drag the image on preview to reposition'}
                                        </p>
                                    </div>
                                )}
                                
                                {/* üé¨ Mode 3D - THREE.JS MOCKUP */}
                                {viewMode === '3d' && (
                                    <div id="mockup-3d-wrapper" style={{
                                        width: '100%',
                                        minHeight: '550px',
                                        background: 'linear-gradient(135deg, #0d0f14 0%, #1a1d23 100%)',
                                        borderRadius: '12px',
                                        overflow: 'hidden',
                                        position: 'relative'
                                    }}>
                                        {dimensions && (frontImage || backImage || backCoverTexture) ? (
                                            <React.Fragment>
                                                {/* Container Three.js */}
                                                <div 
                                                    id="threejs-container" 
                                                    style={{width: '100%', height: '420px'}}
                                                    ref={(el) => {
                                                        if (el && !el.dataset.init && window.initBook3D) {
                                                            el.dataset.init = 'true';
                                                            setTimeout(() => {
                                                                window.initBook3D(el, {
                                                                    coverUrl: frontImage?.url || null,
                                                                    backUrl: backImage?.url || null,
                                                                    spineColor: spineColor || '#222222',
                                                                    bookWidth: dimensions.format.width,
                                                                    bookHeight: dimensions.format.height,
                                                                    spineWidth: dimensions.spine,
                                                                    isFullCover: frontImage?.isFullCover || false
                                                                });
                                                            }, 50);
                                                        }
                                                    }}
                                                ></div>
                                                
                                                {/* Contr√¥les 3D */}
                                                <div style={{
                                                    display: 'flex',
                                                    justifyContent: 'center',
                                                    alignItems: 'center',
                                                    gap: '15px',
                                                    padding: '15px',
                                                    background: 'rgba(0,0,0,0.5)',
                                                    borderTop: '1px solid rgba(255,255,255,0.1)',
                                                    flexWrap: 'wrap'
                                                }}>
                                                    {/* Presets de vue */}
                                                    <div style={{display:'flex', gap:'8px'}}>
                                                        {['Perspective', 'Flat', 'Standing'].map(style => (
                                                            <button
                                                                key={style}
                                                                onClick={() => {
                                                                    if (window.setBook3DPreset) window.setBook3DPreset(style.toLowerCase());
                                                                }}
                                                                style={{
                                                                    padding: '8px 16px',
                                                                    borderRadius: '20px',
                                                                    border: 'none',
                                                                    cursor: 'pointer',
                                                                    background: 'rgba(255,255,255,0.15)',
                                                                    color: '#fff',
                                                                    fontSize: '12px',
                                                                    fontWeight: '500',
                                                                    transition: 'all 0.2s'
                                                                }}
                                                                onMouseOver={(e) => e.target.style.background = '#FF9900'}
                                                                onMouseOut={(e) => e.target.style.background = 'rgba(255,255,255,0.15)'}
                                                            >
                                                                {style}
                                                            </button>
                                                        ))}
                                                    </div>
                                                    
                                                    {/* Bouton Export PNG */}
                                                    <button
                                                        onClick={() => {
                                                            if (window.exportBook3DPNG) window.exportBook3DPNG();
                                                            else alert(language === 'fr' ? 'Mockup 3D non initialis√©' : '3D Mockup not initialized');
                                                        }}
                                                        style={{
                                                            padding: '8px 20px',
                                                            borderRadius: '20px',
                                                            border: '2px solid #10B981',
                                                            cursor: 'pointer',
                                                            background: 'transparent',
                                                            color: '#10B981',
                                                            fontSize: '12px',
                                                            fontWeight: 'bold',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            gap: '6px'
                                                        }}
                                                    >
                                                        üì∏ Export PNG
                                                    </button>
                                                </div>
                                                
                                                <p style={{
                                                    color: '#6B7280',
                                                    fontSize: '11px',
                                                    textAlign: 'center',
                                                    padding: '8px',
                                                    margin: 0
                                                }}>
                                                    {language === 'fr' 
                                                        ? 'üñ±Ô∏è Glissez pour faire pivoter ‚Ä¢ Molette pour zoomer' 
                                                        : 'üñ±Ô∏è Drag to rotate ‚Ä¢ Scroll to zoom'}
                                                </p>
                                            </React.Fragment>
                                        ) : (
                                            <div className="text-center text-white opacity-50" style={{padding: '150px 20px'}}>
                                               <div className="text-6xl mb-4">üìö</div>
                                               <p>{language === 'fr' ? 'Chargez une couverture pour voir le mockup 3D' : 'Load a cover to see the 3D mockup'}</p>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                            
                            {dimensions && (
                                <div className="flex justify-center items-center space-x-6 mt-3 text-xs text-gray-700 p-2 bg-gray-50 rounded-lg">
                                    <div className="flex items-center">
                                        <div className="w-4 h-0 border-t-2 border-blue-500 border-dashed mr-2"></div>
                                        <span>{t('legendTrim')}</span>
                                    </div>
                                    <div className="flex items-center">
                                        <div className="w-4 h-0 border-t-2 border-red-500 border-dashed mr-2"></div>
                                        <span>{t('legendSafeZone')}</span>
                                    </div>
                                </div>
                            )}

                            <div className="mt-6 flex flex-col items-center">
                                <div className="mb-4 bg-white border border-gray-200 rounded-lg p-4 shadow-sm max-w-md w-full">
                                    <h4 className="font-semibold text-gray-800 mb-3 text-center">
                                        üìÅ {t('exportFormat')}
                                    </h4>

                                    <div className="space-y-2">
                                        <label className="flex items-center space-x-3 p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer">
                                            <input
                                                type="radio"
                                                name="exportFormat"
                                                value="pdf"
                                                checked={exportFormat === 'pdf'}
                                                onChange={(e) => setExportFormat(e.target.value)}
                                                className="text-orange-500"
                                            />
                                            <div className="flex-1">
                                                <div className="font-medium text-gray-800">{t('formatPDF')}</div>
                                                <div className="text-xs text-gray-500">
                                                    {language === 'fr' ? 'Format standard pour Amazon KDP' : 'Standard format for Amazon KDP'}
                                                </div>
                                            </div>
                                            <span className="bg-orange-100 text-orange-800 text-xs px-2 py-1 rounded-full font-semibold">
                                                ‚≠ê
                                            </span>
                                        </label>

                                        <label className="flex items-center space-x-3 p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer">
                                            <input
                                                type="radio"
                                                name="exportFormat"
                                                value="png"
                                                checked={exportFormat === 'png'}
                                                onChange={(e) => setExportFormat(e.target.value)}
                                                className="text-blue-500"
                                            />
                                            <div className="flex-1">
                                                <div className="font-medium text-gray-800">{t('formatPNG')}</div>
                                                <div className="text-xs text-gray-500">
                                                    {language === 'fr' ? 'Excellente qualit√©, accept√© par Amazon' : 'Excellent quality, accepted by Amazon'}
                                                </div>
                                            </div>
                                        </label>

                                        <label className="flex items-center space-x-3 p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer">
                                            <input
                                                type="radio"
                                                name="exportFormat"
                                                value="jpeg"
                                                checked={exportFormat === 'jpeg'}
                                                onChange={(e) => setExportFormat(e.target.value)}
                                                className="text-green-500"
                                            />
                                            <div className="flex-1">
                                                <div className="font-medium text-gray-800">{t('formatJPEG')}</div>
                                                <div className="text-xs text-gray-500">
                                                    {language === 'fr' ? 'Fichier plus l√©ger, bonne qualit√©' : 'Smaller file, good quality'}
                                                </div>
                                            </div>
                                        </label>
                                    </div>

                                    {exportFormat === 'pdf' && (
                                        <div className="mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                                            <p className="text-xs text-blue-800">
                                                <span className="font-semibold">üí° Info PDF :</span> Le PDF sera g√©n√©r√© directement, en utilisant l'image haute d√©finition.
                                            </p>
                                        </div>
                                    )}

                                    {format === '8.5x11' && (
                                        <div className="mt-3 p-3 bg-red-50 border border-red-200 rounded-lg">
                                            <p className="text-xs text-red-800">
                                                <span className="font-semibold">‚ö†Ô∏è Format 8.5√ó11" :</span>
                                                {language === 'fr' 
                                                    ? ' Export√© en 360 DPI pour ce format complexe. V√©rifiez le PDF final.'
                                                    : ' Exported at 360 DPI for this complex format. Please check the final PDF.'
                                                }
                                            </p>
                                        </div>
                                    )}

                                    {/* üîí KDP STRICT - Checkbox de confirmation obligatoire */}
                                    {exportFormat === 'pdf' && (
                                        <div className="mt-4 p-4 bg-amber-50 border-2 border-amber-300 rounded-lg">
                                            <label className="flex items-start gap-3 cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    checked={kdpStrictConfirmed}
                                                    onChange={(e) => setKdpStrictConfirmed(e.target.checked)}
                                                    className="mt-1 w-5 h-5 text-amber-600 rounded focus:ring-amber-500"
                                                />
                                                <span className="text-sm text-amber-900">
                                                    <strong>üîí KDP Strict :</strong> {language === 'fr' 
                                                        ? `Je confirme que les param√®tres KDP de mon livre correspondent EXACTEMENT √† ceux-ci : ${kdpFormats[format]?.name || format}, ${pageCount} pages, ${paperType === 'white' ? 'N&B papier blanc' : paperType === 'cream' ? 'N&B papier cr√®me' : paperType}, ${hasBleed ? 'avec fond perdu' : 'sans fond perdu'}. Sinon KDP rejettera la couverture.`
                                                        : `I confirm that my KDP book parameters EXACTLY match: ${kdpFormats[format]?.name || format}, ${pageCount} pages, ${paperType}, ${hasBleed ? 'with bleed' : 'without bleed'}. Otherwise KDP will reject the cover.`
                                                    }
                                                </span>
                                            </label>
                                        </div>
                                    )}
                                </div>

                                {/* üìö Design Library controls */}
                                {viewMode === '2d' && (
                                    <div className="flex flex-col gap-2 items-center mb-3">
                                        <div className="flex flex-wrap gap-2 justify-center">
                                            <button
                                                onClick={saveCurrentToLibrary}
                                                className="px-4 py-2 rounded-lg border border-gray-300 bg-white text-gray-800 text-sm font-semibold hover:shadow"
                                                type="button"
                                            >
                                                üíæ {language === 'fr' ? 'Sauvegarder' : 'Save'}
                                            </button>
                                            <button
                                                onClick={openDesignsModal}
                                                className="px-4 py-2 rounded-lg border border-gray-300 bg-white text-gray-800 text-sm font-semibold hover:shadow"
                                                type="button"
                                            >
                                                üìö {language === 'fr' ? 'Mes designs' : 'My designs'}
                                            </button>
                                            <button
                                                onClick={createNewDesign}
                                                className="px-4 py-2 rounded-lg border border-gray-300 bg-white text-gray-800 text-sm font-semibold hover:shadow"
                                                type="button"
                                            >
                                                ‚ûï {language === 'fr' ? 'Nouveau' : 'New'}
                                            </button>
                                        </div>
                                        <div className="w-full max-w-md">
                                            <input
                                                value={designTitle}
                                                onChange={(e) => setDesignTitle(e.target.value)}
                                                placeholder={language === 'fr' ? 'Nom du design (optionnel)' : 'Design name (optional)'}
                                                className="w-full px-3 py-2 rounded-lg border border-gray-300 text-sm"
                                                type="text"
                                            />
                                        </div>
                                    </div>
                                )}

                                {/* Bouton Export 2D classique */}
                                {viewMode === '2d' && (
                                    <button
                                        onClick={handleExportClick}
                                        disabled={!dimensions || isExporting || (exportFormat === 'pdf' && !kdpStrictConfirmed)}
                                        className={`flex items-center space-x-3 px-8 py-4 rounded-xl font-bold text-lg text-white transition-all transform hover:scale-105 shadow-lg hover:shadow-xl ${
                                            isExporting
                                                ? 'bg-purple-500 cursor-wait scale-95'
                                                : !dimensions || (exportFormat === 'pdf' && !kdpStrictConfirmed)
                                                    ? 'bg-gray-400 cursor-not-allowed'
                                                    : format === '8.5x11'
                                                        ? 'bg-gradient-to-r from-red-500 to-orange-500 hover:from-red-600 hover:to-orange-600'
                                                        : 'bg-gradient-to-r from-orange-500 to-yellow-500 hover:from-orange-600 hover:to-yellow-600'
                                        }`}
                                    >
                                        <span className="text-2xl">üíæ</span>
                                        <span>
                                            {isExporting 
                                                ? t('generating') 
                                                : !window.isUserLoggedIn || !window.isUserLoggedIn()
                                                    ? (language === 'fr' ? 'EXPORTER (Inscription gratuite)' : 'EXPORT (Free signup)')
                                                    : exportLimitInfo.level === 'pro'
                                                        ? t('exportDesign') + ' ‚àû'
                                                        : `${t('exportDesign')} (${exportLimitInfo.remaining} ${language === 'fr' ? 'restant' : 'left'})`
                                            }
                                        </span>
                                    </button>
                                )}
                                
                                {/* Texte Mode Pr√©visualisation sous le bouton EXPORT */}
                                {isMarketplacePreview && (
                                    <div style={{
                                        marginTop: '12px',
                                        textAlign: 'center',
                                        color: '#FF9900',
                                        fontSize: '0.9rem',
                                        fontWeight: '600',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        gap: '8px'
                                    }}>
                                        <span style={{fontSize: '1.2rem'}}>üé®</span>
                                        <span>{language === 'fr' ? 'Mode Pr√©visualisation - Exportez pour obtenir l\'image HD sans watermark' : 'Preview Mode - Export to get HD image without watermark'}</span>
                                    </div>
                                )}
                                
                                {/* Boutons Export 3D - THREE.JS */}
                                {viewMode === '3d' && (
                                    <div className="flex flex-col gap-3">
                                        <button
                                            onClick={() => {
                                                if (window.exportBook3DPNG) {
                                                    window.exportBook3DPNG();
                                                } else {
                                                    alert(language === 'fr' ? 'Mockup 3D non initialis√©' : '3D Mockup not initialized');
                                                }
                                            }}
                                            disabled={!dimensions || !(frontImage || backImage || backCoverTexture)}
                                            className={`flex items-center justify-center space-x-3 px-8 py-4 rounded-xl font-bold text-lg text-white transition-all transform hover:scale-105 shadow-lg hover:shadow-xl ${
                                                !dimensions || !(frontImage || backImage || backCoverTexture)
                                                    ? 'bg-gray-400 cursor-not-allowed'
                                                    : 'bg-gradient-to-r from-purple-500 to-indigo-500 hover:from-purple-600 hover:to-indigo-600'
                                            }`}
                                        >
                                            <span className="text-2xl">üì∏</span>
                                            <span>
                                                {language === 'fr' ? 'Exporter Mockup 3D (PNG)' : 'Export 3D Mockup (PNG)'}
                                            </span>
                                        </button>
                                        
                                        <p className="text-xs text-gray-500 text-center">
                                            {language === 'fr' 
                                                ? 'üé¨ Export PNG haute r√©solution avec Three.js'
                                                : 'üé¨ High resolution PNG export with Three.js'}
                                        </p>
                                        
                                        {/* Bouton pour revenir √† l'export 2D */}
                                        <button
                                            onClick={() => setViewMode('2d')}
                                            className="text-sm text-gray-500 hover:text-gray-700 underline"
                                        >
                                            {language === 'fr' ? '‚Üê Revenir au mode 2D pour exporter PDF/PNG' : '‚Üê Back to 2D mode for PDF/PNG export'}
                                        </button>
                                    </div>
                                )}
                                
                                {/* Affichage de la r√©solution finale */}
                                {dimensions && viewMode === '2d' && (
                                    <div className="mt-2 text-xs text-gray-500 text-center">
                                        üìê {Math.round(dimensions.total.width * (canvasQuality === 'Standard' ? 11.811 : canvasQuality === '4K' ? 15.748 : 23.622))} √ó {Math.round(dimensions.total.height * (canvasQuality === 'Standard' ? 11.811 : canvasQuality === '4K' ? 15.748 : 23.622))} px
                                        <span className="ml-2 text-amber-600 font-medium">
                                            ({canvasQuality === 'Standard' ? '300' : canvasQuality === '4K' ? '400' : '600'} DPI)
                                        </span>
                                    </div>
                                )}

                                <div className="mt-4 max-w-lg text-center">
                                    <p className="text-xs text-gray-500 bg-gray-50 border border-gray-200 rounded-lg px-3 py-2">
                                        <span className="font-medium">{t('disclaimerExport')}</span>
                                        <br />
                                        <span className="text-orange-600">{t('technicalOnly')}</span> ‚Ä¢ <span className="text-blue-600">{t('contentResponsibility')}</span>
                                    </p>
                                </div>
                            </div>
                        </div>

                        <div className="sidebar">
                            <div className="sidebar-section">
                                <div className="mb-3">
                                    <h2 className="sidebar-title">
                                        <i className="fas fa-palette text-purple-500"></i>
                                        {t('canvaImport')}
                                    </h2>
                                    <p className="text-xs text-purple-600 bg-purple-50 border border-purple-200 rounded px-2 py-1 inline-block">
                                        {t('canvaComingSoon')}
                                    </p>
                                </div>

                                <div className="bg-gradient-to-r from-purple-50 to-indigo-50 border border-purple-200 rounded-lg p-4">
                                    <div className="text-center">
                                        <div className="text-4xl mb-3">üé®</div>
                                        <h3 className="font-bold text-purple-900 mb-2">
                                            {t('canvaTitle')}
                                        </h3>
                                        <p className="text-sm text-purple-800 mb-4 leading-relaxed">
                                            {t('canvaDescription')}
                                        </p>
                                        <button
                                            onClick={() => {
                                                console.log('üîò Bouton Canva cliqu√©');
                                                if (window.CanvaAuth) {
                                                    window.CanvaAuth.initiateConnection();
                                                } else {
                                                    alert('Fonctionnalit√© en cours de d√©veloppement. Revenez bient√¥t ! üöÄ');
                                                }
                                            }}
                                            className="w-full py-3 px-4 bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white font-semibold rounded-lg transition-all duration-300 transform hover:scale-105 shadow-lg"
                                        >
                                            {t('canvaConnectButton')}
                                        </button>
                                        <p className="text-xs text-gray-500 mt-3">
                                            {t('canvaAvailabilitySoon')}
                                        </p>
                                    </div>
                                </div>

                                {/* Debug info - will be hidden in production */}
                                {false && (
                                    <div className="mt-2 text-xs text-gray-400">
                                        <p>Debug:</p>
                                        <p>CanvaAuth: {typeof window.CanvaAuth !== 'undefined' ? '‚úÖ Charg√©' : '‚ùå Non charg√©'}</p>
                                        <p>CanvaDesigns: {typeof window.CanvaDesigns !== 'undefined' ? '‚úÖ Charg√©' : '‚ùå Non charg√©'}</p>
                                    </div>
                                )}

                                {/* Container for Canva designs grid */}
                                <div id="canva-designs-container" className="mt-4" style={{minHeight: '100px'}}>
                                    {/* La grille Canva sera inject√©e ici par canva-designs-fetcher.js */}
                                </div>
                            </div>

                            <div className="sidebar-section">
                                <div className="validation-smart">
                                    <div className="validation-header">
                                        <span className="text-xl">üéØ</span>
                                        <h2 className="font-bold text-lg">{t('analysisTitle')}</h2>
                                    </div>

                                    <div className="validation-score">
                                        {(frontImage || backImage || dimensions) ? (
                                            <div>
                                                <div className={getScoreClass(overallScore)}>
                                                    <div className="font-bold text-lg">{getScoreLabel(overallScore).label}</div>
                                                    <div className="text-sm opacity-90">{getScoreLabel(overallScore).subtitle}</div>
                                                    <div className="text-xs mt-2 opacity-75">Score: {overallScore}/25</div>
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="no-analysis">
                                                <div className="text-4xl mb-3">üìä</div>
                                                <h3 className="font-semibold text-gray-700 mb-2">{t('analysisTitle')}</h3>
                                                <p className="text-sm text-gray-500">{t('noImagesYet')}</p>
                                            </div>
                                        )}
                                    </div>

                                    {warnings.length > 0 && (
                                        <div className="validation-alerts">
                                            {warnings.map((warning, index) => (
                                                <div key={index} className={`alert-item alert-${warning.type}`}>
                                                    <div className="alert-icon">
                                                        {warning.type === 'excellent' && 'üèÜ'}
                                                        {warning.type === 'good' && '‚úÖ'}
                                                        {warning.type === 'warning' && '‚ö†Ô∏è'}
                                                        {warning.type === 'critical' && '‚ùå'}
                                                        {warning.type === 'info' && '‚ÑπÔ∏è'}
                                                    </div>
                                                    <div className="flex-1">
                                                        {warning.message}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}

                                    <div className="validation-tips">
                                        <div className="tips-title">
                                            <span>üí°</span>
                                            {t('kdpTips')}
                                        </div>

                                        <div className="space-y-2">
                                            <div className="tip-item">
                                                <span>üìñ</span>
                                                <span>{t('tipFormat')}</span>
                                            </div>

                                            <div className="tip-item">
                                                <span>üñºÔ∏è</span>
                                                <span>{t('tipBleed')}</span>
                                            </div>

                                            <div className="tip-item">
                                                <span>üìè</span>
                                                <span>{t('tipSpine')}</span>
                                            </div>

                                            <div className="tip-item">
                                                <span>‚ú®</span>
                                                <span>{t('tipResolution')}</span>
                                            </div>
                                        </div>

                                        <div className="mt-4 pt-3 border-t border-gray-300">
                                            <div className="tips-title">
                                                <span>‚ö†Ô∏è</span>
                                                <span>{t('disclaimer')}</span>
                                            </div>
                                            <p className="text-xs text-gray-600 leading-relaxed">
                                                {t('disclaimerShort')}
                                            </p>
                                            <details className="mt-2">
                                                <summary className="text-xs text-blue-600 cursor-pointer hover:text-blue-800">
                                                    {language === 'fr' ? 'Voir les d√©tails' : 'See details'}
                                                </summary>
                                                <p className="text-xs text-gray-500 mt-2 leading-relaxed">
                                                    {t('disclaimerFull')}
                                                </p>
                                            </details>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
        
        const AppContainer = () => {
            const [key, setKey] = useState(0); 
            return <KDPCoverGenerator key={key} onReset={() => setKey(prevKey => prevKey + 1)} />;
        }

        const generatorContainer = document.getElementById('kdp-generator-container');
        if (generatorContainer) {
            ReactDOM.render(<AppContainer />, generatorContainer);
        }
    </script>

   <section class="feedback-section">
      <h3 data-fr="Aidez-nous √† am√©liorer" data-en="Help us improve">Help us improve</h3>
      <p data-fr="Nous aimerions conna√Ætre votre avis. N'h√©sitez pas √† nous faire part de vos commentaires." data-en="We‚Äôd love to hear your thoughts. Share your feedback with us.">We‚Äôd love to hear your thoughts. Share your feedback with us.</p>
 <button 
  id="feedbackBtn"
  class="px-4 py-2 bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-lg hover:from-blue-600 hover:to-indigo-700 transition-all duration-300 font-semibold shadow-lg"
  data-fr="üí¨ Donner votre avis" 
  data-en="üí¨ Give Feedback">
  üí¨ Give Feedback
</button>
   </section>    

    <footer class="bg-gray-900 text-gray-300 py-12">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="social-section">
                <h4 class="text-white font-semibold mb-4 text-center" data-en="üöÄ Follow us for the latest KDP news!"
                    data-fr="üöÄ Suivez-nous pour les derni√®res actualit√©s KDP !">üöÄ Follow us for the latest KDP news!
                </h4>
                <div class="social-links">
                    <a href="https://www.youtube.com/@Gabaritkdp" class="social-link youtube"
                        title="YouTube - KDP Tutorials" target="_blank" rel="noopener noreferrer"><i
                            class="fab fa-youtube"></i></a>
                    <a href="https://www.facebook.com/profile.php?id=61578785408904" class="social-link facebook"
                        title="Facebook - Authors Community" target="_blank" rel="noopener noreferrer"><i
                            class="fab fa-facebook-f"></i></a>
                    <a href="https://www.instagram.com/gabaritkdp/" class="social-link instagram"
                        title="Instagram - Cover Inspirations" target="_blank" rel="noopener noreferrer"><i
                            class="fab fa-instagram"></i></a>
                    <a href="https://fr.pinterest.com/Gabaritkdp/" class="social-link pinterest"
                        title="Pinterest - Cover Designs" target="_blank" rel="noopener noreferrer"><i
                            class="fab fa-pinterest-p"></i></a>
                    <a href="https://www.tiktok.com/@gabaritkdp" class="social-link tiktok"
                        title="TikTok - Quick KDP Tips" target="_blank" rel="noopener noreferrer"><i
                            class="fab fa-tiktok"></i></a>
                    <a href="https://www.linkedin.com/in/gabarit-kdp-073368378/" class="social-link linkedin"
                        title="LinkedIn - Publishers & Agencies" target="_blank" rel="noopener noreferrer"><i
                            class="fab fa-linkedin-in"></i></a>
                </div>
                <p class="text-center text-sm text-gray-400 mt-4"
                    data-en="KDP Tips ‚Ä¢ Tutorials ‚Ä¢ News ‚Ä¢ Authors Community"
                    data-fr="Astuces KDP ‚Ä¢ Tutoriels ‚Ä¢ Actualit√©s ‚Ä¢ Communaut√© d'auteurs">KDP Tips ‚Ä¢ Tutorials ‚Ä¢ News ‚Ä¢
                    Authors Community</p>
            </div>
            <div class="grid md:grid-cols-4 gap-8">
                <div>
                    <div class="flex items-center mb-4"><img src="logo-gabarit-kdp-site-web.png" alt="GabaritKDP"
                            class="h-8 w-auto"><span class="ml-2 text-white font-bold">GabaritKDP</span></div>
                    <p class="text-gray-400" data-en="The generator for 100% Amazon-compliant KDP covers."
                        data-fr="Le g√©n√©rateur de couvertures KDP 100% conformes pour Amazon.">The generator for 100%
                        Amazon-compliant KDP covers.</p>
                </div>
                <div>
                    <h4 class="text-white font-semibold mb-4" data-en="Product" data-fr="Produit">Product</h4>
                    <ul class="space-y-2">
                        <li style="margin-bottom: 10px;"><a href="generator.html"
                                class="hover:text-white transition f-exp-gene" data-en="Express Generator"
                                data-fr="G√©n√©rateur Express">Express Generator</a></li>
                        <li><a href="generator-magic.html" class="hover:text-white transition" data-en="Magic Generator"
                                data-fr="G√©n√©rateur Magique">Magic Generator</a></li>
                        <li><a href="./marketplace.html" rel="noopener" class="hover:text-white transition" data-en="Marketplace"
                                data-fr="March√©">Marketplace</a></li>
                        <li><a href="#tarifs" class="hover:text-white transition" data-en="Pricing"
                                data-fr="Tarifs">Pricing</a></li>
                        <li><a href="fonctionnalites.html" class="hover:text-white transition" data-en="Features"
                                data-fr="Fonctionnalit√©s">Features</a></li>
                    </ul>
                </div>
                <div>
                    <h4 class="text-white font-semibold mb-4" data-en="Support" data-fr="Support">Support</h4>
                    <ul class="space-y-2">
                        <li><a href="api-pro.html" class="hover:text-white transition" data-en="API"
                                data-fr="API">API</a></li>
                        <li><a href="faq.html" class="hover:text-white transition" data-en="FAQ" data-fr="FAQ">FAQ</a>
                        </li>
                        <li><a href="contact.html" class="hover:text-white transition" data-en="Contact"
                                data-fr="Contact">Contact</a></li>
                        <li><a href="guide.html" class="hover:text-white transition" data-en="User Guide"
                                data-fr="Guide d'utilisation">User Guide</a></li>
                        <li><a href="updates.html" class="hover:text-white transition" data-en="Updates / What‚Äôs New"
                                data-fr="Mises √† jour / Nouveaut√©s">Updates / What‚Äôs New</a></li>
                    </ul>
                </div>
                <div>
                    <h4 class="text-white font-semibold mb-4" data-en="Legal" data-fr="L√©gal">Legal</h4>
                    <ul class="space-y-2">
                        <li><a href="mentions-legales.html" class="hover:text-white transition" data-en="Legal Notice"
                                data-fr="Mentions L√©gales">Legal Notice</a></li>
                        <li><a href="cgu.html" class="hover:text-white transition" data-en="Terms of Service"
                                data-fr="Conditions d'utilisation">Terms of Service</a></li>
                        <li><a href="confidentialite.html" class="hover:text-white transition" data-en="Privacy Policy"
                                data-fr="Politique de confidentialit√©">Privacy Policy</a></li>
                    </ul>
                </div>
            </div>
            <div class="border-t border-gray-800 mt-8 pt-8 text-center">
                <p>&copy; 2025 GabaritKDP. All rights reserved.</p>
            </div>
        </div>
    </footer>
<script>
    // Replace with your final Tally form links
    const tallyForms = {
        en: "https://tally.so/r/3yB7pd",
        fr: "https://tally.so/r/mY2DJN"
    };

    document.getElementById("feedbackBtn").addEventListener("click", () => {
        const lang = localStorage.getItem("preferredLanguage") || "en";
        window.open(tallyForms[lang], "_blank");
    });
</script>

<script id="lang-switch-module">
(function(){
  const DEFAULT='en'; const VALID=new Set(['en','fr']);
  function getSavedLang(){
    return (localStorage.getItem('preferredLanguage')||document.documentElement.lang||DEFAULT).toLowerCase();
  }
  function setLang(lang){
    lang=(lang||'').toLowerCase(); if(!VALID.has(lang)) lang=DEFAULT;
    document.documentElement.setAttribute('lang',lang);
    try{localStorage.setItem('preferredLanguage',lang);}catch(_){}
    const nodes=document.querySelectorAll('[data-fr],[data-en]');
    nodes.forEach(el=>{
      const val=el.getAttribute('data-'+lang); if(val==null) return;
      if(el.tagName==='META') el.setAttribute('content',val);
      else if(el.tagName==='TITLE') el.textContent=val;
      else if(/[<&]/.test(val)) el.innerHTML=val;
      else el.textContent=val;
    });
    document.querySelectorAll('.lang-btn').forEach(btn=>{
      const b=(btn.getAttribute('data-lang')||'').toLowerCase();
      btn.classList.toggle('active', b===lang);
    });
    window.currentLanguage=lang;
    if(typeof window.reactSetLanguage==='function'){ try{ window.reactSetLanguage(lang); }catch(e){} }
  }
  window.switchLanguage=setLang; window.applyLanguage=setLang;
  document.addEventListener('DOMContentLoaded',function(){
    setLang(getSavedLang());
    document.querySelectorAll('.lang-btn').forEach(btn=>{
      btn.addEventListener('click',function(){ setLang(this.getAttribute('data-lang')||DEFAULT); });
    });
  });
})();
</script>


<script>
(function () {
  window.showFeedbackPrompt = function (lang) {
    try {
      const isEN = (lang || '').toLowerCase().startsWith('en');
      const TALLY_EN = 'https://tally.so/r/3yB7pd';
      const TALLY_FR = 'https://tally.so/r/mY2DJN';
      const redirectUrl = isEN ? TALLY_EN : TALLY_FR;
      const L = isEN
        ? { title: 'How was your export?', subtitle: 'Give us a quick 1‚Äì5 star rating', later: 'Maybe later', send: 'Send rating' }
        : { title: 'Votre export s‚Äôest bien pass√© ?', subtitle: 'Donnez-nous une note rapide 1‚Äì5 √©toiles', later: 'Plus tard', send: 'Envoyer la note' };
      const style = document.createElement('style');
      style.textContent = '.gkdp-modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:9999}.gkdp-modal{background:#fff;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.25);max-width:520px;width:92%;padding:24px}.gkdp-title{font-weight:800;font-size:20px;color:#111827}.gkdp-sub{margin-top:6px;color:#6B7280;font-size:14px}.gkdp-stars{display:flex;gap:8px;justify-content:center;align-items:center;margin:18px 0}.gkdp-star{cursor:pointer;font-size:28px;line-height:1;transition:transform .15s ease}.gkdp-star:hover{transform:scale(1.1)}.gkdp-actions{display:flex;gap:10px;justify-content:center;margin-top:10px;flex-wrap:wrap}.gkdp-btn{border-radius:10px;padding:10px 14px;font-weight:600;border:1px solid #e5e7eb;cursor:pointer}.gkdp-btn-primary{background:#10B981;color:#fff;border-color:#10B981}.gkdp-btn-primary:disabled{opacity:.6;cursor:not-allowed}.gkdp-footer{margin-top:10px;text-align:center;color:#9CA3AF;font-size:12px}';
      document.head.appendChild(style);
      const root = document.createElement('div');
      root.className = 'gkdp-modal-backdrop';
      root.innerHTML = '<div class="gkdp-modal" role="dialog" aria-modal="true" aria-label="feedback">'
        + '<div class="gkdp-title">'+L.title+'</div>'
        + '<div class="gkdp-sub">'+L.subtitle+'</div>'
        + '<div class="gkdp-stars" aria-label="rating">'
        + [1,2,3,4,5].map(n=>'<span class="gkdp-star" data-value="'+n+'" aria-label="'+n+'">‚òÜ</span>').join('')
        + '</div>'
        + '<div class="gkdp-actions">'
        + '<button type="button" class="gkdp-btn" data-action="later">'+L.later+'</button>'
        + '<button type="button" class="gkdp-btn gkdp-btn-primary" data-action="send" disabled>'+L.send+'</button>'
        + '</div>'
        + '<div class="gkdp-footer">GabaritKDP</div>'
        + '</div>';
      document.body.appendChild(root);
      const stars = Array.from(root.querySelectorAll('.gkdp-star'));
      const btnSend = root.querySelector('[data-action="send"]');
      const btnLater = root.querySelector('[data-action="later"]');
      let current = 0;
      const paint = (n)=>{ stars.forEach((s,i)=>{ s.textContent = i<n ? '‚òÖ' : '‚òÜ'; s.style.color = i<n ? '#F59E0B' : '#9CA3AF'; }); btnSend.disabled = n===0; };
      stars.forEach(s=>{
        s.addEventListener('mouseenter',()=>paint(+s.dataset.value));
        s.addEventListener('mouseleave',()=>paint(current));
        s.addEventListener('click',()=>{ current=+s.dataset.value; paint(current); });
      });
      function cleanup(){ try{ root.remove(); style.remove(); }catch(_){} }
      btnLater.addEventListener('click', cleanup);
      btnSend.addEventListener('click', ()=>{ cleanup(); window.open(redirectUrl,'_blank','noopener,noreferrer'); });
    } catch(e) { console.warn('Feedback modal error', e); }
  };
})();
</script>

<script>
  // URL de ton Worker Cloudflare (garde bien ton sous-domaine exact)
  window.WORKER_BASE = window.WORKER_BASE || "https://canva-token.amzkdptessa.workers.dev"; 
// <- adapte si besoin

  function getStored() {
    return {
      access: localStorage.getItem("canva_access_token"),
      refresh: localStorage.getItem("canva_refresh_token"),
      exp: parseInt(localStorage.getItem("canva_expires_at") || "0", 10),
    };
  }
  function storeTokens(data) {
    if (data.access_token) localStorage.setItem("canva_access_token", data.access_token);
    if (data.refresh_token) localStorage.setItem("canva_refresh_token", data.refresh_token);
    if (data.expires_in) localStorage.setItem("canva_expires_at", (Date.now() + data.expires_in * 1000).toString());
  }

  async function refreshIfNeeded() {
    const { access, refresh, exp } = getStored();
    if (!access || !refresh || !exp) throw new Error("Not authenticated");

    const soon = Date.now() + 60_000; // marge 60s
    if (exp > soon) return access;     // encore valide ‚Üí OK

    // Expir√© (ou bient√¥t) ‚Üí refresh c√¥t√© Worker
    const r = await fetch(`${WORKER_BASE}/refresh`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ refresh_token: refresh }),
      credentials: "include"
    });
    const data = await r.json();
    if (!r.ok) throw new Error(data?.error || "Refresh failed");
    // Canva renvoie souvent un NOUVEAU refresh_token
    storeTokens(data);
    return data.access_token;
  }

  // A utiliser avant chaque appel √† l‚ÄôAPI Canva
  async function getValidToken() {
    try {
      return await refreshIfNeeded();
    } catch (e) {
      console.error(e);
      alert("Session Canva expir√©e. Merci de vous reconnecter.");
      throw e;
    }
  }

  // Exemple d'usage (facultatif) :
  // async function testCanvaMe() {
  //   const token = await getValidToken();
  //   const res = await fetch("https://api.canva.com/rest/v1/me", {
  //     headers: { Authorization: `Bearer ${token}` }
  //   });
  //   console.log(await res.json());
  // }
</script>
<script>
  // URL de votre Worker Cloudflare (adapt√©e √† votre compte)
  window.WORKER_BASE = window.WORKER_BASE || "https://canva-token.amzkdptessa.workers.dev";
function getStored() {
    return {
      access: localStorage.getItem("canva_access_token"),
      refresh: localStorage.getItem("canva_refresh_token"),
      exp: parseInt(localStorage.getItem("canva_expires_at") || "0", 10),
    };
  }
  function storeTokens(data) {
    if (data.access_token) localStorage.setItem("canva_access_token", data.access_token);
    if (data.refresh_token) localStorage.setItem("canva_refresh_token", data.refresh_token);
    if (data.expires_in) localStorage.setItem("canva_expires_at", (Date.now() + data.expires_in * 1000).toString());
  }

  async function refreshIfNeeded() {
    const { access, refresh, exp } = getStored();
    if (!access || !refresh || !exp) throw new Error("Not authenticated");

    const soon = Date.now() + 60_000; // marge 60s
    if (exp > soon) return access;     // encore valide ‚Üí OK

    // Expir√© (ou bient√¥t) ‚Üí refresh c√¥t√© Worker
    const r = await fetch(`${WORKER_BASE}/refresh`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ refresh_token: refresh }),
      credentials: "include"
    });
    const data = await r.json();
    if (!r.ok) throw new Error(data?.error || "Refresh failed");
    // Canva renvoie souvent un NOUVEAU refresh_token
    storeTokens(data);
    return data.access_token;
  }

  // A utiliser avant chaque appel √† l‚ÄôAPI Canva
  async function getValidToken() {
    try {
      return await refreshIfNeeded();
    } catch (e) {
      console.error(e);
      alert("Session Canva expir√©e. Merci de vous reconnecter.");
      throw e;
    }
  }

  // Expose pour d'autres scripts si besoin
  window.getValidToken = getValidToken;
</script>
<script>
(function () {
  if (window.__kdp_canva_refresh_init) return;
  window.__kdp_canva_refresh_init = true;

  window.WORKER_BASE = window.WORKER_BASE || "https://canva-token.amzkdptessa.workers.dev";
function getStored() {
    return {
      access: localStorage.getItem("canva_access_token"),
      refresh: localStorage.getItem("canva_refresh_token"),
      exp: parseInt(localStorage.getItem("canva_expires_at") || "0", 10),
    };
  }
  function storeTokens(data) {
    if (data && typeof data === "object") {
      if (data.access_token) localStorage.setItem("canva_access_token", data.access_token);
      if (data.refresh_token) localStorage.setItem("canva_refresh_token", data.refresh_token);
      if (data.expires_in) localStorage.setItem("canva_expires_at", (Date.now() + data.expires_in * 1000).toString());
    }
  }

  async function refreshIfNeeded() {
    const { access, refresh, exp } = getStored();
    if (!access || !refresh || !exp) throw new Error("Not authenticated");

    const soon = Date.now() + 60_000;
    if (exp > soon) return access;

    const r = await fetch(`${window.WORKER_BASE}/refresh`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ refresh_token: refresh }),
      credentials: "include"
    });
    let data;
    try { data = await r.json(); } catch (_) { data = {}; }
    if (!r.ok) throw new Error((data && data.error) || "Refresh failed");
    storeTokens(data);
    return data.access_token;
  }

  window.getValidToken = async function () {
    try {
      return await refreshIfNeeded();
    } catch (e) {
      console.error(e);
      alert("Session Canva expir√©e. Merci de vous reconnecter.");
      throw e;
    }
  };
})();
</script>
<script>
(function(){
  if (window.__kdp_canva_automap_init) return;
  window.__kdp_canva_automap_init = true;

  function dispatchChange(el){ try{ el.dispatchEvent(new Event('change', {bubbles:true})); }catch(_){} }

  function findFrontInput(){
    return document.querySelector('#frontImageInput, input[name="frontImage"], input[id*="front"][type="url"], input[id*="front"][type="text"], input[id*="front"][type="hidden"]');
  }
  function findBackInput(){
    return document.querySelector('#backImageInput, input[name="backImage"], input[id*="back"][type="url"], input[id*="back"][type="text"], input[id*="back"][type="hidden"]');
  }

  function findFrontPreview(){
    return document.querySelector('#frontPreview, img#front, img[id*="front"], img[alt*="front" i], [data-role="frontPreview"] img, [data-front-preview]');
  }
  function findBackPreview(){
    return document.querySelector('#backPreview, img#back, img[id*="back"], img[alt*="back" i], [data-role="backPreview"] img, [data-back-preview]');
  }

  function setFront(url){
    const inp = findFrontInput(); if (inp){ inp.value = url; dispatchChange(inp); }
    const img = findFrontPreview(); if (img){ img.src = url; img.loading='eager'; img.decoding='async'; }
    console.log('[Canva] Front set ‚Üí', url);
  }
  function setBack(url){
    const inp = findBackInput(); if (inp){ inp.value = url; dispatchChange(inp); }
    const img = findBackPreview(); if (img){ img.src = url; img.loading='eager'; img.decoding='async'; }
    console.log('[Canva] Back set ‚Üí', url);
  }

  window.__kdp_setCanvaFront = setFront;
  window.__kdp_setCanvaBack = setBack;

  if (!window.__kdp_canva_onSelected) {
    window.__kdp_canva_onSelected = function(side, url){
      if (!url) return;
      if (side === 'back') setBack(url); else setFront(url);
    };
  }
})();
</script>

<script>
// ============================================================
// SCRIPT D'INT√âGRATION CANVA DESIGNS
// ============================================================
(function() {
  'use strict';
  
  // Mettre √† jour l'UI quand la connexion change
  function updateCanvaUI() {
    const notConnectedHelp = document.getElementById('canva-not-connected-help');
    const isConnected = window.CanvaDesigns && window.CanvaDesigns.isConnected();
    
    if (notConnectedHelp) {
      notConnectedHelp.style.display = isConnected ? 'none' : 'block';
    }
  }
  
  // √âcouter les changements dans localStorage (connexion/d√©connexion)
  window.addEventListener('storage', (e) => {
    if (e.key === 'canva_access_token') {
      updateCanvaUI();
      if (window.CanvaDesigns) {
        window.CanvaDesigns.updateStatus();
      }
    }
  });
  
  // Init apr√®s chargement
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', updateCanvaUI);
  } else {
    updateCanvaUI();
  }
  
  // Afficher un indicateur de chargement lors de l'export
  document.addEventListener('canva:export-start', () => {
    const loader = document.getElementById('canva-export-loading');
    if (loader) loader.classList.remove('hidden');
  });
  
  document.addEventListener('canva:export-end', () => {
    const loader = document.getElementById('canva-export-loading');
    if (loader) loader.classList.add('hidden');
  });
  
  // √âcouter l'√©v√©nement d'import de design Canva
  document.addEventListener('canva:design-imported', async (event) => {
    console.log('üé® [CANVA] Design import√©!', event.detail);
    
    const { imageUrl, action, designId } = event.detail;
    
    try {
      console.log('üì• [CANVA] Chargement image:', imageUrl);
      
      // Cr√©er une image pour charger et obtenir les dimensions
      const img = new Image();
      img.crossOrigin = "anonymous";
      
      img.onload = () => {
        console.log('‚úÖ [CANVA] Image charg√©e:', img.width, 'x', img.height);
        
        // Cr√©er l'objet imageData au format attendu par React
        const imageData = {
          url: imageUrl,
          naturalWidth: img.naturalWidth,
          naturalHeight: img.naturalHeight,
          file: null  // Pas de file car vient de Canva
        };
        
        // Importer selon l'action
        if (action === 'front') {
          console.log('üì± [CANVA] Import sur FACE');
          if (window.reactSetFrontImage) {
            window.reactSetFrontImage(imageData);
          } else {
            console.error('‚ùå reactSetFrontImage non disponible');
            // R√©essayer apr√®s un d√©lai
            setTimeout(() => {
              if (window.reactSetFrontImage) {
                window.reactSetFrontImage(imageData);
              } else {
                alert('Erreur: Fonction d\'import non disponible. Rechargez la page.');
              }
            }, 500);
          }
        } else if (action === 'back') {
          console.log('üîÑ [CANVA] Import sur VERSO');
          if (window.reactSetBackImage) {
            window.reactSetBackImage(imageData);
          } else {
            console.error('‚ùå reactSetBackImage non disponible');
            // R√©essayer apr√®s un d√©lai
            setTimeout(() => {
              if (window.reactSetBackImage) {
                window.reactSetBackImage(imageData);
              } else {
                alert('Erreur: Fonction d\'import non disponible. Rechargez la page.');
              }
            }, 500);
          }
        }
      };
      
      img.onerror = (error) => {
        console.error('‚ùå [CANVA] Erreur chargement image:', error);
        alert('Erreur lors du chargement de l\'image depuis Canva');
      };
      
      img.src = imageUrl;
      
    } catch (error) {
      console.error('‚ùå [CANVA] Erreur import:', error);
      alert('Erreur lors de l\'import: ' + error.message);
    }
  });
  
  console.log('‚úÖ Int√©gration Canva Designs initialis√©e');
})();
</script>

<!-- Syst√®me Beta 100 Founding Testers -->
<!-- Beta system d√©sactiv√© pour le lancement -->
<!-- <script src="beta-system.js"></script> -->

<!-- üî¥ Widget activit√© en temps r√©el - TEMPORAIREMENT D√âSACTIV√â -->
<!-- <script defer src="realtime-activity-widget.js"></script> -->

<!-- üé¨ THREE.JS BOOK 3D MOCKUP (Version D√©coupe Full Cover) -->
<script>
(function() {
    'use strict';
    
    // Variables globales
    let scene, camera, renderer, book, orbit, ground;
    let currentContainer = null;
    let animationId = null;
    let currentConfig = null;
    
    // Param√®tres fixes
    const RENDER_SCALE = 1.5;
    const SHADOW_MAP_SIZE = 2048;
    const PAGE_COLOR = '#fdfbf7';
    const BLEED_MM = 3.175;

    // üéÆ CONTROLES ORBITAUX MAISON
    class SimpleOrbit {
        constructor(cam, domElement) {
            this.cam = cam;
            this.dom = domElement;
            this.rotX = -0.2;
            this.rotY = -0.6;
            this.distance = 550;
            this.target = new THREE.Vector3(0, 0, 0);
            
            this.dragging = false;
            this.lastX = 0;
            this.lastY = 0;
            
            this._onStart = this._onStart.bind(this);
            this._onMove = this._onMove.bind(this);
            this._onEnd = this._onEnd.bind(this);
            this._onWheel = this._onWheel.bind(this);
            
            domElement.addEventListener('mousedown', this._onStart);
            domElement.addEventListener('touchstart', this._onStart, {passive: false});
            window.addEventListener('mousemove', this._onMove);
            window.addEventListener('touchmove', this._onMove, {passive: false});
            window.addEventListener('mouseup', this._onEnd);
            window.addEventListener('touchend', this._onEnd);
            domElement.addEventListener('wheel', this._onWheel, {passive: false});
            
            domElement.style.cursor = 'grab';
        }
        
        _onStart(e) {
            this.dragging = true;
            this.lastX = e.clientX || e.touches[0].clientX;
            this.lastY = e.clientY || e.touches[0].clientY;
            this.dom.style.cursor = 'grabbing';
        }
        
        _onMove(e) {
            if (!this.dragging) return;
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            if (clientX === undefined) return;

            const dx = clientX - this.lastX;
            const dy = clientY - this.lastY;
            
            this.rotY -= dx * 0.005;
            this.rotX -= dy * 0.005;
            this.rotX = Math.max(-1.4, Math.min(0.1, this.rotX));
            
            this.lastX = clientX;
            this.lastY = clientY;
            
            if (e.preventDefault) e.preventDefault();
        }
        
        _onEnd() {
            this.dragging = false;
            this.dom.style.cursor = 'grab';
        }
        
        _onWheel(e) {
            e.preventDefault();
            this.distance += e.deltaY * 0.5;
            this.distance = Math.max(200, Math.min(900, this.distance));
        }
        
        update() {
            const phi = Math.PI / 2 - this.rotX;
            const theta = this.rotY;
            
            this.cam.position.x = this.distance * Math.sin(phi) * Math.sin(theta);
            this.cam.position.y = this.distance * Math.cos(phi);
            this.cam.position.z = this.distance * Math.sin(phi) * Math.cos(theta);
            
            this.cam.lookAt(this.target);
        }
        
        setPreset(name) {
            const presets = {
                'perspective': { rx: -0.25, ry: -0.6, d: 550 },
                'flat': { rx: 0, ry: 0, d: 480 },
                'standing': { rx: -0.1, ry: -0.8, d: 580 }
            };
            if(presets[name]) {
                this.rotX = presets[name].rx;
                this.rotY = presets[name].ry;
                this.distance = presets[name].d;
            }
        }
        
        dispose() {
            this.dom.removeEventListener('mousedown', this._onStart);
            this.dom.removeEventListener('touchstart', this._onStart);
            window.removeEventListener('mousemove', this._onMove);
            window.removeEventListener('touchmove', this._onMove);
            window.removeEventListener('mouseup', this._onEnd);
            window.removeEventListener('touchend', this._onEnd);
            this.dom.removeEventListener('wheel', this._onWheel);
        }
    }

    // üõ†Ô∏è FONCTION MAGIQUE : D√©coupe du Full Cover
    function sliceFullCover(image, bookW_mm, bookH_mm, spine_mm) {
        const bleed = BLEED_MM;
        const imgW = image.naturalWidth;
        const imgH = image.naturalHeight;
        
        const totalMM = (bleed * 2) + (bookW_mm * 2) + spine_mm;
        const pxPerMM = imgW / totalMM;
        
        const bleedPx = bleed * pxPerMM;
        const widthPx = bookW_mm * pxPerMM;
        const spinePx = spine_mm * pxPerMM;
        
        // 1. FACE (Front) - Partie droite
        const frontC = document.createElement('canvas');
        frontC.width = widthPx;
        frontC.height = imgH;
        const frontOffset = bleedPx + widthPx + spinePx;
        frontC.getContext('2d').drawImage(image, frontOffset, 0, widthPx, imgH, 0, 0, widthPx, imgH);
        
        // 2. DOS (Back) - Partie gauche
        const backC = document.createElement('canvas');
        backC.width = widthPx;
        backC.height = imgH;
        backC.getContext('2d').drawImage(image, bleedPx, 0, widthPx, imgH, 0, 0, widthPx, imgH);
        
        // 3. TRANCHE (Spine) - Partie centrale
        const spineC = document.createElement('canvas');
        spineC.width = spinePx;
        spineC.height = imgH;
        const spineOffset = bleedPx + widthPx;
        spineC.getContext('2d').drawImage(image, spineOffset, 0, spinePx, imgH, 0, 0, spinePx, imgH);
        
        return {
            front: new THREE.CanvasTexture(frontC),
            back: new THREE.CanvasTexture(backC),
            spine: new THREE.CanvasTexture(spineC)
        };
    }

    // Texture proc√©durale pour les pages
    function createPagesTexture() {
        const c = document.createElement('canvas');
        c.width = 128; c.height = 128;
        const ctx = c.getContext('2d');
        ctx.fillStyle = PAGE_COLOR;
        ctx.fillRect(0,0,128,128);
        ctx.fillStyle = '#e8e6e1';
        for(let i=0; i<128; i+=2) ctx.fillRect(i,0,1,128);
        
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        return tex;
    }

    // üöÄ INITIALISATION
    window.initBook3D = function(container, config) {
        if (!container || !THREE) {
            console.error('‚ùå Three.js ou container non disponible');
            return;
        }
        if (currentContainer === container) {
            window.updateBook3D(config);
            return;
        }
        
        window.cleanupBook3D();
        currentContainer = container;
        currentConfig = config;
        
        const W = container.clientWidth;
        const H = container.clientHeight;
        
        // SCENE
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0d0f14);
        
        // CAMERA
        camera = new THREE.PerspectiveCamera(35, W/H, 10, 2000);
        
        // RENDERER
        renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true, 
            preserveDrawingBuffer: true
        });
        renderer.setSize(W, H);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);
        
        // CONTROLES
        orbit = new SimpleOrbit(camera, renderer.domElement);
        
        // LUMIERES
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(150, 200, 100);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = SHADOW_MAP_SIZE;
        dirLight.shadow.mapSize.height = SHADOW_MAP_SIZE;
        dirLight.shadow.bias = -0.0001;
        scene.add(dirLight);
        
        const backLight = new THREE.SpotLight(0xffffff, 0.4);
        backLight.position.set(-100, 100, -200);
        scene.add(backLight);
        
        // SOL
        const planeGeo = new THREE.PlaneGeometry(2000, 2000);
        const planeMat = new THREE.ShadowMaterial({ opacity: 0.2 });
        ground = new THREE.Mesh(planeGeo, planeMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Construction du livre
        buildBookGeometry(config);
        
        // Boucle de rendu
        const animate = () => {
            animationId = requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        };
        animate();
        
        // Resize handler
        const onResize = () => {
            if(!container) return;
            const w = container.clientWidth;
            const h = container.clientHeight;
            camera.aspect = w/h;
            camera.updateProjectionMatrix();
            renderer.setSize(w,h);
        };
        window.addEventListener('resize', onResize);
        container._resizeHandler = onResize;
        
        console.log('‚úÖ Book3D initialis√© avec Three.js');
    };
    
    // Construction de la g√©om√©trie
    function buildBookGeometry(cfg) {
        if(book) {
            scene.remove(book);
            book.geometry.dispose();
        }
        
        const scale = 1.5;
        const w = cfg.bookWidth * scale;
        const h = cfg.bookHeight * scale;
        // √âpaisseur plus g√©n√©reuse pour un vrai look livre
        const d = Math.max(35, cfg.spineWidth * scale * 2.5);
        
        if(ground) ground.position.y = -h/2 - 2;
        
        const geometry = new THREE.BoxGeometry(w, h, d);
        
        const pagesTex = createPagesTexture();
        const pageMat = new THREE.MeshStandardMaterial({ map: pagesTex, roughness: 0.9 });
        const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        
        // Faces: [Right, Left, Top, Bottom, Front, Back]
        const materials = [
            pageMat,  // 0: Right (Pages)
            whiteMat, // 1: Left (Spine)
            pageMat,  // 2: Top (Pages)
            pageMat,  // 3: Bottom (Pages)
            whiteMat, // 4: Front
            whiteMat  // 5: Back
        ];
        
        const loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous';
        
        // Cas 1 : FULL COVER (D√©coupe)
        if (cfg.isFullCover && cfg.coverUrl) {
            console.log('üé® Mode Full Cover - D√©coupe en cours...');
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = cfg.coverUrl;
            img.onload = () => {
                console.log('‚úÖ Image Full Cover charg√©e:', img.naturalWidth, 'x', img.naturalHeight);
                const textures = sliceFullCover(img, cfg.bookWidth, cfg.bookHeight, cfg.spineWidth);
                
                [textures.front, textures.back, textures.spine].forEach(t => {
                    t.colorSpace = THREE.SRGBColorSpace;
                    if(renderer) t.anisotropy = renderer.capabilities.getMaxAnisotropy();
                });
                
                materials[4] = new THREE.MeshStandardMaterial({ map: textures.front, roughness: 0.4 });
                materials[5] = new THREE.MeshStandardMaterial({ map: textures.back, roughness: 0.4 });
                materials[1] = new THREE.MeshStandardMaterial({ map: textures.spine, roughness: 0.5 });
                
                book.material = materials;
                console.log('‚úÖ Textures Full Cover appliqu√©es !');
            };
            img.onerror = (err) => console.error('‚ùå Erreur chargement Full Cover:', err);
        } 
        // Cas 2 : Images s√©par√©es
        else {
            if (cfg.coverUrl) {
                loader.load(cfg.coverUrl, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    materials[4] = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.4 });
                    book.material = materials;
                });
            }
            if (cfg.backUrl) {
                loader.load(cfg.backUrl, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    materials[5] = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.4 });
                    book.material = materials;
                });
            } else {
                materials[5] = new THREE.MeshStandardMaterial({ color: 0x222222 });
            }
            materials[1] = new THREE.MeshStandardMaterial({ color: cfg.spineColor || 0x222222 });
        }
        
        book = new THREE.Mesh(geometry, materials);
        book.castShadow = true;
        book.receiveShadow = true;
        scene.add(book);
    }

    // Mise √† jour
    window.updateBook3D = function(newConfig) {
        if (!scene) return;
        buildBookGeometry({ ...currentConfig, ...newConfig });
        currentConfig = { ...currentConfig, ...newConfig };
    };

    // Presets
    window.setBook3DPreset = function(preset) {
        if (orbit) orbit.setPreset(preset);
    };
    
    // Export PNG
    window.exportBook3DPNG = function() {
        if (!renderer) {
            alert('Mockup 3D non initialis√©');
            return;
        }
        renderer.render(scene, camera);
        const data = renderer.domElement.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = data;
        a.download = 'book-mockup-3d.png';
        a.click();
        console.log('‚úÖ Export PNG r√©ussi');
    };
    
    // Nettoyage
    window.cleanupBook3D = function() {
        if (animationId) cancelAnimationFrame(animationId);
        if (currentContainer && currentContainer._resizeHandler) {
            window.removeEventListener('resize', currentContainer._resizeHandler);
        }
        if (renderer) {
            renderer.dispose();
            if(renderer.domElement.parentNode) renderer.domElement.parentNode.removeChild(renderer.domElement);
        }
        if (orbit) orbit.dispose();
        
        scene = null;
        camera = null;
        renderer = null;
        book = null;
        orbit = null;
        ground = null;
        currentContainer = null;
        currentConfig = null;
    };
    
    console.log('‚úÖ Script Book3D Three.js (Full Cover) charg√©');
})();
</script>

<script src="./logout-button.js" defer></script>
</body></body>
</html>
